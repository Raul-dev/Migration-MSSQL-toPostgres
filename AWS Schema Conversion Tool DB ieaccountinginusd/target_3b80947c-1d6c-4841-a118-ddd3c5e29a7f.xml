<?xml version="1.0" encoding="UTF-8"?>
<tree>
    <complex-attributes>
        <type name="materialized-view">
            <attr name="sql"></attr>
        </type>
        <type name="view">
            <attr name="sql"></attr>
        </type>
        <type name="metadata">
            <attr name="vendor-engine"></attr>
        </type>
        <type name="function">
            <attr name="sql"></attr>
        </type>
        <type name="constraint">
            <attr name="check-clause"></attr>
        </type>
        <type name="trigger">
            <attr name="trigger-definition"></attr>
            <attr name="comment"></attr>
            <attr name="sql"></attr>
        </type>
        <type name="procedure">
            <attr name="sql"></attr>
        </type>
    </complex-attributes>
    <metadata _I_D="7fe88c54-7b26-4d05-a71b-0b8a11626aa2" vendor="POSTGRESQL" name="PostgreSQL - localhost:54321:ieaccountinginusd" metaStorageUuid="3b80947c-1d6c-4841-a118-ddd3c5e29a7f" nonquoted-case="lower" allow-similarly-named-objects="y" quoted-case="specified" connection-data="postgres@localhost:54321/ieaccountinginusd" product-version="14.5.0.0" vendor-engine-version="14.5" mdl-waiting-complex-attributes="" connection-identifier="821314433d5d4c133699d85f5521743a" max-identifier-length="63">
        <complex-attribute name="vendor-engine"><![CDATA[PostgreSQL 14.5 on x86_64-pc-linux-musl, compiled by gcc (Alpine 11.2.1_git20220219) 11.2.1 20220219, 64-bit]]></complex-attribute>
        <category _I_D="c4508e5f-daa5-4e42-97da-21a51f2b995b" name="Schemas" order-num="0" objects-loading="extended" subcategories-loading="none" child-type="schema">
            <schema _I_D="5b00fb30-921f-4cac-925e-a83e1e72ab9f" name="aws_sqlserver_ext" is-empty="N" context="aws_sqlserver_ext" subcategories-loading="none" object-loading="extended" schema-owner="postgres" is-system="N">
                <category _I_D="d7c84c45-d0fe-40ec-b0d4-6c3f67bf97e1" name="Tables" order-num="0" objects-loading="extended" subcategories-loading="none" child-type="table">
                    <table _I_D="ae6fa85a-599b-4db8-8d4e-f5100bc12361" name="sys_languages" context="sys_languages" subcategories-loading="none" object-loading="extended" partitioned="NO" is-typed="NO" is-unlogged="NO" comment="This table contains complete info about languages present in the instance of MS SQL Server.">
                        <category _I_D="19d80f34-8204-4500-bd02-fc1f1fa1c107" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="bd80b57d-ec4b-4e77-8438-f73b6b9b3595" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="b07c1897-aadd-4a80-8a64-b7ce47d2dd27" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="21290274-7605-47c5-ba45-e87c54923d10" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="1"/>
                        <category _I_D="47554763-2746-4405-a60a-9745cb16a066" name="Indexes" order-num="4" objects-loading="none" subcategories-loading="none" child-type="index" mdl-expected-node-count="2"/>
                        <category _I_D="ae185e28-367f-4258-be31-0fec747f5910" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="4bf93d29-2c63-49c7-b00f-3861d34804cc" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="fc17bfe9-d2c8-4e7d-8bf3-03c55f4e75e6" name="sysjobhistory" context="sysjobhistory" subcategories-loading="none" object-loading="extended" partitioned="NO" is-typed="NO" is-unlogged="NO">
                        <category _I_D="cd81da94-870e-4917-ba69-e2d46b1b54d3" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="be2743e4-9209-4c48-a3ad-d576c0540ff5" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="02f3171a-68cf-4897-a093-b3196cc2ca36" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="287d35e4-54f2-424a-a63b-bd19eb7d5383" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="1"/>
                        <category _I_D="09e85b6d-aefa-417b-9e63-86b90c265235" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="d3b153d1-052b-4755-bd08-bae2a0a9c59e" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="11d92c79-adcb-47d3-bc2c-190485f23e45" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="46fabd1b-da18-43f1-b1d8-cf76c5cc5cda" name="sysjobs" context="sysjobs" subcategories-loading="none" object-loading="extended" partitioned="NO" is-typed="NO" is-unlogged="NO">
                        <category _I_D="760dab19-4b36-42b2-9a26-b21983bf4e6f" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="49c1a087-2a1b-4dd9-964a-2121801b5a84" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="23c159ee-f772-454a-ba90-b27fd361c85d" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="d87c0ab7-7a4f-4b92-a8db-6c900c15486d" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="1"/>
                        <category _I_D="6cb614d7-3da9-4990-9083-b346bfe95424" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="009aa7d1-c7ea-48ad-9202-8b3c484c1b6f" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="8e2685a2-ae8f-42a7-909b-01cd9e701312" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="1846fdae-f040-42cb-83ec-b9eb74adc67b" name="sysjobschedules" context="sysjobschedules" subcategories-loading="none" object-loading="extended" partitioned="NO" is-typed="NO" is-unlogged="NO">
                        <category _I_D="ac28ec40-ab51-4f47-b770-fb0fe090fffa" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="b48a4727-9419-4aa1-bb00-ebcbc451ef49" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="77b8b9ed-bfae-4b5d-ad5f-fb06f12584a2" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="d153d8e9-7e50-4132-83f2-7500f161b4d9" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="2"/>
                        <category _I_D="fb71d789-b7ec-44a6-b295-c334c238a658" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="e0255097-72b0-4dd8-bfd6-529e4bc1836b" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="f3079552-90e6-4f8e-9d7e-b6f4ed8b3458" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="5c00b597-ad10-4af9-a803-cd40e5edf63d" name="sysjobsteps" context="sysjobsteps" subcategories-loading="none" object-loading="extended" partitioned="NO" is-typed="NO" is-unlogged="NO">
                        <category _I_D="ea560e75-5463-4d16-b746-a495d187fa3b" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="8fc10e35-ba2b-42e9-a094-4a65d22d7aa6" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="b22caede-5531-4558-b445-2856391de2cc" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="5706f603-0c26-46af-9d00-35a7e4c3f0bf" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="1"/>
                        <category _I_D="3603234a-6c4a-4c13-9507-0e609007eb3c" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="47c5f709-523e-4141-bc7b-2ce5f8f51fd0" name="Triggers" order-num="5" objects-loading="none" subcategories-loading="none" child-type="trigger" mdl-expected-node-count="2"/>
                        <category _I_D="4b43956a-6577-4fce-9bc2-8a961ff1f2fa" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="5cd96b0e-95dd-4fec-bd27-747f19af4d50" name="sysmail_account" context="sysmail_account" subcategories-loading="none" object-loading="extended" partitioned="NO" is-typed="NO" is-unlogged="NO">
                        <category _I_D="b1d4e21c-bf7d-4b99-b2b3-8fbc6a2f137b" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="c5be0cce-4634-4fbc-85ed-447847061070" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="ec3f70d7-7bfb-4bf9-b802-6e8d0741b219" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="6fbc2f40-a56d-4108-b4f3-6fb071df9601" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="2"/>
                        <category _I_D="10ff67ae-3f8f-4799-88e2-162c05466fa9" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="a88a792e-d6dd-4e31-886d-b970c221b0b1" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="3590fae3-e525-40ac-8bdb-e32834a6eed4" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="5f5e90dc-de14-46be-8804-f8ba6065901e" name="sysmail_attachments" context="sysmail_attachments" subcategories-loading="none" object-loading="extended" partitioned="NO" is-typed="NO" is-unlogged="NO">
                        <category _I_D="49c4aee7-3fa5-4ade-beaa-b15d6880b047" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="016d7ba5-e7eb-4565-9fa2-1db005200135" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="04a5ca6e-5e89-47c4-bc4d-8bf5333370ad" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="fa4850b0-1e2a-4a60-9c93-7efbc89cf0b6" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="2"/>
                        <category _I_D="acb2f534-2c6d-479e-a5a2-55850ab7bb7b" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="d571ed94-6f7b-465f-8914-f61ed38e2735" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="01926962-d56b-4c70-ab49-eb350dad61a7" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="76be7a87-f2e9-442c-918e-009d70789fe2" name="sysmail_log" context="sysmail_log" subcategories-loading="none" object-loading="extended" partitioned="NO" is-typed="NO" is-unlogged="NO">
                        <category _I_D="65b20b43-63b2-4dca-aaee-11767ca356b5" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="ffa73ad9-4b00-430c-b140-79ac508157b5" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="cf3f7a22-c07d-4545-843c-dbefe9e4d225" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="721757eb-efcb-451b-b0b5-08d8f7640ee6" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="2"/>
                        <category _I_D="157a0d2c-a295-47c2-bdae-9911dd86d198" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="a272965a-fe1b-4bfe-b1a6-dd0f8b6c8aa0" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="b89169db-840e-4ef2-b488-33054d5e811a" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="69bc26a6-fd5d-45b4-ba72-03ff1d65250e" name="sysmail_mailitems" context="sysmail_mailitems" subcategories-loading="none" object-loading="extended" partitioned="NO" is-typed="NO" is-unlogged="NO">
                        <category _I_D="91cff56a-84cf-402d-8ba3-7f687f3be658" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="8fd0603a-1381-4b31-b53c-0191f28aba51" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="314a9549-6d3c-411e-b4a1-be2ecbb8b3d5" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="d3dfce30-a220-47e1-98b0-faa9512accc1" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="1"/>
                        <category _I_D="6e86a7be-5739-460e-8bfb-7e87e85d0de8" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="1edd4011-ecf6-4304-9766-6aab1eb70d96" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="e246551a-1be4-4d46-909a-c2e26f8996e4" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="ff438533-7239-45f3-a0d5-4e93da9f00e0" name="sysmail_profile" context="sysmail_profile" subcategories-loading="none" object-loading="extended" partitioned="NO" is-typed="NO" is-unlogged="NO">
                        <category _I_D="dde50eff-66a1-429b-9229-0ac38478d3d2" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="f9958c0d-6549-442c-bc82-53dddd801ece" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="41034554-de00-446e-9203-3edd818d9a8e" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="e120f584-faa1-4eeb-a518-a4282e23ba8b" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="2"/>
                        <category _I_D="908c5aa9-ce3a-450d-83c7-8e207fefd2c9" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="65d39048-e3a1-477c-a67d-300ba69f7298" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="e9823157-0212-4d80-b614-351134795de7" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="4deae797-6060-4a03-84e2-b9a8207ef29c" name="sysmail_profileaccount" context="sysmail_profileaccount" subcategories-loading="none" object-loading="extended" partitioned="NO" is-typed="NO" is-unlogged="NO">
                        <category _I_D="c51d1424-9fcd-4951-a7a3-54b49a678822" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="5779cb1f-7c14-4b7b-a6a0-9b2e6b52c28b" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="0b93358f-1bc6-41b3-b3e1-a4f68691ad33" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="2b310f3b-961f-4e95-b4e4-4b4c5345c7c8" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="2"/>
                        <category _I_D="bcdbbe30-fd37-4818-98bf-c04cd2ea8c16" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="f0df6f36-cde8-49a1-b721-0761fe44d6e0" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="aa6e5f1b-eaef-4b17-b6b6-d28a1eec9f63" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="242e9653-d6ab-484e-b24d-eb4b800b03ff" name="sysmail_server" context="sysmail_server" subcategories-loading="none" object-loading="extended" partitioned="NO" is-typed="NO" is-unlogged="NO">
                        <category _I_D="b6a32efa-9d18-492f-99a6-727c95031ef2" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="5b753c29-c21f-42ba-95d1-76e2ab5fa580" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="120bf0bc-4806-4d46-aa40-829cc9c163d6" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="cb093084-aca4-4675-8817-d8d45cea2ffe" name="Constraints" order-num="3" objects-loading="empty" subcategories-loading="full" child-type="constraint" mdl-expected-node-count="0"/>
                        <category _I_D="79521767-4126-4f3d-84c5-7628f361f454" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="e8c6acae-55ba-4d80-8b94-93441c2c0166" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="5d09d541-02a0-4ba2-8f37-ce800fb122a3" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="8ce51833-cd06-43ab-a698-cbe02e3868aa" name="sysschedules" context="sysschedules" subcategories-loading="none" object-loading="extended" partitioned="NO" is-typed="NO" is-unlogged="NO">
                        <category _I_D="4e6e35e8-a6e3-43d2-a224-007d987ac0fb" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="a3c6142a-aa65-4474-9df4-fd22152a60e1" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="dae03d15-70e8-499f-b5d6-5c373878c532" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="1b857c0e-1930-41f9-92f8-1993d3d02988" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="1"/>
                        <category _I_D="1429f7e5-27e8-4f66-9d34-407fbb220d60" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="2f905bdb-889e-4dca-8f34-7ae74715b473" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="25a697c4-6017-4c4f-80b7-01d9c8667d1b" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="e682aa8f-386a-4ff5-9a75-e94187c2ba84" name="versions" context="versions" subcategories-loading="none" object-loading="extended" partitioned="NO" is-typed="NO" is-unlogged="NO">
                        <category _I_D="4b7a56b4-d0db-4acf-8ea0-4010d59c0daa" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="acc1c129-f0f0-40e4-826a-6ebad3b746e3" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="b09bc629-f738-418f-a81b-ee8ace99aeee" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="6ddc5f34-7b11-4462-ad4d-39af569ff019" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="1"/>
                        <category _I_D="b0cb3edb-dcdd-45aa-aaaf-fe8a80e7d4f6" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="cd3a4695-5a33-4412-af5b-d42327e9b515" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="cfaf30e2-d1a9-49c5-8ce5-db4b1aafe33c" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                </category>
                <category _I_D="7d7dbd84-ea5f-47b4-ad21-e543860a280c" name="Foreign tables" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="foreigntable"/>
                <category _I_D="57f55fcf-1fe7-4dd3-8bf6-dd2366433f15" name="Views" order-num="2" objects-loading="extended" subcategories-loading="none" child-type="view">
                    <view _I_D="0f7d2d4d-f608-4ac0-beb5-73f910bcde00" name="information_schema_check_constraints" context="information_schema_check_constraints" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT current_database() AS constraint_catalog,
    s.nspname AS constraint_schema,
    c.conname AS constraint_name,
    pg_get_constraintdef(c.oid) AS check_clause
   FROM (pg_constraint c
     JOIN pg_namespace s ON ((s.oid = c.connamespace)))
  WHERE ((s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name])) AND (c.contype = 'c'::"char"));]]></complex-attribute>
                        <category _I_D="c3679699-f593-45c5-8511-65dffab1e0ba" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="dd8fde22-f7e0-4ee1-931c-affb4704adaa" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="c2669c50-c78c-4a86-b252-60f1d8fe352d" name="information_schema_columns" context="information_schema_columns" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT current_database() AS table_catalog,
    s.nspname AS table_schema,
    c.relname AS table_name,
    a.attname AS column_name,
    a.attnum AS ordinal_position,
    pg_get_expr(d.adbin, d.adrelid) AS column_default,
        CASE
            WHEN a.attnotnull THEN 'NO'::character varying(3)
            ELSE 'YES'::character varying(3)
        END AS is_nullable,
    format_type(t.oid, NULL::integer) AS data_type,
    a.attlen AS character_maximum_length,
    a.attlen AS character_octet_length,
    NULL::integer AS numeric_precision,
    NULL::integer AS numeric_precision_radix,
    NULL::integer AS numeric_scale,
    NULL::integer AS datetime_precision,
    NULL::character varying(128) AS character_set_catalog,
    NULL::character varying(128) AS character_set_schema,
    NULL::character varying(128) AS character_set_name,
    NULL::character varying(128) AS collation_catalog,
    NULL::character varying(128) AS collation_schema,
    coll.collname AS collation_name,
    NULL::character varying(128) AS domain_catalog,
    NULL::character varying(128) AS domain_schema,
        CASE t.typtype
            WHEN 'd'::"char" THEN (t.typname)::character varying(128)
            ELSE NULL::character varying(128)
        END AS domain_name
   FROM (((((pg_attribute a
     JOIN pg_class c ON (((c.oid = a.attrelid) AND (c.relkind = 'r'::"char"))))
     LEFT JOIN pg_attrdef d ON (((d.adrelid = c.oid) AND (d.adnum = a.attnum))))
     JOIN pg_namespace s ON ((s.oid = c.relnamespace)))
     JOIN pg_type t ON ((t.oid = a.atttypid)))
     LEFT JOIN pg_collation coll ON ((coll.oid = t.typcollation)))
  WHERE (s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name]));]]></complex-attribute>
                        <category _I_D="6290614c-f516-49ab-bc19-3437109ef3d3" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="88e8d223-b7e3-4808-8936-f2c4b321d378" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="11f03200-084b-4ecf-be7d-8cbc4290c77a" name="information_schema_constraint_column_usage" context="information_schema_constraint_column_usage" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT current_database() AS table_catalog,
    s.nspname AS table_schema,
    t.relname AS table_name,
    a.attname AS column_name,
    current_database() AS constraint_catalog,
    s.nspname AS constraint_schema,
    c.conname AS constraint_name
   FROM (((pg_constraint c
     JOIN pg_namespace s ON ((s.oid = c.connamespace)))
     JOIN pg_class t ON ((t.oid = c.conrelid)))
     JOIN pg_attribute a ON (((a.attrelid = c.conrelid) AND (a.attnum = ANY (c.conkey)))))
  WHERE (s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name]));]]></complex-attribute>
                        <category _I_D="e1f5771b-4a36-4115-833c-2a7429075f15" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="87ee584e-7f9e-4334-91f0-390cda40a5dd" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="12d04282-ec49-43ac-aaa2-f7742d202b22" name="information_schema_constraint_table_usage" context="information_schema_constraint_table_usage" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT current_database() AS table_catalog,
    s.nspname AS table_schema,
    t.relname AS table_name,
    current_database() AS constraint_catalog,
    s.nspname AS constraint_schema,
    c.conname AS constraint_name
   FROM ((pg_constraint c
     JOIN pg_namespace s ON ((s.oid = c.connamespace)))
     JOIN pg_class t ON ((t.oid = c.conrelid)))
  WHERE (s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name]));]]></complex-attribute>
                        <category _I_D="1d7ba6f9-9ae9-44fc-9cc2-3b0b4378e2a6" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="e9e297c0-fda0-4a00-b530-2b3e16d4d1ec" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="9533c1de-734b-4276-894f-ce159ccfbf03" name="information_schema_key_column_usage" context="information_schema_key_column_usage" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT current_database() AS constraint_catalog,
    s.nspname AS constraint_schema,
    c.conname AS constraint_name,
    current_database() AS table_catalog,
    s.nspname AS table_schema,
    t.relname AS table_name,
    a.attname AS column_name,
    a.attnum AS ordinal_position
   FROM (((pg_constraint c
     JOIN pg_attribute a ON (((a.attrelid = c.conrelid) AND (a.attnum = ANY (c.conkey)))))
     JOIN pg_namespace s ON ((s.oid = c.connamespace)))
     JOIN pg_class t ON ((t.oid = c.conrelid)))
  WHERE ((s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name])) AND (c.contype = 'p'::"char"));]]></complex-attribute>
                        <category _I_D="7375b457-2cfa-4a7f-8468-eefe84e43ee8" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="ce80c074-2cb2-4444-8aca-4993ea833910" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="e2c767bf-5820-4de6-96df-e71cd4b7a461" name="information_schema_referential_constraints" context="information_schema_referential_constraints" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT current_database() AS constraint_catalog,
    s.nspname AS constraint_schema,
    c.conname AS constraint_name,
    current_database() AS unique_constraint_catalog,
    ( SELECT pk.conname
           FROM pg_constraint pk
          WHERE ((pk.conrelid = c.confrelid) AND (pk.contype = 'p'::"char"))
         LIMIT 1) AS conname,
    'SIMPLE'::character varying(7) AS match_option,
        CASE c.confupdtype
            WHEN 'a'::"char" THEN 'NO_ACTION'::text
            WHEN 'r'::"char" THEN 'NO_ACTION'::text
            WHEN 'c'::"char" THEN 'CASCADE'::text
            WHEN 'n'::"char" THEN 'SET_NULL'::text
            WHEN 'd'::"char" THEN 'SET_DEFAULT'::text
            ELSE NULL::text
        END AS update_rule,
        CASE c.confdeltype
            WHEN 'a'::"char" THEN 'NO_ACTION'::text
            WHEN 'r'::"char" THEN 'NO_ACTION'::text
            WHEN 'c'::"char" THEN 'CASCADE'::text
            WHEN 'n'::"char" THEN 'SET_NULL'::text
            WHEN 'd'::"char" THEN 'SET_DEFAULT'::text
            ELSE NULL::text
        END AS delete_rule
   FROM (pg_constraint c
     JOIN pg_namespace s ON ((s.oid = c.connamespace)))
  WHERE ((s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name])) AND (c.contype = 'f'::"char"));]]></complex-attribute>
                        <category _I_D="4ae762c5-2c39-4e54-8947-af1b941b32ad" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="ed2bc740-879e-4d95-90e7-b39e137d3993" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="c6e65694-b509-4733-bbb1-1e8923fddb8a" name="information_schema_routines" context="information_schema_routines" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT current_database() AS specific_catalog,
    s.nspname AS specific_schema,
    p.proname AS specific_name,
    current_database() AS routine_catalog,
    s.nspname AS routine_schema,
    p.proname AS routine_name,
        CASE format_type(p.prorettype, NULL::integer)
            WHEN 'void'::text THEN 'PROCEDURE'::character varying(20)
            ELSE 'FUNCTION'::character varying(20)
        END AS routine_type,
    NULL::character varying(128) AS module_catalog,
    NULL::character varying(128) AS module_schema,
    NULL::character varying(128) AS module_name,
    NULL::character varying(128) AS udt_catalog,
    NULL::character varying(128) AS udt_schema,
    NULL::character varying(128) AS udt_name,
        CASE format_type(p.prorettype, NULL::integer)
            WHEN 'void'::text THEN (NULL::character varying(128))::text
            ELSE format_type(p.prorettype, NULL::integer)
        END AS data_type,
    t.typlen AS character_maximum_length,
    t.typlen AS character_octet_length,
    NULL::character varying(128) AS collation_catalog,
    NULL::character varying(128) AS collation_schema,
    c.collname,
    NULL::character varying(128) AS character_set_catalog,
    NULL::character varying(128) AS character_set_schema,
    ( SELECT pg_encoding_to_char(pg_database.encoding) AS pg_encoding_to_char
           FROM pg_database
          WHERE (pg_database.datname = current_database())) AS character_set_name,
    NULL::smallint AS numeric_precision,
    NULL::smallint AS numeric_precision_radix,
    NULL::smallint AS numeric_scale,
    NULL::smallint AS datetime_precision,
    NULL::character varying(30) AS interval_type,
    NULL::smallint AS interval_precision,
    NULL::character varying(128) AS type_udt_catalog,
    NULL::character varying(128) AS type_udt_schema,
    NULL::character varying(128) AS type_udt_name,
    NULL::character varying(128) AS scope_catalog,
    NULL::character varying(128) AS scope_schema,
    NULL::character varying(128) AS scope_name,
    NULL::bigint AS maximum_cardinality,
    NULL::character varying(128) AS dtd_identifier,
    'SQL'::character varying(30) AS routine_body,
    pg_get_functiondef(p.oid) AS routine_definition,
    NULL::character varying(128) AS external_name,
    NULL::character varying(30) AS external_language,
    NULL::character varying(30) AS parameter_style,
        CASE p.provolatile
            WHEN 'i'::"char" THEN 'YES'::text
            ELSE 'NO'::text
        END AS is_deterministic,
        CASE format_type(p.prorettype, NULL::integer)
            WHEN 'void'::text THEN 'MODIFIES'::character varying(30)
            ELSE 'READS'::character varying
        END AS sql_data_access,
        CASE
            WHEN p.proisstrict THEN 'NO'::character varying(10)
            ELSE NULL::character varying(10)
        END AS is_null_call,
    NULL::character varying(128) AS sql_path,
    'YES'::character varying(10) AS schema_level_routine,
    0 AS max_dynamic_result_sets,
    'NO'::character varying(10) AS is_user_defined_cast,
    'NO'::character varying(10) AS is_implicitly_invocable,
    NULL::timestamp without time zone AS created,
    NULL::timestamp without time zone AS last_altered
   FROM (((pg_proc p
     JOIN pg_namespace s ON ((s.oid = p.pronamespace)))
     JOIN pg_type t ON ((t.oid = p.prorettype)))
     LEFT JOIN pg_collation c ON ((c.oid = t.typcollation)))
  WHERE ((s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name])) AND pg_function_is_visible(p.oid));]]></complex-attribute>
                        <category _I_D="f4f56ddd-5ee6-4b6e-ab54-b8f93ee291e1" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="b10258df-debc-46d5-b14c-c600761e28da" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="c62fd8c7-6d90-4184-8fa8-c74a3c34b616" name="information_schema_schemata" context="information_schema_schemata" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT current_database() AS catalog_name,
    s.nspname AS schema_name,
    a.rolname AS schema_owner,
    NULL::character varying(6) AS default_character_set_catalog,
    NULL::character varying(6) AS default_character_set_schema,
    ( SELECT pg_encoding_to_char(pg_database.encoding) AS pg_encoding_to_char
           FROM pg_database
          WHERE (pg_database.datname = current_database())) AS default_character_set_name
   FROM (pg_namespace s
     JOIN pg_authid a ON ((a.oid = s.nspowner)))
  WHERE (has_schema_privilege((s.nspname)::text, 'USAGE'::text) AND (s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name])));]]></complex-attribute>
                        <category _I_D="0ad6db78-7fc3-4b60-ac0e-778d55949259" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="92a28528-db35-49c9-9a23-c07d55c80c68" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="eb54ad4e-3d06-44db-83a6-fb85b2e1eb80" name="information_schema_table_constraints" context="information_schema_table_constraints" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT current_database() AS constraint_catalog,
    s.nspname AS constraint_schema,
    c.conname AS constraint_name,
    current_database() AS table_catalog,
    s.nspname AS table_schema,
    t.relname AS table_name,
        CASE c.contype
            WHEN 'c'::"char" THEN 'CHECK'::text
            WHEN 'f'::"char" THEN 'FOREIGN KEY'::text
            WHEN 'p'::"char" THEN 'PRIMARY KEY'::text
            WHEN 'u'::"char" THEN 'UNIQUE'::text
            ELSE 'OTHER'::text
        END AS constraint_type,
    'NO'::character varying(2) AS is_deferrable,
    'NO'::character varying(2) AS initially_deferred
   FROM ((pg_constraint c
     JOIN pg_namespace s ON ((s.oid = c.connamespace)))
     JOIN pg_class t ON ((t.oid = c.conrelid)))
  WHERE (s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name]));]]></complex-attribute>
                        <category _I_D="723959ef-f173-43e9-bc91-ddfe3c62b5d9" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="f8534d18-6cbb-4f54-a6c8-958f1e4b0d03" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="7e18e44f-797d-4708-bd79-d8392cff0752" name="information_schema_tables" context="information_schema_tables" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT current_database() AS table_catalog,
    s.nspname AS table_schema,
    t.tablename AS table_name,
    'BASE TABLE'::text AS table_type
   FROM ((pg_tables t
     JOIN pg_namespace s ON ((s.nspname = t.schemaname)))
     JOIN pg_class c ON (((c.relname = t.tablename) AND (c.relnamespace = s.oid))))
  WHERE (s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name]))
UNION ALL
 SELECT current_database() AS table_catalog,
    s.nspname AS table_schema,
    v.viewname AS table_name,
    'VIEW'::text AS table_type
   FROM ((pg_views v
     JOIN pg_namespace s ON ((s.nspname = v.schemaname)))
     JOIN pg_class c ON (((c.relname = v.viewname) AND (c.relnamespace = s.oid))))
  WHERE (s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name]));]]></complex-attribute>
                        <category _I_D="7d43f3bb-0770-4928-af0d-584f4eb24610" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="3bcc0fae-0bb9-4254-91b3-5622e709d2da" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="b1c05836-979d-4cd9-88fb-0df4fce45928" name="information_schema_views" context="information_schema_views" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT current_database() AS table_catalog,
    s.nspname AS table_schema,
    v.viewname AS table_name,
    v.definition AS view_definition,
    'NONE'::character varying(7) AS check_option,
    'NO'::character varying(2) AS is_updatable
   FROM ((pg_views v
     JOIN pg_namespace s ON ((s.nspname = v.schemaname)))
     JOIN pg_class c ON (((c.relname = v.viewname) AND (c.relnamespace = s.oid))))
  WHERE (s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name]));]]></complex-attribute>
                        <category _I_D="09d0f256-c3d9-49c6-92c0-c1aa5c3eaabb" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="069f30e9-e4de-4f0f-a76c-363c45fe20ab" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="548ba40d-0eb3-4ad9-b04e-1688f260ee37" name="sys_all_columns" context="sys_all_columns" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT c.oid AS object_id,
    a.attname AS name,
    a.attnum AS column_id,
    t.oid AS system_type_id,
    t.oid AS user_type_id,
    a.attlen AS max_length,
    NULL::integer AS "precision",
    NULL::integer AS scale,
    coll.collname AS collation_name,
        CASE
            WHEN a.attnotnull THEN 0
            ELSE 1
        END AS is_nullable,
    0 AS is_ansi_padded,
    0 AS is_rowguidcol,
    0 AS is_identity,
    0 AS is_computed,
    0 AS is_filestream,
    0 AS is_replicated,
    0 AS is_non_sql_subscribed,
    0 AS is_merge_published,
    0 AS is_dts_replicated,
    0 AS is_xml_document,
    0 AS xml_collection_id,
    COALESCE(d.oid, (0)::oid) AS default_object_id,
    COALESCE(( SELECT pg_constraint.oid
           FROM pg_constraint
          WHERE ((pg_constraint.conrelid = t.oid) AND (pg_constraint.contype = 'c'::"char") AND (a.attnum = ANY (pg_constraint.conkey)))
         LIMIT 1), (0)::oid) AS rule_object_id,
    0 AS is_sparse,
    0 AS is_column_set,
    0 AS generated_always_type,
    'NOT_APPLICABLE'::character varying(60) AS generated_always_type_desc,
    NULL::integer AS encryption_type,
    NULL::character varying(64) AS encryption_type_desc,
    NULL::character varying AS encryption_algorithm_name,
    NULL::integer AS column_encryption_key_id,
    NULL::character varying AS column_encryption_key_database_name,
    0 AS is_hidden,
    0 AS is_masked
   FROM (((((pg_attribute a
     JOIN pg_class c ON ((c.oid = a.attrelid)))
     JOIN pg_type t ON ((t.oid = a.atttypid)))
     JOIN pg_namespace s ON ((s.oid = c.relnamespace)))
     LEFT JOIN pg_attrdef d ON (((c.oid = d.adrelid) AND (a.attnum = d.adnum))))
     LEFT JOIN pg_collation coll ON ((coll.oid = t.typcollation)))
  WHERE ((NOT a.attisdropped) AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'm'::"char", 'f'::"char", 'p'::"char"])) AND has_column_privilege(((quote_ident((s.nspname)::text) || '.'::text) || quote_ident((c.relname)::text)), (a.attname)::text, 'SELECT,INSERT,UPDATE,REFERENCES'::text));]]></complex-attribute>
                        <category _I_D="1d950880-91a8-493e-8307-339e7ce61726" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="1092478e-403e-4109-a8bf-f6f6b775a2bc" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="ffcf0f0e-f088-442d-bbde-2e6556ebf0f4" name="sys_all_objects" context="sys_all_objects" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT t.name,
    t.object_id,
    t.principal_id,
    t.schema_id,
    t.parent_object_id,
    'U'::text AS type,
    'USER_TABLE'::text AS type_desc,
    t.create_date,
    t.modify_date,
    t.is_ms_shipped,
    t.is_published,
    t.is_schema_published
   FROM aws_sqlserver_ext.sys_tables t
UNION ALL
 SELECT v.name,
    v.object_id,
    v.principal_id,
    v.schema_id,
    v.parent_object_id,
    'V'::text AS type,
    'VIEW'::text AS type_desc,
    v.create_date,
    v.modify_date,
    v.is_ms_shipped,
    v.is_published,
    v.is_schema_published
   FROM aws_sqlserver_ext.sys_all_views v
UNION ALL
 SELECT f.name,
    f.object_id,
    f.principal_id,
    f.schema_id,
    f.parent_object_id,
    'F'::text AS type,
    'FOREIGN_KEY_CONSTRAINT'::text AS type_desc,
    f.create_date,
    f.modify_date,
    f.is_ms_shipped,
    f.is_published,
    f.is_schema_published
   FROM aws_sqlserver_ext.sys_foreign_keys f
UNION ALL
 SELECT p.name,
    p.object_id,
    p.principal_id,
    p.schema_id,
    p.parent_object_id,
    'PK'::text AS type,
    'PRIMARY_KEY_CONSTRAINT'::text AS type_desc,
    p.create_date,
    p.modify_date,
    p.is_ms_shipped,
    p.is_published,
    p.is_schema_published
   FROM aws_sqlserver_ext.sys_key_constraints p
UNION ALL
 SELECT pr.name,
    pr.object_id,
    pr.principal_id,
    pr.schema_id,
    pr.parent_object_id,
    pr.type,
    pr.type_desc,
    pr.create_date,
    pr.modify_date,
    pr.is_ms_shipped,
    pr.is_published,
    pr.is_schema_published
   FROM aws_sqlserver_ext.sys_procedures pr
UNION ALL
 SELECT p.relname AS name,
    p.oid AS object_id,
    NULL::integer AS principal_id,
    s.oid AS schema_id,
    0 AS parent_object_id,
    'SO'::character varying(2) AS type,
    'SEQUENCE_OBJECT'::character varying(60) AS type_desc,
    NULL::timestamp without time zone AS create_date,
    NULL::timestamp without time zone AS modify_date,
    0 AS is_ms_shipped,
    0 AS is_published,
    0 AS is_schema_published
   FROM (pg_class p
     JOIN pg_namespace s ON ((s.oid = p.relnamespace)))
  WHERE (p.relkind = 'S'::"char");]]></complex-attribute>
                        <category _I_D="7930636a-2aba-4126-8023-8b5961e36146" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="51f3cfe7-2dfd-4632-b90b-40788b3be468" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="a701c568-c412-4416-a4e9-081e1dfc3e6b" name="sys_all_views" context="sys_all_views" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT t.relname AS name,
    t.oid AS object_id,
    NULL::integer AS principal_id,
    s.oid AS schema_id,
    0 AS parent_object_id,
    'V'::character varying(2) AS type,
    'VIEW'::character varying(60) AS type_desc,
    NULL::timestamp without time zone AS create_date,
    NULL::timestamp without time zone AS modify_date,
    0 AS is_ms_shipped,
    0 AS is_published,
    0 AS is_schema_published,
    0 AS with_check_option,
    0 AS is_date_correlation_view,
    0 AS is_tracked_by_cdc
   FROM (pg_class t
     JOIN pg_namespace s ON ((s.oid = t.relnamespace)))
  WHERE ((t.relkind = 'v'::"char") AND has_table_privilege(((quote_ident((s.nspname)::text) || '.'::text) || quote_ident((t.relname)::text)), 'SELECT,INSERT,UPDATE,DELETE,TRUNCATE,TRIGGER'::text));]]></complex-attribute>
                        <category _I_D="1ee832f4-3d94-41c8-9017-04b117199f3c" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="16b5d2be-80a1-4c27-8d5f-2fa49e7ec8ba" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="e80ef83d-daa6-43e9-8ad4-79b3e0967155" name="sys_columns" context="sys_columns" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT c.oid AS object_id,
    a.attname AS name,
    a.attnum AS column_id,
    t.oid AS system_type_id,
    t.oid AS user_type_id,
    a.attlen AS max_length,
    NULL::integer AS "precision",
    NULL::integer AS scale,
    coll.collname AS collation_name,
        CASE
            WHEN a.attnotnull THEN 0
            ELSE 1
        END AS is_nullable,
    0 AS is_ansi_padded,
    0 AS is_rowguidcol,
    0 AS is_identity,
    0 AS is_computed,
    0 AS is_filestream,
    0 AS is_replicated,
    0 AS is_non_sql_subscribed,
    0 AS is_merge_published,
    0 AS is_dts_replicated,
    0 AS is_xml_document,
    0 AS xml_collection_id,
    COALESCE(d.oid, (0)::oid) AS default_object_id,
    COALESCE(( SELECT pg_constraint.oid
           FROM pg_constraint
          WHERE ((pg_constraint.conrelid = t.oid) AND (pg_constraint.contype = 'c'::"char") AND (a.attnum = ANY (pg_constraint.conkey)))
         LIMIT 1), (0)::oid) AS rule_object_id,
    0 AS is_sparse,
    0 AS is_column_set,
    0 AS generated_always_type,
    'NOT_APPLICABLE'::character varying(60) AS generated_always_type_desc,
    NULL::integer AS encryption_type,
    NULL::character varying(64) AS encryption_type_desc,
    NULL::character varying AS encryption_algorithm_name,
    NULL::integer AS column_encryption_key_id,
    NULL::character varying AS column_encryption_key_database_name,
    0 AS is_hidden,
    0 AS is_masked
   FROM (((((pg_attribute a
     JOIN pg_class c ON ((c.oid = a.attrelid)))
     JOIN pg_type t ON ((t.oid = a.atttypid)))
     JOIN pg_namespace s ON ((s.oid = c.relnamespace)))
     LEFT JOIN pg_attrdef d ON (((c.oid = d.adrelid) AND (a.attnum = d.adnum))))
     LEFT JOIN pg_collation coll ON ((coll.oid = t.typcollation)))
  WHERE ((NOT a.attisdropped) AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'm'::"char", 'f'::"char", 'p'::"char"])) AND (s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name])) AND has_column_privilege(((quote_ident((s.nspname)::text) || '.'::text) || quote_ident((c.relname)::text)), (a.attname)::text, 'SELECT,INSERT,UPDATE,REFERENCES'::text));]]></complex-attribute>
                        <category _I_D="1f2f31f2-8675-47b9-b5d5-6ce9835baef6" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="7754c35d-2eef-4d99-aff0-b4347a31b581" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="2f909c09-fb4f-48b9-b03d-16845ef5ecf1" name="sys_databases" context="sys_databases" subcategories-loading="none" object-loading="extended" is-updatable="YES" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT d.datname AS name,
    d.oid AS database_id,
    NULL::integer AS source_database_id,
    NULL::character varying(85) AS owner_sid,
    NULL::integer AS compatibility_level,
    d.datcollate AS collation_name,
    0 AS user_access,
    NULL::character varying(60) AS user_access_desc,
    0 AS is_read_only,
    0 AS is_auto_close_on,
    0 AS is_auto_shrink_on,
    0 AS state,
    'ONLINE'::character varying(60) AS state_desc,
    0 AS is_in_standby,
    0 AS is_cleanly_shutdown,
    0 AS is_supplemental_logging_enabled,
    0 AS snapshot_isolation_state,
    NULL::character varying(60) AS snapshot_isolation_state_desc,
    0 AS is_read_committed_snapshot_on,
    1 AS recovery_model,
    'FULL'::character varying(60) AS recovery_model_desc,
    0 AS page_verify_option,
    NULL::character varying(60) AS page_verify_option_desc,
    1 AS is_auto_create_stats_on,
    0 AS is_auto_update_stats_on,
    0 AS is_auto_update_stats_async_on,
    0 AS is_ansi_null_default_on,
    0 AS is_ansi_nulls_on,
    0 AS is_ansi_padding_on,
    0 AS is_ansi_warnings_on,
    0 AS is_arithabort_on,
    0 AS is_concat_null_yields_null_on,
    0 AS is_numeric_roundabort_on,
    0 AS is_quoted_identifier_on,
    0 AS is_recursive_triggers_on,
    0 AS is_cursor_close_on_commit_on,
    0 AS is_local_cursor_default,
    0 AS is_fulltext_enabled,
    0 AS is_trustworthy_on,
    0 AS is_db_chaining_on,
    0 AS is_parameterization_forced,
    0 AS is_master_key_encrypted_by_server,
    0 AS is_published,
    0 AS is_subscribed,
    0 AS is_merge_published,
    0 AS is_distributor,
    0 AS is_sync_with_backup,
    NULL::oid AS service_broker_guid,
    0 AS is_broker_enabled,
    0 AS log_reuse_wait,
    'NOTHING'::character varying(60) AS log_reuse_wait_desc,
    0 AS is_date_correlation_on,
    0 AS is_cdc_enabled,
    0 AS is_encrypted,
    0 AS is_honor_broker_priority_on,
    NULL::oid AS replica_id,
    NULL::oid AS group_database_id,
    NULL::oid AS default_language_lcid,
    NULL::character varying(128) AS default_language_name,
    NULL::oid AS default_fulltext_language_lcid,
    NULL::character varying(128) AS default_fulltext_language_name,
    NULL::integer AS is_nested_triggers_on,
    NULL::integer AS is_transform_noise_words_on,
    NULL::integer AS two_digit_year_cutoff,
    0 AS containment,
    'NONE'::character varying(60) AS containment_desc,
    0 AS target_recovery_time_in_seconds,
    0 AS is_federation_member,
    0 AS is_memory_optimized_elevate_to_snapshot_on,
    0 AS is_auto_create_stats_incremental_on,
    0 AS is_query_store_on,
    NULL::integer AS resource_pool_id
   FROM pg_database d;]]></complex-attribute>
                        <category _I_D="1d0e0661-3317-420c-90b5-ff7ae592c1f0" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="8e61bac4-3b6d-409b-9640-51af306d60e4" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="a7655ef5-99cd-4249-9604-f8f43743e420" name="sys_foreign_key_columns" context="sys_foreign_key_columns" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT DISTINCT c.oid AS constraint_object_id,
    c.confkey AS constraint_column_id,
    c.conrelid AS parent_object_id,
    a_con.attnum AS parent_column_id,
    c.confrelid AS referenced_object_id,
    a_conf.attnum AS referenced_column_id
   FROM ((pg_constraint c
     JOIN pg_attribute a_con ON (((a_con.attrelid = c.conrelid) AND (a_con.attnum = ANY (c.conkey)))))
     JOIN pg_attribute a_conf ON (((a_conf.attrelid = c.confrelid) AND (a_conf.attnum = ANY (c.confkey)))))
  WHERE (c.contype = 'f'::"char");]]></complex-attribute>
                        <category _I_D="22976bf2-07c9-48c7-bf0e-4dbc5adea0d5" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="0eb39948-1ea1-4531-8dc5-fd6a74ad99d7" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="707a4366-2db7-468b-87f0-0806e581be27" name="sys_foreign_keys" context="sys_foreign_keys" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT c.conname AS name,
    c.oid AS object_id,
    NULL::integer AS principal_id,
    s.oid AS schema_id,
    c.conrelid AS parent_object_id,
    'F'::character varying(2) AS type,
    'FOREIGN_KEY_CONSTRAINT'::character varying(60) AS type_desc,
    NULL::timestamp without time zone AS create_date,
    NULL::timestamp without time zone AS modify_date,
    0 AS is_ms_shipped,
    0 AS is_published,
    0 AS is_schema_published,
    c.confrelid AS referenced_object_id,
    c.confkey AS key_index_id,
    0 AS is_disabled,
    0 AS is_not_for_replication,
    0 AS is_not_trusted,
        CASE c.confdeltype
            WHEN 'a'::"char" THEN 0
            WHEN 'r'::"char" THEN 0
            WHEN 'c'::"char" THEN 1
            WHEN 'n'::"char" THEN 2
            WHEN 'd'::"char" THEN 3
            ELSE NULL::integer
        END AS delete_referential_action,
        CASE c.confdeltype
            WHEN 'a'::"char" THEN 'NO_ACTION'::text
            WHEN 'r'::"char" THEN 'NO_ACTION'::text
            WHEN 'c'::"char" THEN 'CASCADE'::text
            WHEN 'n'::"char" THEN 'SET_NULL'::text
            WHEN 'd'::"char" THEN 'SET_DEFAULT'::text
            ELSE NULL::text
        END AS delete_referential_action_desc,
        CASE c.confupdtype
            WHEN 'a'::"char" THEN 0
            WHEN 'r'::"char" THEN 0
            WHEN 'c'::"char" THEN 1
            WHEN 'n'::"char" THEN 2
            WHEN 'd'::"char" THEN 3
            ELSE NULL::integer
        END AS update_referential_action,
        CASE c.confupdtype
            WHEN 'a'::"char" THEN 'NO_ACTION'::text
            WHEN 'r'::"char" THEN 'NO_ACTION'::text
            WHEN 'c'::"char" THEN 'CASCADE'::text
            WHEN 'n'::"char" THEN 'SET_NULL'::text
            WHEN 'd'::"char" THEN 'SET_DEFAULT'::text
            ELSE NULL::text
        END AS update_referential_action_desc,
    1 AS is_system_named
   FROM (pg_constraint c
     JOIN pg_namespace s ON ((s.oid = c.connamespace)))
  WHERE ((c.contype = 'f'::"char") AND (s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name])));]]></complex-attribute>
                        <category _I_D="f583d126-e8ec-44b6-a341-3efce371ec90" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="29980c6f-0a40-40b8-8e02-d9babe9f04cc" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="14cd6b88-eec9-4cae-840f-4121d0c9308c" name="sys_identity_columns" context="sys_identity_columns" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT aws_sqlserver_ext.get_id_by_name(((c.oid)::text || (a.attname)::text)) AS object_id,
    a.attname AS name,
    a.attnum AS column_id,
    t.oid AS system_type_id,
    t.oid AS user_type_id,
    a.attlen AS max_length,
    NULL::integer AS "precision",
    NULL::integer AS scale,
    coll.collname AS collation_name,
        CASE
            WHEN a.attnotnull THEN 0
            ELSE 1
        END AS is_nullable,
    0 AS is_ansi_padded,
    0 AS is_rowguidcol,
    1 AS is_identity,
    0 AS is_computed,
    0 AS is_filestream,
    0 AS is_replicated,
    0 AS is_non_sql_subscribed,
    0 AS is_merge_published,
    0 AS is_dts_replicated,
    0 AS is_xml_document,
    0 AS xml_collection_id,
    COALESCE(d.oid, (0)::oid) AS default_object_id,
    COALESCE(( SELECT pg_constraint.oid
           FROM pg_constraint
          WHERE ((pg_constraint.conrelid = t.oid) AND (pg_constraint.contype = 'c'::"char") AND (a.attnum = ANY (pg_constraint.conkey)))
         LIMIT 1), (0)::oid) AS rule_object_id,
    0 AS is_sparse,
    0 AS is_column_set,
    0 AS generated_always_type,
    'NOT_APPLICABLE'::character varying(60) AS generated_always_type_desc,
    NULL::integer AS encryption_type,
    NULL::character varying(64) AS encryption_type_desc,
    NULL::character varying AS encryption_algorithm_name,
    NULL::integer AS column_encryption_key_id,
    NULL::character varying AS column_encryption_key_database_name,
    0 AS is_hidden,
    0 AS is_masked,
    NULL::bigint AS seed_value,
    NULL::bigint AS increment_value,
    aws_sqlserver_ext.get_sequence_value((pg_get_serial_sequence(((quote_ident((s.nspname)::text) || '.'::text) || quote_ident((c.relname)::text)), (a.attname)::text))::character varying) AS last_value
   FROM (((((pg_attribute a
     LEFT JOIN pg_attrdef d ON (((a.attrelid = d.adrelid) AND (a.attnum = d.adnum))))
     JOIN pg_class c ON ((c.oid = a.attrelid)))
     JOIN pg_namespace s ON ((s.oid = c.relnamespace)))
     LEFT JOIN pg_type t ON ((t.oid = a.atttypid)))
     LEFT JOIN pg_collation coll ON ((coll.oid = t.typcollation)))
  WHERE ((NOT a.attisdropped) AND (pg_get_serial_sequence(((quote_ident((s.nspname)::text) || '.'::text) || quote_ident((c.relname)::text)), (a.attname)::text) IS NOT NULL) AND (s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name])) AND has_sequence_privilege(pg_get_serial_sequence(((quote_ident((s.nspname)::text) || '.'::text) || quote_ident((c.relname)::text)), (a.attname)::text), 'USAGE,SELECT,UPDATE'::text));]]></complex-attribute>
                        <category _I_D="0475f88b-e8ac-4eea-9039-a471ba83364e" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="b19d1bed-803b-4391-aaa7-4e01c141e29f" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="c2891445-2fd8-4e36-8172-d64af0cf6d4e" name="sys_indexes" context="sys_indexes" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT i.indrelid AS object_id,
    c.relname AS name,
        CASE
            WHEN i.indisclustered THEN 1
            ELSE 2
        END AS type,
        CASE
            WHEN i.indisclustered THEN 'CLUSTERED'::character varying(60)
            ELSE 'NONCLUSTERED'::character varying(60)
        END AS type_desc,
        CASE
            WHEN i.indisunique THEN 1
            ELSE 0
        END AS is_unique,
    c.reltablespace AS data_space_id,
    0 AS ignore_dup_key,
        CASE
            WHEN i.indisprimary THEN 1
            ELSE 0
        END AS is_primary_key,
        CASE
            WHEN (constr.oid IS NULL) THEN 0
            ELSE 1
        END AS is_unique_constraint,
    0 AS fill_factor,
        CASE
            WHEN (i.indpred IS NULL) THEN 0
            ELSE 1
        END AS is_padded,
        CASE
            WHEN i.indisready THEN 0
            ELSE 1
        END AS is_disabled,
    0 AS is_hypothetical,
    1 AS allow_row_locks,
    1 AS allow_page_locks,
    0 AS has_filter,
    NULL::character varying AS filter_definition,
    0 AS auto_created
   FROM (((pg_class c
     JOIN pg_namespace s ON ((s.oid = c.relnamespace)))
     JOIN pg_index i ON ((i.indexrelid = c.oid)))
     LEFT JOIN pg_constraint constr ON ((constr.conindid = c.oid)))
  WHERE ((c.relkind = 'i'::"char") AND i.indislive AND (s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name])));]]></complex-attribute>
                        <category _I_D="26dade35-12c1-402f-a7cd-1bd5af37be8d" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="83a6472e-f98e-4440-a99c-1829b0f0c1ba" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="dc5d78b7-3035-4070-b4af-658bf9660ea1" name="sys_key_constraints" context="sys_key_constraints" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT c.conname AS name,
    c.oid AS object_id,
    NULL::integer AS principal_id,
    s.oid AS schema_id,
    c.conrelid AS parent_object_id,
        CASE c.contype
            WHEN 'p'::"char" THEN 'PK'::character varying(2)
            WHEN 'u'::"char" THEN 'UQ'::character varying(2)
            ELSE NULL::character varying
        END AS type,
        CASE c.contype
            WHEN 'p'::"char" THEN 'PRIMARY_KEY_CONSTRAINT'::character varying(60)
            WHEN 'u'::"char" THEN 'UNIQUE_CONSTRAINT'::character varying(60)
            ELSE NULL::character varying
        END AS type_desc,
    NULL::timestamp without time zone AS create_date,
    NULL::timestamp without time zone AS modify_date,
    c.conindid AS unique_index_id,
    0 AS is_ms_shipped,
    0 AS is_published,
    0 AS is_schema_published
   FROM (pg_constraint c
     JOIN pg_namespace s ON ((s.oid = c.connamespace)))
  WHERE (c.contype = 'p'::"char");]]></complex-attribute>
                        <category _I_D="0efc7f4a-42ed-4616-82c1-2165796d7062" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="1bd4959a-edf9-4262-97f1-b2cc233269ee" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="562452e2-cb8c-412f-bc66-e82be80ca695" name="sys_objects" context="sys_objects" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT t.name,
    t.object_id,
    t.principal_id,
    t.schema_id,
    t.parent_object_id,
    'U'::text AS type,
    'USER_TABLE'::text AS type_desc,
    t.create_date,
    t.modify_date,
    t.is_ms_shipped,
    t.is_published,
    t.is_schema_published
   FROM aws_sqlserver_ext.sys_tables t
UNION ALL
 SELECT v.name,
    v.object_id,
    v.principal_id,
    v.schema_id,
    v.parent_object_id,
    'V'::text AS type,
    'VIEW'::text AS type_desc,
    v.create_date,
    v.modify_date,
    v.is_ms_shipped,
    v.is_published,
    v.is_schema_published
   FROM aws_sqlserver_ext.sys_views v
UNION ALL
 SELECT f.name,
    f.object_id,
    f.principal_id,
    f.schema_id,
    f.parent_object_id,
    'F'::text AS type,
    'FOREIGN_KEY_CONSTRAINT'::text AS type_desc,
    f.create_date,
    f.modify_date,
    f.is_ms_shipped,
    f.is_published,
    f.is_schema_published
   FROM aws_sqlserver_ext.sys_foreign_keys f
UNION ALL
 SELECT p.name,
    p.object_id,
    p.principal_id,
    p.schema_id,
    p.parent_object_id,
    'PK'::text AS type,
    'PRIMARY_KEY_CONSTRAINT'::text AS type_desc,
    p.create_date,
    p.modify_date,
    p.is_ms_shipped,
    p.is_published,
    p.is_schema_published
   FROM aws_sqlserver_ext.sys_key_constraints p
UNION ALL
 SELECT pr.name,
    pr.object_id,
    pr.principal_id,
    pr.schema_id,
    pr.parent_object_id,
    pr.type,
    pr.type_desc,
    pr.create_date,
    pr.modify_date,
    pr.is_ms_shipped,
    pr.is_published,
    pr.is_schema_published
   FROM aws_sqlserver_ext.sys_procedures pr
UNION ALL
 SELECT p.relname AS name,
    p.oid AS object_id,
    NULL::integer AS principal_id,
    s.oid AS schema_id,
    0 AS parent_object_id,
    'SO'::character varying(2) AS type,
    'SEQUENCE_OBJECT'::character varying(60) AS type_desc,
    NULL::timestamp without time zone AS create_date,
    NULL::timestamp without time zone AS modify_date,
    0 AS is_ms_shipped,
    0 AS is_published,
    0 AS is_schema_published
   FROM (pg_class p
     JOIN pg_namespace s ON ((s.oid = p.relnamespace)))
  WHERE ((s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name])) AND (p.relkind = 'S'::"char"));]]></complex-attribute>
                        <category _I_D="1daf620c-1ae8-4eeb-b249-9614d31f2bdc" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="f4ff84f3-1489-448a-bacb-946b9167d055" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="bc3fcccc-90de-44e5-899c-47c287d21b2c" name="sys_procedures" context="sys_procedures" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT p.proname AS name,
    p.oid AS object_id,
    NULL::integer AS principal_id,
    s.oid AS schema_id,
    0 AS parent_object_id,
        CASE format_type(p.prorettype, NULL::integer)
            WHEN 'void'::text THEN 'P'::character varying(2)
            ELSE
            CASE format_type(p.prorettype, NULL::integer)
                WHEN 'trigger'::text THEN 'TR'::character varying(2)
                ELSE 'FN'::character varying(2)
            END
        END AS type,
        CASE format_type(p.prorettype, NULL::integer)
            WHEN 'void'::text THEN 'SQL_STORED_PROCEDURE'::character varying(60)
            ELSE
            CASE format_type(p.prorettype, NULL::integer)
                WHEN 'trigger'::text THEN 'SQL_TRIGGER'::character varying(60)
                ELSE 'SQL_SCALAR_FUNCTION'::character varying(60)
            END
        END AS type_desc,
    NULL::timestamp without time zone AS create_date,
    NULL::timestamp without time zone AS modify_date,
    0 AS is_ms_shipped,
    0 AS is_published,
    0 AS is_schema_published
   FROM (pg_proc p
     JOIN pg_namespace s ON ((s.oid = p.pronamespace)))
  WHERE ((s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name])) AND pg_function_is_visible(p.oid));]]></complex-attribute>
                        <category _I_D="9cd5d847-d6cd-4fb2-8a47-de5f213c2c5f" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="ddd1ba45-4ba3-496b-8418-08299a792116" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="2e130981-535d-4288-9ee1-2f34403728be" name="sys_schemas" context="sys_schemas" subcategories-loading="none" object-loading="extended" is-updatable="YES" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT pg_namespace.nspname AS name,
    pg_namespace.oid AS schema_id,
    pg_namespace.oid AS principal_id
   FROM pg_namespace
  WHERE (pg_namespace.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name]));]]></complex-attribute>
                        <category _I_D="3813bf8e-cd3b-466f-a3f4-b93678169646" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="6adfba26-b7be-4916-8719-e6f2e6b0d05f" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="d2eeab15-5e31-4847-a02b-24f30b2c059a" name="sys_sql_modules" context="sys_sql_modules" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT p.oid AS object_id,
    pg_get_functiondef(p.oid) AS definition,
    1 AS uses_ansi_nulls,
    1 AS uses_quoted_identifier,
    0 AS is_schema_bound,
    0 AS uses_database_collation,
    0 AS is_recompiled,
        CASE
            WHEN p.proisstrict THEN 1
            ELSE 0
        END AS null_on_null_input,
    NULL::integer AS execute_as_principal_id,
    0 AS uses_native_compilation
   FROM (((pg_proc p
     JOIN pg_namespace s ON ((s.oid = p.pronamespace)))
     JOIN pg_type t ON ((t.oid = p.prorettype)))
     LEFT JOIN pg_collation c ON ((c.oid = t.typcollation)))
  WHERE ((s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name])) AND pg_function_is_visible(p.oid));]]></complex-attribute>
                        <category _I_D="8191d24c-dc45-44c0-aa17-afa2627319ce" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="a31e38b7-59dc-4e86-9ae3-d1066e697280" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="5071ba48-2a91-4f61-9ae2-c1eb132da137" name="sys_sysforeignkeys" context="sys_sysforeignkeys" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT c.conname AS name,
    c.oid AS object_id,
    c.conrelid AS fkeyid,
    c.confrelid AS rkeyid,
    a_con.attnum AS fkey,
    a_conf.attnum AS rkey,
    a_conf.attnum AS keyno
   FROM (((pg_constraint c
     JOIN pg_namespace s ON ((s.oid = c.connamespace)))
     JOIN pg_attribute a_con ON (((a_con.attrelid = c.conrelid) AND (a_con.attnum = ANY (c.conkey)))))
     JOIN pg_attribute a_conf ON (((a_conf.attrelid = c.confrelid) AND (a_conf.attnum = ANY (c.confkey)))))
  WHERE ((c.contype = 'f'::"char") AND (s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name])));]]></complex-attribute>
                        <category _I_D="e245f0cb-3005-46ea-8bb1-3f4bd8441fd2" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="9c3afd68-7121-494b-b4ea-0afbf8d24a11" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="26454b6e-c859-4532-92dc-5bd674607bbc" name="sys_sysindexes" context="sys_sysindexes" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT i.object_id AS id,
    NULL::integer AS status,
    NULL::oid AS first,
    i.type AS indid,
    NULL::oid AS root,
    0 AS minlen,
    1 AS keycnt,
    0 AS groupid,
    0 AS dpages,
    0 AS reserved,
    0 AS used,
    0 AS rowcnt,
    0 AS rowmodctr,
    0 AS reserved3,
    0 AS reserved4,
    0 AS xmaxlen,
    NULL::integer AS maxirow,
    0 AS origfillfactor,
    0 AS statversion,
    0 AS reserved2,
    NULL::integer AS firstiam,
    0 AS impid,
    0 AS lockflags,
    0 AS pgmodctr,
    NULL::bytea AS keys,
    i.name,
    NULL::bytea AS statblob,
    800 AS maxlen,
    0 AS rows
   FROM aws_sqlserver_ext.sys_indexes i;]]></complex-attribute>
                        <category _I_D="8edaf3a2-f3e3-438a-824e-6a5ffee82b69" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="f5f32fef-be97-4c48-bb2a-ff88d067aa88" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="40628deb-b0ef-4592-a802-d1aae3e7fe8f" name="sys_sysobjects" context="sys_sysobjects" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT s.name,
    s.object_id AS id,
    s.type AS xtype,
    s.schema_id AS uid,
    0 AS info,
    0 AS status,
    0 AS base_schema_ver,
    0 AS replinfo,
    s.parent_object_id AS parent_obj,
    s.create_date AS crdate,
    0 AS ftcatid,
    0 AS schema_ver,
    0 AS stats_schema_ver,
    s.type,
    0 AS userstat,
    0 AS sysstat,
    0 AS indexdel,
    s.modify_date AS refdate,
    0 AS version,
    0 AS deltrig,
    0 AS instrig,
    0 AS updtrig,
    0 AS seltrig,
    0 AS category,
    0 AS cache
   FROM aws_sqlserver_ext.sys_objects s;]]></complex-attribute>
                        <category _I_D="f1f58789-c83f-4d98-b558-0cb6d05bfe67" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="956a8be9-4535-49a7-b9a5-1c9f057d9b4e" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="337da61e-77eb-440b-9deb-6f65cdbfa7c5" name="sys_sysprocesses" context="sys_sysprocesses" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT a.pid AS spid,
    NULL::integer AS kpid,
    COALESCE(blocking_activity.pid, 0) AS blocked,
    NULL::bytea AS waittype,
    0 AS waittime,
    a.wait_event_type AS lastwaittype,
    NULL::text AS waitresource,
    a.datid AS dbid,
    a.usesysid AS uid,
    0 AS cpu,
    0 AS physical_io,
    0 AS memusage,
    a.backend_start AS login_time,
    a.query_start AS last_batch,
    0 AS ecid,
    0 AS open_tran,
    a.state AS status,
    NULL::bytea AS sid,
    a.client_hostname AS hostname,
    a.application_name AS program_name,
    NULL::character varying(10) AS hostprocess,
    a.query AS cmd,
    NULL::character varying(128) AS nt_domain,
    NULL::character varying(128) AS nt_username,
    NULL::character varying(12) AS net_address,
    NULL::character varying(12) AS net_library,
    a.usename AS loginname,
    NULL::bytea AS context_info,
    NULL::bytea AS sql_handle,
    0 AS stmt_start,
    0 AS stmt_end,
    0 AS request_id
   FROM (((pg_stat_activity a
     LEFT JOIN pg_locks blocked_locks ON ((a.pid = blocked_locks.pid)))
     LEFT JOIN pg_locks blocking_locks ON (((blocking_locks.locktype = blocked_locks.locktype) AND (NOT (blocking_locks.database IS DISTINCT FROM blocked_locks.database)) AND (NOT (blocking_locks.relation IS DISTINCT FROM blocked_locks.relation)) AND (NOT (blocking_locks.page IS DISTINCT FROM blocked_locks.page)) AND (NOT (blocking_locks.tuple IS DISTINCT FROM blocked_locks.tuple)) AND (NOT (blocking_locks.virtualxid IS DISTINCT FROM blocked_locks.virtualxid)) AND (NOT (blocking_locks.transactionid IS DISTINCT FROM blocked_locks.transactionid)) AND (NOT (blocking_locks.classid IS DISTINCT FROM blocked_locks.classid)) AND (NOT (blocking_locks.objid IS DISTINCT FROM blocked_locks.objid)) AND (NOT (blocking_locks.objsubid IS DISTINCT FROM blocked_locks.objsubid)) AND (blocking_locks.pid <> blocked_locks.pid))))
     LEFT JOIN pg_stat_activity blocking_activity ON ((blocking_activity.pid = blocking_locks.pid)));]]></complex-attribute>
                        <category _I_D="7e6b5742-8694-4a45-afa7-240c5a31e4d9" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="5d46b4d5-ed8c-4dd6-b9ae-483a5edb5e3e" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="0ba3e3fc-1fcf-42d6-a2f2-9c1dbeca4922" name="sys_system_objects" context="sys_system_objects" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT o.name,
    o.object_id,
    o.principal_id,
    o.schema_id,
    o.parent_object_id,
    o.type,
    o.type_desc,
    o.create_date,
    o.modify_date,
    o.is_ms_shipped,
    o.is_published,
    o.is_schema_published,
    s.oid,
    s.nspname,
    s.nspowner,
    s.nspacl
   FROM (aws_sqlserver_ext.sys_all_objects o
     JOIN pg_namespace s ON ((s.oid = o.schema_id)))
  WHERE (s.nspname = ANY (ARRAY['information_schema'::name, 'pg_catalog'::name]));]]></complex-attribute>
                        <category _I_D="bc856346-7155-4cc8-8d50-532e598143a8" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="68705c30-6068-4db5-b089-6a002bf3d022" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="22241aee-74c5-4384-857f-1961ff108956" name="sys_tables" context="sys_tables" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT t.relname AS name,
    t.oid AS object_id,
    NULL::integer AS principal_id,
    s.oid AS schema_id,
    0 AS parent_object_id,
    'U'::character varying(2) AS type,
    'USER_TABLE'::character varying(60) AS type_desc,
    NULL::timestamp without time zone AS create_date,
    NULL::timestamp without time zone AS modify_date,
    0 AS is_ms_shipped,
    0 AS is_published,
    0 AS is_schema_published,
        CASE t.reltoastrelid
            WHEN 0 THEN 0
            ELSE 1
        END AS lob_data_space_id,
    NULL::integer AS filestream_data_space_id,
    t.relnatts AS max_column_id_used,
    0 AS lock_on_bulk_load,
    1 AS uses_ansi_nulls,
    0 AS is_replicated,
    0 AS has_replication_filter,
    0 AS is_merge_published,
    0 AS is_sync_tran_subscribed,
    0 AS has_unchecked_assembly_data,
    0 AS text_in_row_limit,
    0 AS large_value_types_out_of_row,
    0 AS is_tracked_by_cdc,
    0 AS lock_escalation,
    'TABLE'::character varying(60) AS lock_escalation_desc,
    0 AS is_filetable,
    0 AS durability,
    'SCHEMA_AND_DATA'::character varying(60) AS durability_desc,
    0 AS is_memory_optimized,
        CASE t.relpersistence
            WHEN 't'::"char" THEN 2
            ELSE 0
        END AS temporal_type,
        CASE t.relpersistence
            WHEN 't'::"char" THEN 'SYSTEM_VERSIONED_TEMPORAL_TABLE'::text
            ELSE 'NON_TEMPORAL_TABLE'::text
        END AS temporal_type_desc,
    NULL::integer AS history_table_id,
    0 AS is_remote_data_archive_enabled,
    0 AS is_external
   FROM (pg_class t
     JOIN pg_namespace s ON ((s.oid = t.relnamespace)))
  WHERE ((t.relpersistence = ANY (ARRAY['p'::"char", 'u'::"char", 't'::"char"])) AND (t.relkind = 'r'::"char") AND has_table_privilege(((quote_ident((s.nspname)::text) || '.'::text) || quote_ident((t.relname)::text)), 'SELECT,INSERT,UPDATE,DELETE,TRUNCATE,TRIGGER'::text) AND (s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name])));]]></complex-attribute>
                        <category _I_D="69aa0445-9f2c-487b-9a7d-6824aa341681" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="1add038d-5bb4-461c-9e55-0c70b7d466e3" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="e27472b6-c6bd-43cc-b6f0-d2e8941950f3" name="sys_types" context="sys_types" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT format_type(t.oid, NULL::integer) AS name,
    t.oid AS system_type_id,
    t.oid AS user_type_id,
    s.oid AS schema_id,
    NULL::integer AS principal_id,
    t.typlen AS max_length,
    0 AS "precision",
    0 AS scale,
    c.collname AS collation_name,
        CASE
            WHEN t.typnotnull THEN 0
            ELSE 1
        END AS is_nullable,
        CASE t.typcategory
            WHEN 'U'::"char" THEN 1
            ELSE 0
        END AS is_user_defined,
    0 AS is_assembly_type,
    0 AS default_object_id,
    0 AS rule_object_id,
    0 AS is_table_type
   FROM ((pg_type t
     JOIN pg_namespace s ON ((s.oid = t.typnamespace)))
     LEFT JOIN pg_collation c ON ((c.oid = t.typcollation)));]]></complex-attribute>
                        <category _I_D="218dfca6-d074-4186-bc0c-20e501307097" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="de37435e-acc9-4f86-87a2-48f7d3f66b1a" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="f9f18492-f340-451c-bf58-9b4aeaa9a22f" name="sys_views" context="sys_views" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT t.relname AS name,
    t.oid AS object_id,
    NULL::integer AS principal_id,
    s.oid AS schema_id,
    0 AS parent_object_id,
    'V'::character varying(2) AS type,
    'VIEW'::character varying(60) AS type_desc,
    NULL::timestamp without time zone AS create_date,
    NULL::timestamp without time zone AS modify_date,
    0 AS is_ms_shipped,
    0 AS is_published,
    0 AS is_schema_published,
    0 AS with_check_option,
    0 AS is_date_correlation_view,
    0 AS is_tracked_by_cdc
   FROM (pg_class t
     JOIN pg_namespace s ON ((s.oid = t.relnamespace)))
  WHERE ((t.relkind = 'v'::"char") AND has_table_privilege(((quote_ident((s.nspname)::text) || '.'::text) || quote_ident((t.relname)::text)), 'SELECT,INSERT,UPDATE,DELETE,TRUNCATE,TRIGGER'::text) AND (s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name])));]]></complex-attribute>
                        <category _I_D="9000180b-9d2b-48b0-a182-f5ac5a31510e" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="72593f95-d4f4-477d-93d0-c65390e4d9ed" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="ecb27875-84d6-43bf-a03c-53ef52963d1b" name="sysmail_allitems" context="sysmail_allitems" subcategories-loading="none" object-loading="extended" is-updatable="YES" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT sa.mailitem_id,
    sa.profile_id,
    sa.recipients,
    sa.copy_recipients,
    sa.blind_copy_recipients,
    sa.subject,
    sa.body,
    sa.body_format,
    sa.importance,
    sa.sensitivity,
    sa.file_attachments,
    sa.attachment_encoding,
    sa.query,
    sa.execute_query_database,
    sa.attach_query_result_as_file,
    sa.query_result_header,
    sa.query_result_width,
    sa.query_result_separator,
    sa.exclude_query_output,
    sa.append_query_error,
    sa.sent_account_id,
        CASE sa.sent_status
            WHEN 0 THEN 'unsent'::text
            WHEN 1 THEN 'sent'::text
            WHEN 3 THEN 'retrying'::text
            ELSE 'failed'::text
        END AS sent_status,
    sa.sent_date
   FROM aws_sqlserver_ext.sysmail_mailitems sa;]]></complex-attribute>
                        <category _I_D="2c76ffd1-2afc-4ec3-8aba-c33f025ee4a1" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="bc35f796-90bb-4e37-b7c9-978806ef6f00" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="6aff0f5f-e747-4349-9626-6211521031e4" name="sysmail_faileditems" context="sysmail_faileditems" subcategories-loading="none" object-loading="extended" is-updatable="YES" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT sa.mailitem_id,
    sa.profile_id,
    sa.recipients,
    sa.copy_recipients,
    sa.blind_copy_recipients,
    sa.subject,
    sa.body,
    sa.body_format,
    sa.importance,
    sa.sensitivity,
    sa.file_attachments,
    sa.attachment_encoding,
    sa.query,
    sa.execute_query_database,
    sa.attach_query_result_as_file,
    sa.query_result_header,
    sa.query_result_width,
    sa.query_result_separator,
    sa.exclude_query_output,
    sa.append_query_error,
    sa.sent_account_id,
    sa.sent_status,
    sa.sent_date
   FROM aws_sqlserver_ext.sysmail_allitems sa
  WHERE (lower(sa.sent_status) = lower('failed'::text));]]></complex-attribute>
                        <category _I_D="777d0c4e-9d9d-47b3-9696-e19bb91fe493" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="2eef9d00-b7da-4aaf-80af-fa14ec8e5664" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="55f1e20e-ebdf-4065-b1cf-156425e05092" name="sysmail_mailattachments" context="sysmail_mailattachments" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT sa.attachment_id,
    sa.mailitem_id,
    sa.filename,
    sa.filesize,
    sa.attachment
   FROM (aws_sqlserver_ext.sysmail_attachments sa
     JOIN aws_sqlserver_ext.sysmail_mailitems sm ON ((sa.mailitem_id = sm.mailitem_id)));]]></complex-attribute>
                        <category _I_D="6ebf556e-23e9-43c4-bb22-b8a2c7fb49be" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="fdd2e2cb-0219-4608-9ecc-a69a18a6d2cd" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="29b16ff4-62a4-432d-9d55-d0e05c32ce70" name="sysmail_sentitems" context="sysmail_sentitems" subcategories-loading="none" object-loading="extended" is-updatable="YES" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT sa.mailitem_id,
    sa.profile_id,
    sa.recipients,
    sa.copy_recipients,
    sa.blind_copy_recipients,
    sa.subject,
    sa.body,
    sa.body_format,
    sa.importance,
    sa.sensitivity,
    sa.file_attachments,
    sa.attachment_encoding,
    sa.query,
    sa.execute_query_database,
    sa.attach_query_result_as_file,
    sa.query_result_header,
    sa.query_result_width,
    sa.query_result_separator,
    sa.exclude_query_output,
    sa.append_query_error,
    sa.sent_account_id,
    sa.sent_status,
    sa.sent_date
   FROM aws_sqlserver_ext.sysmail_allitems sa
  WHERE (lower(sa.sent_status) = lower('sent'::text));]]></complex-attribute>
                        <category _I_D="fcd6e5e6-f67b-4134-b5b0-5546e35b4e38" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="572b9b36-4652-4230-a56c-63c13d37f307" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="1e219199-a434-4a0b-92fb-c664917203a4" name="sysmail_unsentitems" context="sysmail_unsentitems" subcategories-loading="none" object-loading="extended" is-updatable="YES" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT sa.mailitem_id,
    sa.profile_id,
    sa.recipients,
    sa.copy_recipients,
    sa.blind_copy_recipients,
    sa.subject,
    sa.body,
    sa.body_format,
    sa.importance,
    sa.sensitivity,
    sa.file_attachments,
    sa.attachment_encoding,
    sa.query,
    sa.execute_query_database,
    sa.attach_query_result_as_file,
    sa.query_result_header,
    sa.query_result_width,
    sa.query_result_separator,
    sa.exclude_query_output,
    sa.append_query_error,
    sa.sent_account_id,
    sa.sent_status,
    sa.sent_date
   FROM aws_sqlserver_ext.sysmail_allitems sa
  WHERE ((lower(sa.sent_status) = lower('unsent'::text)) OR (lower(sa.sent_status) = lower('retrying'::text)));]]></complex-attribute>
                        <category _I_D="88a3d7a2-9db7-4a7f-a0e3-5055c3e06009" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="0d08a8c4-eac1-4608-9667-ae891424f747" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                </category>
                <category _I_D="86beae8f-d627-470c-bc5c-164a56f70c34" name="Collations" order-num="3" objects-loading="empty" subcategories-loading="full" child-type="collation"/>
                <category _I_D="ee5ab757-9be1-4bf5-97ae-7c206ced380f" name="Operators" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="operator"/>
                <category _I_D="23a955c7-aaff-4e99-aca0-924a7cf26214" name="Rules" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="rule"/>
                <category _I_D="ba3e575d-0ad6-48c5-aca4-1ef48a32cb22" name="FTS Configurations" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="ftsconfiguration"/>
                <category _I_D="7b42ffcd-94db-43f4-8956-692bb90740ef" name="FTS Dictionaries" order-num="7" objects-loading="empty" subcategories-loading="full" child-type="ftsdictionary"/>
                <category _I_D="f1bd87b7-a92d-43ea-9038-b4647f472dda" name="Functions" order-num="8" objects-loading="extended" subcategories-loading="none" child-type="function">
                    <function _I_D="3ac20696-8c16-49c6-bfac-00ebbb07f3aa" name="char" function-id="16543" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="char" is-aggregate="f" language-name="plpgsql" context="char" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="bpchar" count-arguments="1" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="char(x integer)" arguments-datatypes="integer" function-arguments="x integer" function-identity-arguments="x integer">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
/***************************************************************
EXTENSION PACK function CHAR(x)
***************************************************************/
	if x between 1 and 255 then
		return chr(x);
	else
		return null; 
	end if;	
END;
]]></complex-attribute>
                        <category _I_D="0ea454c7-e3c7-469b-a04a-9cfb0e98dcf2" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b6761a8b-e42b-49a9-912f-5242879af249" name="checksum" function-id="16542" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="checksum" is-aggregate="f" language-name="sql" context="checksum" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" count-arguments="1" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="checksum(_input text)" arguments-datatypes="text" function-arguments="_input text" function-identity-arguments="_input text">
                        <complex-attribute name="sql"><![CDATA[
  SELECT ('x'||SUBSTR(MD5(_input),1,8))::BIT(32)::INTEGER;
]]></complex-attribute>
                        <category _I_D="f66662c7-ac7b-497c-baba-7693a1a757cf" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2662f796-e95e-4c27-b3c3-f0e64c4bbe66" name="conv_date_to_string" function-id="16567" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="conv_date_to_string" is-aggregate="f" language-name="plpgsql" context="conv_date_to_string" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="text" count-arguments="3" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="conv_date_to_string(p_datatype text, p_dateval date, p_style numeric)" arguments-datatypes="text,date,numeric" comment="This function converts the DATE value into a character string, according to specified style (conversion mask)." function-arguments="p_datatype text, p_dateval date, p_style numeric DEFAULT 20" function-identity-arguments="p_datatype text, p_dateval date, p_style numeric">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_day VARCHAR;
    v_dateval DATE;
    v_style SMALLINT;
    v_month SMALLINT;
    v_resmask VARCHAR;
    v_datatype VARCHAR;
    v_language VARCHAR;
    v_monthname VARCHAR;
    v_resstring VARCHAR;
    v_lengthexpr VARCHAR;
    v_maxlength SMALLINT;
    v_res_length SMALLINT;
    v_err_message VARCHAR;
    v_res_datatype VARCHAR;
    v_lang_metadata_json JSONB;
    VARCHAR_MAX CONSTANT SMALLINT := 8000;
    NVARCHAR_MAX CONSTANT SMALLINT := 4000;
    CONVERSION_LANG CONSTANT VARCHAR := '';
    CHARACTER_REGEXP CONSTANT VARCHAR := 'CHAR|NCHAR|CHARACTER|NATIONAL CHARACTER';
    VARCHAR_REGEXP CONSTANT VARCHAR := 'VARCHAR|NVARCHAR|CHARACTER VARYING|NATIONAL CHARACTER VARYING';
    DATATYPE_REGEXP CONSTANT VARCHAR := concat('^\s*(', CHARACTER_REGEXP, '|', VARCHAR_REGEXP, ')\s*$');
    DATATYPE_MASK_REGEXP CONSTANT VARCHAR := concat('^\s*(?:', CHARACTER_REGEXP, '|', VARCHAR_REGEXP, ')\s*\(\s*(\d+|MAX)\s*\)\s*$');
BEGIN
    v_datatype := regexp_replace(upper(trim(p_datatype)), '\s+', ' ', 'gi');
    v_style := floor(p_style)::SMALLINT;

    IF (scale(p_style) > 0) THEN
        RAISE most_specific_type_mismatch;
    ELSIF (NOT ((v_style BETWEEN 0 AND 13) OR
                (v_style BETWEEN 20 AND 25) OR
                (v_style BETWEEN 100 AND 113) OR
                v_style IN (120, 121, 126, 127, 130, 131)))
    THEN
        RAISE invalid_parameter_value;
    ELSIF (v_style IN (8, 24, 108)) THEN
        RAISE invalid_datetime_format;
    END IF;

    IF (v_datatype ~* DATATYPE_MASK_REGEXP) THEN
        v_res_datatype := rtrim(split_part(v_datatype, '(', 1));

        v_maxlength := CASE
                          WHEN substring(v_res_datatype, '^(NCHAR|NATIONAL.*)$') IS NULL
                          THEN VARCHAR_MAX
                          ELSE NVARCHAR_MAX
                       END;

        v_lengthexpr := substring(v_datatype, DATATYPE_MASK_REGEXP);

        IF (v_lengthexpr <> 'MAX' AND char_length(v_lengthexpr) > 4) THEN
            RAISE interval_field_overflow;
        END IF;

        v_res_length := CASE v_lengthexpr
                           WHEN 'MAX' THEN v_maxlength
                           ELSE v_lengthexpr::SMALLINT
                        END;
    ELSIF (v_datatype ~* DATATYPE_REGEXP) THEN
        v_res_datatype := v_datatype;
    ELSE
        RAISE datatype_mismatch;
    END IF;

    v_dateval := CASE
                    WHEN (v_style NOT IN (130, 131)) THEN p_dateval
                    ELSE aws_sqlserver_ext.conv_greg_to_hijri(p_dateval) + 1
                 END;

    v_day := ltrim(to_char(v_dateval, 'DD'), '0');
    v_month := to_char(v_dateval, 'MM')::SMALLINT;

    v_language := CASE
                     WHEN (v_style IN (130, 131)) THEN 'HIJRI'
                     ELSE CONVERSION_LANG
                  END;
    BEGIN
        v_lang_metadata_json := aws_sqlserver_ext.get_lang_metadata_json(v_language);
    EXCEPTION
        WHEN OTHERS THEN
        RAISE invalid_character_value_for_cast;
    END;

    v_monthname := (v_lang_metadata_json -> 'months_shortnames') ->> v_month - 1;

    v_resmask := CASE
                    WHEN (v_style IN (1, 22)) THEN 'MM/DD/YY'
                    WHEN (v_style = 101) THEN 'MM/DD/YYYY'
                    WHEN (v_style = 2) THEN 'YY.MM.DD'
                    WHEN (v_style = 102) THEN 'YYYY.MM.DD'
                    WHEN (v_style = 3) THEN 'DD/MM/YY'
                    WHEN (v_style = 103) THEN 'DD/MM/YYYY'
                    WHEN (v_style = 4) THEN 'DD.MM.YY'
                    WHEN (v_style = 104) THEN 'DD.MM.YYYY'
                    WHEN (v_style = 5) THEN 'DD-MM-YY'
                    WHEN (v_style = 105) THEN 'DD-MM-YYYY'
                    WHEN (v_style = 6) THEN 'DD $mnme$ YY'
                    WHEN (v_style IN (13, 106, 113)) THEN 'DD $mnme$ YYYY'
                    WHEN (v_style = 7) THEN '$mnme$ DD, YY'
                    WHEN (v_style = 107) THEN '$mnme$ DD, YYYY'
                    WHEN (v_style = 10) THEN 'MM-DD-YY'
                    WHEN (v_style = 110) THEN 'MM-DD-YYYY'
                    WHEN (v_style = 11) THEN 'YY/MM/DD'
                    WHEN (v_style = 111) THEN 'YYYY/MM/DD'
                    WHEN (v_style = 12) THEN 'YYMMDD'
                    WHEN (v_style = 112) THEN 'YYYYMMDD'
                    WHEN (v_style IN (20, 21, 23, 25, 120, 121, 126, 127)) THEN 'YYYY-MM-DD'
                    WHEN (v_style = 130) THEN 'DD $mnme$ YYYY'
                    WHEN (v_style = 131) THEN format('%s/MM/YYYY', lpad(v_day, 2, ' '))
                    WHEN (v_style IN (0, 9, 100, 109)) THEN format('$mnme$ %s YYYY', lpad(v_day, 2, ' '))
                 END;

    v_resstring := to_char(v_dateval, v_resmask);
    v_resstring := replace(v_resstring, '$mnme$', v_monthname);

    v_resstring := substring(v_resstring, 1, coalesce(v_res_length, char_length(v_resstring)));

    RETURN CASE
              WHEN substring(v_res_datatype, concat('^(', CHARACTER_REGEXP, ')$')) IS NOT NULL
              THEN rpad(v_resstring, coalesce(v_res_length, 30), ' ')
              ELSE v_resstring
           END;
EXCEPTION
    WHEN most_specific_type_mismatch THEN
        RAISE USING MESSAGE := 'Argument data type NUMERIC is invalid for argument 3 of convert function.',
                    DETAIL := 'Use of incorrect "style" parameter value during conversion process.',
                    HINT := 'Change "style" parameter to the proper value and try again.';

    WHEN invalid_parameter_value THEN
        RAISE USING MESSAGE := format('%s is not a valid style number when converting from DATE to a character string.', v_style),
                    DETAIL := 'Use of incorrect "style" parameter value during conversion process.',
                    HINT := 'Change "style" parameter to the proper value and try again.';

    WHEN invalid_datetime_format THEN
        RAISE USING MESSAGE := format('Error converting data type DATE to %s.', trim(p_datatype)),
                    DETAIL := 'Incorrect using of pair of input parameters values during conversion process.',
                    HINT := 'Check the input parameters values, correct them if needed, and try again.';

   WHEN interval_field_overflow THEN
       RAISE USING MESSAGE := format('The size (%s) given to the convert specification ''%s'' exceeds the maximum allowed for any data type (%s).',
                                     v_lengthexpr,
                                     lower(v_res_datatype),
                                     v_maxlength),
                   DETAIL := 'Use of incorrect size value of data type parameter during conversion process.',
                   HINT := 'Change size component of data type parameter to the allowable value and try again.';

    WHEN datatype_mismatch THEN
        RAISE USING MESSAGE := concat('Data type should be one of these values: ''CHAR(n|MAX)'', ''NCHAR(n|MAX)'', ''VARCHAR(n|MAX)'', ''NVARCHAR(n|MAX)'', ',
                                      '''CHARACTER VARYING(n|MAX)'', ''NATIONAL CHARACTER VARYING(n|MAX)''.'),
                    DETAIL := 'Use of incorrect "datatype" parameter value during conversion process.',
                    HINT := 'Change "datatype" parameter to the proper value and try again.';

    WHEN invalid_character_value_for_cast THEN
        RAISE USING MESSAGE := format('Invalid CONVERSION_LANG constant value - ''%s''. Allowed values are: ''English'', ''Deutsch'', etc.',
                                      CONVERSION_LANG),
                    DETAIL := 'Compiled incorrect CONVERSION_LANG constant value in function''s body.',
                    HINT := 'Correct CONVERSION_LANG constant value in function''s body, recompile it and try again.';

    WHEN invalid_text_representation THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
        v_err_message := substring(lower(v_err_message), 'integer\:\s\"(.*)\"');

        RAISE USING MESSAGE := format('Error while trying to convert "%s" value to SMALLINT (or INTEGER) data type.',
                                      v_err_message),
                    DETAIL := 'Supplied value contains illegal characters.',
                    HINT := 'Correct supplied value, remove all illegal characters.';
END;
]]></complex-attribute>
                        <category _I_D="fbb99211-f85b-40ec-b1b8-93c9f3fe9239" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="af97411a-9641-4cfb-92ea-8055ce9f2d6b" name="conv_datetime_to_string" function-id="16569" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="conv_datetime_to_string" is-aggregate="f" language-name="plpgsql" context="conv_datetime_to_string" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="text" count-arguments="4" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="conv_datetime_to_string(p_datatype text, p_src_datatype text, p_datetimeval timestamp without time zone, p_style numeric)" arguments-datatypes="text,text,timestamp without time zone,numeric" comment="This function converts the DATETIME value into a character string, according to specified style (conversion mask)." function-arguments="p_datatype text, p_src_datatype text, p_datetimeval timestamp without time zone, p_style numeric DEFAULT '-1'::integer" function-identity-arguments="p_datatype text, p_src_datatype text, p_datetimeval timestamp without time zone, p_style numeric">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_day VARCHAR;
    v_hour VARCHAR;
    v_month SMALLINT;
    v_style SMALLINT;
    v_scale SMALLINT;
    v_resmask VARCHAR;
    v_language VARCHAR;
    v_datatype VARCHAR;
    v_fseconds VARCHAR;
    v_fractsep VARCHAR;
    v_monthname VARCHAR;
    v_resstring VARCHAR;
    v_lengthexpr VARCHAR;
    v_maxlength SMALLINT;
    v_res_length SMALLINT;
    v_err_message VARCHAR;
    v_src_datatype VARCHAR;
    v_res_datatype VARCHAR;
    v_lang_metadata_json JSONB;
    VARCHAR_MAX CONSTANT SMALLINT := 8000;
    NVARCHAR_MAX CONSTANT SMALLINT := 4000;
    CONVERSION_LANG CONSTANT VARCHAR := '';
    CHARACTER_REGEXP CONSTANT VARCHAR := 'CHAR|NCHAR|CHARACTER|NATIONAL CHARACTER';
    VARCHAR_REGEXP CONSTANT VARCHAR := 'VARCHAR|NVARCHAR|CHARACTER VARYING|NATIONAL CHARACTER VARYING';
    DATATYPE_REGEXP CONSTANT VARCHAR := concat('^\s*(', CHARACTER_REGEXP, '|', VARCHAR_REGEXP, ')\s*$');
    DATATYPE_MASK_REGEXP CONSTANT VARCHAR := concat('^\s*(?:', CHARACTER_REGEXP, '|', VARCHAR_REGEXP, ')\s*\(\s*(\d+|MAX)\s*\)\s*$');
    SRCDATATYPE_MASK_REGEXP VARCHAR := '^(?:DATETIME|SMALLDATETIME|DATETIME2)\s*(?:\s*\(\s*(\d+)\s*\)\s*)?$';
    v_datetimeval TIMESTAMP(6) WITHOUT TIME ZONE;
BEGIN
    v_datatype := regexp_replace(upper(trim(p_datatype)), '\s+', ' ', 'gi');
    v_src_datatype := upper(trim(p_src_datatype));
    v_style := floor(p_style)::SMALLINT;

    IF (v_src_datatype ~* SRCDATATYPE_MASK_REGEXP)
    THEN
        v_scale := substring(v_src_datatype, SRCDATATYPE_MASK_REGEXP)::SMALLINT;

        v_src_datatype := rtrim(split_part(v_src_datatype, '(', 1));

        IF (v_src_datatype <> 'DATETIME2' AND v_scale IS NOT NULL) THEN
            RAISE invalid_indicator_parameter_value;
        ELSIF (v_scale NOT BETWEEN 0 AND 7) THEN
            RAISE invalid_regular_expression;
        END IF;

        v_scale := coalesce(v_scale, 7);
    ELSE
        RAISE most_specific_type_mismatch;
    END IF;

    IF (scale(p_style) > 0) THEN
        RAISE escape_character_conflict;
    ELSIF (NOT ((v_style BETWEEN 0 AND 14) OR
                (v_style BETWEEN 20 AND 25) OR
                (v_style BETWEEN 100 AND 114) OR
                v_style IN (-1, 120, 121, 126, 127, 130, 131)))
    THEN
        RAISE invalid_parameter_value;
    END IF;

    IF (v_datatype ~* DATATYPE_MASK_REGEXP) THEN
        v_res_datatype := rtrim(split_part(v_datatype, '(', 1));

        v_maxlength := CASE
                          WHEN substring(v_res_datatype, '^(NCHAR|NATIONAL.*)$') IS NULL
                          THEN VARCHAR_MAX
                          ELSE NVARCHAR_MAX
                       END;

        v_lengthexpr := substring(v_datatype, DATATYPE_MASK_REGEXP);

        IF (v_lengthexpr <> 'MAX' AND char_length(v_lengthexpr) > 4)
        THEN
            RAISE interval_field_overflow;
        END IF;

        v_res_length := CASE v_lengthexpr
                           WHEN 'MAX' THEN v_maxlength
                           ELSE v_lengthexpr::SMALLINT
                        END;
    ELSIF (v_datatype ~* DATATYPE_REGEXP) THEN
        v_res_datatype := v_datatype;
    ELSE
        RAISE datatype_mismatch;
    END IF;

    v_datetimeval := CASE
                        WHEN (v_style NOT IN (130, 131)) THEN p_datetimeval
                        ELSE aws_sqlserver_ext.conv_greg_to_hijri(p_datetimeval) + INTERVAL '1 day'
                     END;

    v_day := ltrim(to_char(v_datetimeval, 'DD'), '0');
    v_hour := ltrim(to_char(v_datetimeval, 'HH12'), '0');
    v_month := to_char(v_datetimeval, 'MM')::SMALLINT;

    v_language := CASE
                     WHEN (v_style IN (130, 131)) THEN 'HIJRI'
                     ELSE CONVERSION_LANG
                  END;
    BEGIN
        v_lang_metadata_json := aws_sqlserver_ext.get_lang_metadata_json(v_language);
    EXCEPTION
        WHEN OTHERS THEN
        RAISE invalid_character_value_for_cast;
    END;

    v_monthname := (v_lang_metadata_json -> 'months_shortnames') ->> v_month - 1;

    IF (v_src_datatype IN ('DATETIME', 'SMALLDATETIME')) THEN
        v_fseconds := aws_sqlserver_ext.round_fractseconds(to_char(v_datetimeval, 'MS'));

        IF (v_fseconds::INTEGER = 1000) THEN
            v_fseconds := '000';
            v_datetimeval := v_datetimeval + INTERVAL '1 second';
        ELSE
            v_fseconds := lpad(v_fseconds, 3, '0');
        END IF;
    ELSE
        v_fseconds := aws_sqlserver_ext.get_microsecs_from_fractsecs(to_char(v_datetimeval, 'US'), v_scale);

        IF (v_scale = 7) THEN
            v_fseconds := concat(v_fseconds, '0');
        END IF;
    END IF;

    v_fractsep := CASE v_src_datatype
                     WHEN 'DATETIME2' THEN '.'
                     ELSE ':'
                  END;

    IF ((v_style = -1 AND v_src_datatype <> 'DATETIME2') OR
        v_style IN (0, 9, 100, 109))
    THEN
        v_resmask := format('$mnme$ %s YYYY %s:MI%s',
                            lpad(v_day, 2, ' '),
                            lpad(v_hour, 2, ' '),
                            CASE
                               WHEN (v_style IN (-1, 0, 100)) THEN 'AM'
                               ELSE CASE
                                       WHEN char_length(v_fseconds) > 0
                                       THEN format(':SS:%sAM', v_fseconds)
                                       ELSE ':SSAM'
                                    END
                            END);
    ELSIF (v_style = 1) THEN
        v_resmask := 'MM/DD/YY';
    ELSIF (v_style = 101) THEN
        v_resmask := 'MM/DD/YYYY';
    ELSIF (v_style = 2) THEN
        v_resmask := 'YY.MM.DD';
    ELSIF (v_style = 102) THEN
        v_resmask := 'YYYY.MM.DD';
    ELSIF (v_style = 3) THEN
        v_resmask := 'DD/MM/YY';
    ELSIF (v_style = 103) THEN
        v_resmask := 'DD/MM/YYYY';
    ELSIF (v_style = 4) THEN
        v_resmask := 'DD.MM.YY';
    ELSIF (v_style = 104) THEN
        v_resmask := 'DD.MM.YYYY';
    ELSIF (v_style = 5) THEN
        v_resmask := 'DD-MM-YY';
    ELSIF (v_style = 105) THEN
        v_resmask := 'DD-MM-YYYY';
    ELSIF (v_style = 6) THEN
        v_resmask := 'DD $mnme$ YY';
    ELSIF (v_style = 106) THEN
        v_resmask := 'DD $mnme$ YYYY';
    ELSIF (v_style = 7) THEN
        v_resmask := '$mnme$ DD, YY';
    ELSIF (v_style = 107) THEN
        v_resmask := '$mnme$ DD, YYYY';
    ELSIF (v_style IN (8, 24, 108)) THEN
        v_resmask := 'HH24:MI:SS';
    ELSIF (v_style = 10) THEN
        v_resmask := 'MM-DD-YY';
    ELSIF (v_style = 110) THEN
        v_resmask := 'MM-DD-YYYY';
    ELSIF (v_style = 11) THEN
        v_resmask := 'YY/MM/DD';
    ELSIF (v_style = 111) THEN
        v_resmask := 'YYYY/MM/DD';
    ELSIF (v_style = 12) THEN
        v_resmask := 'YYMMDD';
    ELSIF (v_style = 112) THEN
        v_resmask := 'YYYYMMDD';
    ELSIF (v_style IN (13, 113)) THEN
        v_resmask := format('DD $mnme$ YYYY HH24:MI:SS%s%s', v_fractsep, v_fseconds);
    ELSIF (v_style IN (14, 114)) THEN
        v_resmask := format('HH24:MI:SS%s%s', v_fractsep, v_fseconds);
    ELSIF (v_style IN (20, 120)) THEN
        v_resmask := 'YYYY-MM-DD HH24:MI:SS';
    ELSIF ((v_style = -1 AND v_src_datatype = 'DATETIME2') OR
           v_style IN (21, 25, 121))
    THEN
        v_resmask := format('YYYY-MM-DD HH24:MI:SS%s',
                            CASE
                               WHEN char_length(v_fseconds) > 0 THEN '.' || v_fseconds
                            END);
    ELSIF (v_style = 22) THEN
        v_resmask := format('MM/DD/YY %s:MI:SS AM', lpad(v_hour, 2, ' '));
    ELSIF (v_style = 23) THEN
        v_resmask := 'YYYY-MM-DD';
    ELSIF (v_style IN (126, 127)) THEN
        v_resmask := CASE v_src_datatype
                        WHEN 'SMALLDATETIME' THEN 'YYYY-MM-DDT$rem$HH24:MI:SS'
                        ELSE format('YYYY-MM-DDT$rem$HH24:MI:SS%s',
                                    CASE
                                       WHEN char_length(v_fseconds) > 0 THEN '.' || v_fseconds
                                    END)
                     END;
    ELSIF (v_style IN (130, 131)) THEN
        v_resmask := concat(CASE p_style
                               WHEN 131 THEN format('%s/MM/YYYY ', lpad(v_day, 2, ' '))
                               ELSE format('%s $mnme$ YYYY ', lpad(v_day, 2, ' '))
                            END,
                            format('%s:MI:SS%sAM', lpad(v_hour, 2, ' '),
                                   CASE
                                      WHEN char_length(v_fseconds) > 0 THEN concat(v_fractsep, v_fseconds)
                                   END));
    END IF;

    v_resstring := to_char(v_datetimeval, v_resmask);
    v_resstring := replace(v_resstring, '$mnme$', v_monthname);
    v_resstring := replace(v_resstring, '$rem$', '');

    v_resstring := substring(v_resstring, 1, coalesce(v_res_length, char_length(v_resstring)));

    RETURN CASE
              WHEN substring(v_res_datatype, concat('^(', CHARACTER_REGEXP, ')$')) IS NOT NULL
              THEN rpad(v_resstring, coalesce(v_res_length, 30), ' ')
              ELSE v_resstring
           END;
EXCEPTION
    WHEN most_specific_type_mismatch THEN
        RAISE USING MESSAGE := 'Source data type should be one of these values: ''DATETIME'', ''SMALLDATETIME'', ''DATETIME2'' or ''DATETIME2(n)''.',
                    DETAIL := 'Use of incorrect "src_datatype" parameter value during conversion process.',
                    HINT := 'Change "srcdatatype" parameter to the proper value and try again.';

   WHEN invalid_regular_expression THEN
       RAISE USING MESSAGE := format('The source data type scale (%s) given to the convert specification exceeds the maximum allowable value (7).',
                                     v_scale),
                   DETAIL := 'Use of incorrect scale value of source data type parameter during conversion process.',
                   HINT := 'Change scale component of source data type parameter to the allowable value and try again.';

    WHEN invalid_indicator_parameter_value THEN
        RAISE USING MESSAGE := format('Invalid attributes specified for data type %s.', v_src_datatype),
                    DETAIL := 'Use of incorrect scale value, which is not corresponding to specified data type.',
                    HINT := 'Change data type scale component or select different data type and try again.';

    WHEN escape_character_conflict THEN
        RAISE USING MESSAGE := 'Argument data type NUMERIC is invalid for argument 4 of convert function.',
                    DETAIL := 'Use of incorrect "style" parameter value during conversion process.',
                    HINT := 'Change "style" parameter to the proper value and try again.';

    WHEN invalid_parameter_value THEN
        RAISE USING MESSAGE := format('%s is not a valid style number when converting from %s to a character string.',
                                      v_style, v_src_datatype),
                    DETAIL := 'Use of incorrect "style" parameter value during conversion process.',
                    HINT := 'Change "style" parameter to the proper value and try again.';

    WHEN interval_field_overflow THEN
        RAISE USING MESSAGE := format('The size (%s) given to the convert specification ''%s'' exceeds the maximum allowed for any data type (%s).',
                                      v_lengthexpr, lower(v_res_datatype), v_maxlength),
                    DETAIL := 'Use of incorrect size value of data type parameter during conversion process.',
                    HINT := 'Change size component of data type parameter to the allowable value and try again.';

    WHEN datatype_mismatch THEN
        RAISE USING MESSAGE := concat('Data type should be one of these values: ''CHAR(n|MAX)'', ''NCHAR(n|MAX)'', ''VARCHAR(n|MAX)'', ''NVARCHAR(n|MAX)'', ',
                                      '''CHARACTER VARYING(n|MAX)'', ''NATIONAL CHARACTER VARYING(n|MAX)''.'),
                    DETAIL := 'Use of incorrect "datatype" parameter value during conversion process.',
                    HINT := 'Change "datatype" parameter to the proper value and try again.';

    WHEN invalid_character_value_for_cast THEN
        RAISE USING MESSAGE := format('Invalid CONVERSION_LANG constant value - ''%s''. Allowed values are: ''English'', ''Deutsch'', etc.',
                                      CONVERSION_LANG),
                    DETAIL := 'Compiled incorrect CONVERSION_LANG constant value in function''s body.',
                    HINT := 'Correct CONVERSION_LANG constant value in function''s body, recompile it and try again.';

    WHEN invalid_text_representation THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
        v_err_message := substring(lower(v_err_message), 'integer\:[[:space:]]\"(.*)\"');

        RAISE USING MESSAGE := format('Error while trying to convert "%s" value to SMALLINT data type.',
                                      v_err_message),
                    DETAIL := 'Supplied value contains illegal characters.',
                    HINT := 'Correct supplied value, remove all illegal characters.';
END;
]]></complex-attribute>
                        <category _I_D="2fb232f0-9c73-4e03-bda5-084672461a90" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a4ffab96-8177-40c7-aabc-f7a47663fad4" name="conv_greg_to_hijri" function-id="16551" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="conv_greg_to_hijri(p_datetimeval timestamp without time zone)" is-aggregate="f" language-name="plpgsql" context="conv_greg_to_hijri(p_datetimeval timestamp without time zone)" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="timestamp" count-arguments="1" volatility="VOLATILE" is-window="f" overload-function-count="4" proc-language="plpgsql" function-signature="conv_greg_to_hijri(p_datetimeval timestamp without time zone)" arguments-datatypes="timestamp without time zone" comment="This function converts date and time from Gregorian calendar to the appropriate date and time in Hijri calendar." unique-suffix="(p_datetimeval timestamp without time zone)" routine-number="16551" function-arguments="p_datetimeval timestamp without time zone" function-identity-arguments="p_datetimeval timestamp without time zone">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_hijri_date DATE;
BEGIN
    v_hijri_date := aws_sqlserver_ext.conv_greg_to_hijri(extract(day from p_datetimeval)::SMALLINT,
                                                         extract(month from p_datetimeval)::SMALLINT,
                                                         extract(year from p_datetimeval)::INTEGER);

    RETURN to_timestamp(format('%s %s', to_char(v_hijri_date, 'DD.MM.YYYY'),
                                        to_char(p_datetimeval, ' HH24:MI:SS.US')),
                        'DD.MM.YYYY HH24:MI:SS.US');
END;
]]></complex-attribute>
                        <category _I_D="a251d732-a024-4f4a-9fcb-bc161603ffe5" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ab422494-31ba-48c6-bff6-478208be8748" name="conv_greg_to_hijri" function-id="16548" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="conv_greg_to_hijri(p_dateval date)" is-aggregate="f" language-name="plpgsql" context="conv_greg_to_hijri(p_dateval date)" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="date" count-arguments="1" volatility="VOLATILE" is-window="f" overload-function-count="4" proc-language="plpgsql" function-signature="conv_greg_to_hijri(p_dateval date)" arguments-datatypes="date" comment="This function converts date from Gregorian calendar to the appropriate date in Hijri calendar." unique-suffix="(p_dateval date)" routine-number="16548" function-arguments="p_dateval date" function-identity-arguments="p_dateval date">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    RETURN aws_sqlserver_ext.conv_greg_to_hijri(extract(day from p_dateval)::NUMERIC,
                                                extract(month from p_dateval)::NUMERIC,
                                                extract(year from p_dateval)::NUMERIC);
END;
]]></complex-attribute>
                        <category _I_D="ad892d64-702d-4af5-b4ff-41feedfd8314" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="bb110d47-9644-40a0-b159-adb7f8e60a86" name="conv_greg_to_hijri" function-id="16549" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="conv_greg_to_hijri(p_day numeric, p_month numeric, p_year numeric)" is-aggregate="f" language-name="plpgsql" context="conv_greg_to_hijri(p_day numeric, p_month numeric, p_year numeric)" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="date" count-arguments="3" volatility="VOLATILE" is-window="f" overload-function-count="4" proc-language="plpgsql" function-signature="conv_greg_to_hijri(p_day numeric, p_month numeric, p_year numeric)" arguments-datatypes="numeric,numeric,numeric" comment="This function converts date from Gregorian calendar to the appropriate date in Hijri calendar." unique-suffix="(p_day numeric, p_month numeric, p_year numeric)" routine-number="16549" function-arguments="p_day numeric, p_month numeric, p_year numeric" function-identity-arguments="p_day numeric, p_month numeric, p_year numeric">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_day SMALLINT;
    v_month SMALLINT;
    v_year INTEGER;
    v_jdnum DOUBLE PRECISION;
    v_lnum DOUBLE PRECISION;
    v_inum DOUBLE PRECISION;
    v_nnum DOUBLE PRECISION;
    v_jnum DOUBLE PRECISION;
BEGIN
    v_day := floor(p_day)::SMALLINT;
    v_month := floor(p_month)::SMALLINT;
    v_year := floor(p_year)::INTEGER;

    IF ((sign(v_day) = -1) OR (sign(v_month) = -1) OR (sign(v_year) = -1))
    THEN
        RAISE invalid_character_value_for_cast;
    ELSIF (v_year = 0) THEN
        RAISE null_value_not_allowed;
    END IF;

    IF ((p_year > 1582) OR ((p_year = 1582) AND (p_month > 10)) OR ((p_year = 1582) AND (p_month = 10) AND (p_day > 14)))
    THEN
        v_jdnum := aws_sqlserver_ext.get_int_part((1461 * (p_year + 4800 + aws_sqlserver_ext.get_int_part((p_month - 14) / 12))) / 4) +
                   aws_sqlserver_ext.get_int_part((367 * (p_month - 2 - 12 * (aws_sqlserver_ext.get_int_part((p_month - 14) / 12)))) / 12) -
                   aws_sqlserver_ext.get_int_part((3 * (aws_sqlserver_ext.get_int_part((p_year + 4900 +
                   aws_sqlserver_ext.get_int_part((p_month - 14) / 12)) / 100))) / 4) + p_day - 32075;
    ELSE
        v_jdnum := 367 * p_year - aws_sqlserver_ext.get_int_part((7 * (p_year + 5001 +
                   aws_sqlserver_ext.get_int_part((p_month - 9) / 7))) / 4) +
                   aws_sqlserver_ext.get_int_part((275 * p_month) / 9) + p_day + 1729777;
    END IF;

    v_lnum := v_jdnum - 1948440 + 10632;
    v_nnum := aws_sqlserver_ext.get_int_part((v_lnum - 1) / 10631);
    v_lnum := v_lnum - 10631 * v_nnum + 354;
    v_jnum := (aws_sqlserver_ext.get_int_part((10985 - v_lnum) / 5316)) * (aws_sqlserver_ext.get_int_part((50 * v_lnum) / 17719)) +
              (aws_sqlserver_ext.get_int_part(v_lnum / 5670)) * (aws_sqlserver_ext.get_int_part((43 * v_lnum) / 15238));
    v_lnum := v_lnum - (aws_sqlserver_ext.get_int_part((30 - v_jnum) / 15)) * (aws_sqlserver_ext.get_int_part((17719 * v_jnum) / 50)) -
              (aws_sqlserver_ext.get_int_part(v_jnum / 16)) * (aws_sqlserver_ext.get_int_part((15238 * v_jnum) / 43)) + 29;

    v_month := aws_sqlserver_ext.get_int_part((24 * v_lnum) / 709);
    v_day := v_lnum - aws_sqlserver_ext.get_int_part((709 * v_month) / 24);
    v_year := 30 * v_nnum + v_jnum - 30;

    RETURN to_date(concat_ws('.', v_day, v_month, v_year), 'DD.MM.YYYY');
EXCEPTION
    WHEN invalid_character_value_for_cast THEN
        RAISE USING MESSAGE := 'Could not convert Gregorian to Hijri date if any part of the date is negative.',
                    DETAIL := 'Some of the supplied date parts (day, month, year) is negative.',
                    HINT := 'Change the value of the date part (day, month, year) wich was found to be negative.';

    WHEN null_value_not_allowed THEN
        RAISE USING MESSAGE := 'Could not convert Gregorian to Hijri date if year value is equal to zero.',
                    DETAIL := 'Supplied year value is equal to zero.',
                    HINT := 'Change the value of the year so that it is greater than zero.';
END;
]]></complex-attribute>
                        <category _I_D="92c17d3c-9069-448c-8e45-f9e18771fa3b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="68a24126-f35e-4e02-b621-99d4bcf3e6d4" name="conv_greg_to_hijri" function-id="16550" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="conv_greg_to_hijri(p_day text, p_month text, p_year text)" is-aggregate="f" language-name="plpgsql" context="conv_greg_to_hijri(p_day text, p_month text, p_year text)" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="date" count-arguments="3" volatility="VOLATILE" is-window="f" overload-function-count="4" proc-language="plpgsql" function-signature="conv_greg_to_hijri(p_day text, p_month text, p_year text)" arguments-datatypes="text,text,text" comment="This function converts date from Gregorian calendar to the appropriate date in Hijri calendar." unique-suffix="(p_day text, p_month text, p_year text)" routine-number="16550" function-arguments="p_day text, p_month text, p_year text" function-identity-arguments="p_day text, p_month text, p_year text">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    RETURN aws_sqlserver_ext.conv_greg_to_hijri(p_day::NUMERIC,
                                                p_month::NUMERIC,
                                                p_year::NUMERIC);
END;
]]></complex-attribute>
                        <category _I_D="acc61814-8029-4f88-8b3e-3802c3a76f93" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="cf07d439-9665-448c-bdf9-d924244c5906" name="conv_hijri_to_greg" function-id="16555" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="conv_hijri_to_greg(p_datetimeval timestamp without time zone)" is-aggregate="f" language-name="plpgsql" context="conv_hijri_to_greg(p_datetimeval timestamp without time zone)" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="timestamp" count-arguments="1" volatility="VOLATILE" is-window="f" overload-function-count="4" proc-language="plpgsql" function-signature="conv_hijri_to_greg(p_datetimeval timestamp without time zone)" arguments-datatypes="timestamp without time zone" comment="This function converts date from Hijri calendar to the appropriate date in Gregorian calendar." unique-suffix="(p_datetimeval timestamp without time zone)" routine-number="16555" function-arguments="p_datetimeval timestamp without time zone" function-identity-arguments="p_datetimeval timestamp without time zone">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_hijri_date DATE;
BEGIN
    v_hijri_date := aws_sqlserver_ext.conv_hijri_to_greg(extract(day from p_datetimeval)::NUMERIC,
                                                         extract(month from p_datetimeval)::NUMERIC,
                                                         extract(year from p_datetimeval)::NUMERIC);

    RETURN to_timestamp(format('%s %s', to_char(v_hijri_date, 'DD.MM.YYYY'),
                                        to_char(p_datetimeval, ' HH24:MI:SS.US')),
                        'DD.MM.YYYY HH24:MI:SS.US');
END;
]]></complex-attribute>
                        <category _I_D="40dd8931-f26c-4421-bdb5-3bb46568a8ec" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="1cfba986-c615-424d-b8a9-17960aa22098" name="conv_hijri_to_greg" function-id="16552" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="conv_hijri_to_greg(p_dateval date)" is-aggregate="f" language-name="plpgsql" context="conv_hijri_to_greg(p_dateval date)" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="date" count-arguments="1" volatility="VOLATILE" is-window="f" overload-function-count="4" proc-language="plpgsql" function-signature="conv_hijri_to_greg(p_dateval date)" arguments-datatypes="date" comment="This function converts date from Hijri calendar to the appropriate date in Gregorian calendar." unique-suffix="(p_dateval date)" routine-number="16552" function-arguments="p_dateval date" function-identity-arguments="p_dateval date">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    RETURN aws_sqlserver_ext.conv_hijri_to_greg(extract(day from p_dateval)::NUMERIC,
                                                extract(month from p_dateval)::NUMERIC,
                                                extract(year from p_dateval)::NUMERIC);
END;
]]></complex-attribute>
                        <category _I_D="79357e74-62bb-4656-9bbe-441369d1e911" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e6c60bb0-16b9-41d4-9f90-b12823354990" name="conv_hijri_to_greg" function-id="16553" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="conv_hijri_to_greg(p_day numeric, p_month numeric, p_year numeric)" is-aggregate="f" language-name="plpgsql" context="conv_hijri_to_greg(p_day numeric, p_month numeric, p_year numeric)" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="date" count-arguments="3" volatility="VOLATILE" is-window="f" overload-function-count="4" proc-language="plpgsql" function-signature="conv_hijri_to_greg(p_day numeric, p_month numeric, p_year numeric)" arguments-datatypes="numeric,numeric,numeric" comment="This function converts date from Hijri calendar to the appropriate date in Gregorian calendar." unique-suffix="(p_day numeric, p_month numeric, p_year numeric)" routine-number="16553" function-arguments="p_day numeric, p_month numeric, p_year numeric" function-identity-arguments="p_day numeric, p_month numeric, p_year numeric">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_day SMALLINT;
    v_month SMALLINT;
    v_year INTEGER;
    v_err_message VARCHAR;
    v_jdnum DOUBLE PRECISION;
    v_lnum DOUBLE PRECISION;
    v_inum DOUBLE PRECISION;
    v_nnum DOUBLE PRECISION;
    v_jnum DOUBLE PRECISION;
    v_knum DOUBLE PRECISION;
BEGIN
    v_day := floor(p_day)::SMALLINT;
    v_month := floor(p_month)::SMALLINT;
    v_year := floor(p_year)::INTEGER;

    IF ((sign(v_day) = -1) OR (sign(v_month) = -1) OR (sign(v_year) = -1))
    THEN
        RAISE invalid_character_value_for_cast;
    ELSIF (v_year = 0) THEN
        RAISE null_value_not_allowed;
    END IF;

    v_jdnum = aws_sqlserver_ext.get_int_part((11 * v_year + 3) / 30) + 354 * v_year + 30 * v_month -
              aws_sqlserver_ext.get_int_part((v_month - 1) / 2) + v_day + 1948440 - 385;

    IF (v_jdnum > 2299160)
    THEN
        v_lnum := v_jdnum + 68569;
        v_nnum := aws_sqlserver_ext.get_int_part((4 * v_lnum) / 146097);
        v_lnum := v_lnum - aws_sqlserver_ext.get_int_part((146097 * v_nnum + 3) / 4);
        v_inum := aws_sqlserver_ext.get_int_part((4000 * (v_lnum + 1)) / 1461001);
        v_lnum := v_lnum - aws_sqlserver_ext.get_int_part((1461 * v_inum) / 4) + 31;
        v_jnum := aws_sqlserver_ext.get_int_part((80 * v_lnum) / 2447);
        v_day := v_lnum - aws_sqlserver_ext.get_int_part((2447 * v_jnum) / 80);
        v_lnum := aws_sqlserver_ext.get_int_part(v_jnum / 11);
        v_month := v_jnum + 2 - 12 * v_lnum;
        v_year := 100 * (v_nnum - 49) + v_inum + v_lnum;
    ELSE
        v_jnum := v_jdnum + 1402;
        v_knum := aws_sqlserver_ext.get_int_part((v_jnum - 1) / 1461);
        v_lnum := v_jnum - 1461 * v_knum;
        v_nnum := aws_sqlserver_ext.get_int_part((v_lnum - 1) / 365) - aws_sqlserver_ext.get_int_part(v_lnum / 1461);
        v_inum := v_lnum - 365 * v_nnum + 30;
        v_jnum := aws_sqlserver_ext.get_int_part((80 * v_inum) / 2447);
        v_day := v_inum - aws_sqlserver_ext.get_int_part((2447 * v_jnum) / 80);
        v_inum := aws_sqlserver_ext.get_int_part(v_jnum / 11);
        v_month := v_jnum + 2 - 12 * v_inum;
        v_year := 4 * v_knum + v_nnum + v_inum - 4716;
    END IF;

    RETURN to_date(concat_ws('.', v_day, v_month, v_year), 'DD.MM.YYYY');
EXCEPTION
    WHEN invalid_character_value_for_cast THEN
        RAISE USING MESSAGE := 'Could not convert Hijri to Gregorian date if any part of the date is negative.',
                    DETAIL := 'Some of the supplied date parts (day, month, year) is negative.',
                    HINT := 'Change the value of the date part (day, month, year) wich was found to be negative.';

    WHEN null_value_not_allowed THEN
        RAISE USING MESSAGE := 'Could not convert Hijri to Gregorian date if year value is equal to zero.',
                    DETAIL := 'Supplied year value is equal to zero.',
                    HINT := 'Change the value of the year so that it is greater than zero.';

    WHEN invalid_text_representation THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
        v_err_message := substring(lower(v_err_message), 'integer\:\s\"(.*)\"');

        RAISE USING MESSAGE := format('Error while trying to convert "%s" value to SMALLINT data type.', v_err_message),
                    DETAIL := 'Supplied value contains illegal characters.',
                    HINT := 'Correct supplied value, remove all illegal characters.';
END;
]]></complex-attribute>
                        <category _I_D="b3b5a80f-a014-4f9d-9d62-3098e28295ee" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="039f8669-ed27-4c78-93a4-056e2989a771" name="conv_hijri_to_greg" function-id="16554" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="conv_hijri_to_greg(p_day text, p_month text, p_year text)" is-aggregate="f" language-name="plpgsql" context="conv_hijri_to_greg(p_day text, p_month text, p_year text)" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="date" count-arguments="3" volatility="VOLATILE" is-window="f" overload-function-count="4" proc-language="plpgsql" function-signature="conv_hijri_to_greg(p_day text, p_month text, p_year text)" arguments-datatypes="text,text,text" comment="This function converts date from Hijri calendar to the appropriate date in Gregorian calendar." unique-suffix="(p_day text, p_month text, p_year text)" routine-number="16554" function-arguments="p_day text, p_month text, p_year text" function-identity-arguments="p_day text, p_month text, p_year text">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    RETURN aws_sqlserver_ext.conv_hijri_to_greg(p_day::NUMERIC,
                                                p_month::NUMERIC,
                                                p_year::NUMERIC);
END;
]]></complex-attribute>
                        <category _I_D="8b7928a3-6acf-4678-907e-c9b8f5d38e7a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="1dd722c0-3916-4718-b8ae-25240997b41a" name="conv_string_to_date" function-id="16573" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="conv_string_to_date" is-aggregate="f" language-name="plpgsql" context="conv_string_to_date" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="date" count-arguments="2" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="conv_string_to_date(p_datestring text, p_style numeric)" arguments-datatypes="text,numeric" comment="This function parses the TEXT string and converts it into a DATE value, according to specified style (conversion mask)." function-arguments="p_datestring text, p_style numeric DEFAULT 0" function-identity-arguments="p_datestring text, p_style numeric">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_day VARCHAR;
    v_year VARCHAR;
    v_month VARCHAR;
    v_hijridate DATE;
    v_style SMALLINT;
    v_leftpart VARCHAR;
    v_middlepart VARCHAR;
    v_rightpart VARCHAR;
    v_fractsecs VARCHAR;
    v_datestring VARCHAR;
    v_err_message VARCHAR;
    v_date_format VARCHAR;
    v_regmatch_groups TEXT[];
    v_lang_metadata_json JSONB;
    v_compmonth_regexp VARCHAR;
    CONVERSION_LANG CONSTANT VARCHAR := '';
    DATE_FORMAT CONSTANT VARCHAR := '';
    DAYMM_REGEXP CONSTANT VARCHAR := '(\d{1,2})';
    FULLYEAR_REGEXP CONSTANT VARCHAR := '(\d{4})';
    SHORTYEAR_REGEXP CONSTANT VARCHAR := '(\d{1,2})';
    COMPYEAR_REGEXP CONSTANT VARCHAR := '(\d{1,2}|\d{4})';
    AMPM_REGEXP CONSTANT VARCHAR := '(?:[AP]M)';
    TIMEUNIT_REGEXP CONSTANT VARCHAR := '\s*\d{1,2}\s*';
    FRACTSECS_REGEXP CONSTANT VARCHAR := '\s*\d{1,9}';
    HHMMSSFS_PART_REGEXP CONSTANT VARCHAR := concat('(', TIMEUNIT_REGEXP, AMPM_REGEXP, '|',
                                                    TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '|',
                                                    TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '|',
                                                    TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '(?:\.|\:)', FRACTSECS_REGEXP,
                                                    ')\s*', AMPM_REGEXP, '?');
    HHMMSSFS_DOTPART_REGEXP CONSTANT VARCHAR := concat('(', TIMEUNIT_REGEXP, AMPM_REGEXP, '|',
                                                       TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '|',
                                                       TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '|',
                                                       TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '\.', FRACTSECS_REGEXP,
                                                       ')\s*', AMPM_REGEXP, '?');
    HHMMSSFS_REGEXP CONSTANT VARCHAR := concat('^', HHMMSSFS_PART_REGEXP, '$');
    HHMMSSFS_DOT_REGEXP CONSTANT VARCHAR := concat('^', HHMMSSFS_DOTPART_REGEXP, '$');
    v_defmask1_regexp VARCHAR := concat('^($comp_month$)\s*', DAYMM_REGEXP, '\s+', COMPYEAR_REGEXP, '$');
    v_defmask2_regexp VARCHAR := concat('^', DAYMM_REGEXP, '\s*($comp_month$)\s*', COMPYEAR_REGEXP, '$');
    v_defmask3_regexp VARCHAR := concat('^', FULLYEAR_REGEXP, '\s*($comp_month$)\s*', DAYMM_REGEXP, '$');
    v_defmask4_regexp VARCHAR := concat('^', FULLYEAR_REGEXP, '\s+', DAYMM_REGEXP, '\s*($comp_month$)$');
    v_defmask5_regexp VARCHAR := concat('^', DAYMM_REGEXP, '\s+', COMPYEAR_REGEXP, '\s*($comp_month$)$');
    v_defmask6_regexp VARCHAR := concat('^($comp_month$)\s*', FULLYEAR_REGEXP, '\s+', DAYMM_REGEXP, '$');
    v_defmask7_regexp VARCHAR := concat('^($comp_month$)\s*', DAYMM_REGEXP, '\s*\,\s*', COMPYEAR_REGEXP, '$');
    v_defmask8_regexp VARCHAR := concat('^', FULLYEAR_REGEXP, '\s*($comp_month$)$');
    v_defmask9_regexp VARCHAR := concat('^($comp_month$)\s*', FULLYEAR_REGEXP, '$');
    v_defmask10_regexp VARCHAR := concat('^', DAYMM_REGEXP, '\s*(?:\.|/|-)\s*($comp_month$)\s*(?:\.|/|-)\s*', COMPYEAR_REGEXP, '$');
    DOT_SHORTYEAR_REGEXP CONSTANT VARCHAR := concat('^', DAYMM_REGEXP, '\s*\.\s*', DAYMM_REGEXP, '\s*\.\s*', SHORTYEAR_REGEXP, '$');
    DOT_FULLYEAR_REGEXP CONSTANT VARCHAR := concat('^', DAYMM_REGEXP, '\s*\.\s*', DAYMM_REGEXP, '\s*\.\s*', FULLYEAR_REGEXP, '$');
    SLASH_SHORTYEAR_REGEXP CONSTANT VARCHAR := concat('^', DAYMM_REGEXP, '\s*/\s*', DAYMM_REGEXP, '\s*/\s*', SHORTYEAR_REGEXP, '$');
    SLASH_FULLYEAR_REGEXP CONSTANT VARCHAR := concat('^', DAYMM_REGEXP, '\s*/\s*', DAYMM_REGEXP, '\s*/\s*', FULLYEAR_REGEXP, '$');
    DASH_SHORTYEAR_REGEXP CONSTANT VARCHAR := concat('^', DAYMM_REGEXP, '\s*-\s*', DAYMM_REGEXP, '\s*-\s*', SHORTYEAR_REGEXP, '$');
    DASH_FULLYEAR_REGEXP CONSTANT VARCHAR := concat('^', DAYMM_REGEXP, '\s*-\s*', DAYMM_REGEXP, '\s*-\s*', FULLYEAR_REGEXP, '$');
    DOT_SLASH_DASH_YEAR_REGEXP CONSTANT VARCHAR := concat('^', DAYMM_REGEXP, '\s*(?:\.|/|-)\s*', DAYMM_REGEXP, '\s*(?:\.|/|-)\s*', COMPYEAR_REGEXP, '$');
    YEAR_DOTMASK_REGEXP CONSTANT VARCHAR := concat('^', FULLYEAR_REGEXP, '\s*\.\s*', DAYMM_REGEXP, '\s*\.\s*', DAYMM_REGEXP, '$');
    YEAR_SLASHMASK_REGEXP CONSTANT VARCHAR := concat('^', FULLYEAR_REGEXP, '\s*/\s*', DAYMM_REGEXP, '\s*/\s*', DAYMM_REGEXP, '$');
    YEAR_DASHMASK_REGEXP CONSTANT VARCHAR := concat('^', FULLYEAR_REGEXP, '\s*-\s*', DAYMM_REGEXP, '\s*-\s*', DAYMM_REGEXP, '$');
    YEAR_DOT_SLASH_DASH_REGEXP CONSTANT VARCHAR := concat('^', FULLYEAR_REGEXP, '\s*(?:\.|/|-)\s*', DAYMM_REGEXP, '\s*(?:\.|/|-)\s*', DAYMM_REGEXP, '$');
    DIGITMASK1_REGEXP CONSTANT VARCHAR := '^\d{6}$';
    DIGITMASK2_REGEXP CONSTANT VARCHAR := '^\d{8}$';
BEGIN
    v_style := floor(p_style)::SMALLINT;
    v_datestring := trim(p_datestring);

    IF (scale(p_style) > 0) THEN
        RAISE most_specific_type_mismatch;
    ELSIF (NOT ((v_style BETWEEN 0 AND 14) OR
                (v_style BETWEEN 20 AND 25) OR
                (v_style BETWEEN 100 AND 114) OR
                v_style IN (120, 121, 126, 127, 130, 131)))
    THEN
        RAISE invalid_parameter_value;
    END IF;

    IF (v_datestring ~* HHMMSSFS_PART_REGEXP AND v_datestring !~* HHMMSSFS_REGEXP)
    THEN
        v_datestring := trim(regexp_replace(v_datestring, HHMMSSFS_PART_REGEXP, '', 'gi'));
    END IF;

    BEGIN
        v_lang_metadata_json := aws_sqlserver_ext.get_lang_metadata_json(CONVERSION_LANG);
    EXCEPTION
        WHEN OTHERS THEN
        RAISE invalid_character_value_for_cast;
    END;

    v_date_format := coalesce(nullif(DATE_FORMAT, ''), v_lang_metadata_json ->> 'date_format');

    v_compmonth_regexp := array_to_string(array_cat(ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'months_shortnames')),
                                                    ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'months_names'))), '|');

    v_defmask1_regexp := replace(v_defmask1_regexp, '$comp_month$', v_compmonth_regexp);
    v_defmask2_regexp := replace(v_defmask2_regexp, '$comp_month$', v_compmonth_regexp);
    v_defmask3_regexp := replace(v_defmask3_regexp, '$comp_month$', v_compmonth_regexp);
    v_defmask4_regexp := replace(v_defmask4_regexp, '$comp_month$', v_compmonth_regexp);
    v_defmask5_regexp := replace(v_defmask5_regexp, '$comp_month$', v_compmonth_regexp);
    v_defmask6_regexp := replace(v_defmask6_regexp, '$comp_month$', v_compmonth_regexp);
    v_defmask7_regexp := replace(v_defmask7_regexp, '$comp_month$', v_compmonth_regexp);
    v_defmask8_regexp := replace(v_defmask8_regexp, '$comp_month$', v_compmonth_regexp);
    v_defmask9_regexp := replace(v_defmask9_regexp, '$comp_month$', v_compmonth_regexp);
    v_defmask10_regexp := replace(v_defmask10_regexp, '$comp_month$', v_compmonth_regexp);

    IF (v_datestring ~* v_defmask1_regexp OR
        v_datestring ~* v_defmask2_regexp OR
        v_datestring ~* v_defmask3_regexp OR
        v_datestring ~* v_defmask4_regexp OR
        v_datestring ~* v_defmask5_regexp OR
        v_datestring ~* v_defmask6_regexp OR
        v_datestring ~* v_defmask7_regexp OR
        v_datestring ~* v_defmask8_regexp OR
        v_datestring ~* v_defmask9_regexp OR
        v_datestring ~* v_defmask10_regexp)
    THEN
        IF (v_style IN (130, 131)) THEN
            RAISE invalid_datetime_format;
        END IF;

        IF (v_datestring ~* v_defmask1_regexp)
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, v_defmask1_regexp, 'gi');
            v_day := v_regmatch_groups[2];
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[1], v_lang_metadata_json);
            v_year := aws_sqlserver_ext.get_full_year(v_regmatch_groups[3]);

        ELSIF (v_datestring ~* v_defmask2_regexp)
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, v_defmask2_regexp, 'gi');
            v_day := v_regmatch_groups[1];
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
            v_year := aws_sqlserver_ext.get_full_year(v_regmatch_groups[3]);

        ELSIF (v_datestring ~* v_defmask3_regexp)
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, v_defmask3_regexp, 'gi');
            v_day := v_regmatch_groups[3];
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
            v_year := v_regmatch_groups[1];

        ELSIF (v_datestring ~* v_defmask4_regexp)
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, v_defmask4_regexp, 'gi');
            v_day := v_regmatch_groups[2];
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[3], v_lang_metadata_json);
            v_year := v_regmatch_groups[1];

        ELSIF (v_datestring ~* v_defmask5_regexp)
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, v_defmask5_regexp, 'gi');
            v_day := v_regmatch_groups[1];
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[3], v_lang_metadata_json);
            v_year := aws_sqlserver_ext.get_full_year(v_regmatch_groups[2]);

        ELSIF (v_datestring ~* v_defmask6_regexp)
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, v_defmask6_regexp, 'gi');
            v_day := v_regmatch_groups[3];
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[1], v_lang_metadata_json);
            v_year := v_regmatch_groups[2];

        ELSIF (v_datestring ~* v_defmask7_regexp)
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, v_defmask7_regexp, 'gi');
            v_day := v_regmatch_groups[2];
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[1], v_lang_metadata_json);
            v_year := aws_sqlserver_ext.get_full_year(v_regmatch_groups[3]);

        ELSIF (v_datestring ~* v_defmask8_regexp)
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, v_defmask8_regexp, 'gi');
            v_day := '01';
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
            v_year := v_regmatch_groups[1];

        ELSIF (v_datestring ~* v_defmask9_regexp)
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, v_defmask9_regexp, 'gi');
            v_day := '01';
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[1], v_lang_metadata_json);
            v_year := v_regmatch_groups[2];
        ELSE
            v_regmatch_groups := regexp_matches(v_datestring, v_defmask10_regexp, 'gi');
            v_day := v_regmatch_groups[1];
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
            v_year := aws_sqlserver_ext.get_full_year(v_regmatch_groups[3]);
        END IF;
    ELSEIF (v_datestring ~* DOT_SHORTYEAR_REGEXP OR
            v_datestring ~* DOT_FULLYEAR_REGEXP OR
            v_datestring ~* SLASH_SHORTYEAR_REGEXP OR
            v_datestring ~* SLASH_FULLYEAR_REGEXP OR
            v_datestring ~* DASH_SHORTYEAR_REGEXP OR
            v_datestring ~* DASH_FULLYEAR_REGEXP)
    THEN
        IF (v_style IN (6, 7, 8, 9, 12, 13, 14, 24, 100, 106, 107, 108, 109, 112, 113, 114, 130)) THEN
            RAISE invalid_regular_expression;
        ELSIF (v_style IN (20, 21, 23, 25, 102, 111, 120, 121, 126, 127)) THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_datestring, DOT_SLASH_DASH_YEAR_REGEXP, 'gi');
        v_leftpart := v_regmatch_groups[1];
        v_middlepart := v_regmatch_groups[2];
        v_rightpart := v_regmatch_groups[3];

        IF (v_datestring ~* DOT_SHORTYEAR_REGEXP OR
            v_datestring ~* SLASH_SHORTYEAR_REGEXP OR
            v_datestring ~* DASH_SHORTYEAR_REGEXP)
        THEN
            IF ((v_style IN (1, 10, 22) AND v_date_format <> 'MDY') OR
                ((v_style IS NULL OR v_style IN (0, 1, 10, 22)) AND v_date_format NOT IN ('YDM', 'YMD', 'DMY', 'DYM', 'MYD')))
            THEN
                v_day := v_middlepart;
                v_month := v_leftpart;
                v_year := aws_sqlserver_ext.get_full_year(v_rightpart);

            ELSIF ((v_style IN (2, 11) AND v_date_format <> 'YMD') OR
                   ((v_style IS NULL OR v_style IN (0, 2, 11)) AND v_date_format = 'YMD'))
            THEN
                v_day := v_rightpart;
                v_month := v_middlepart;
                v_year := aws_sqlserver_ext.get_full_year(v_leftpart);

            ELSIF ((v_style IN (3, 4, 5) AND v_date_format <> 'DMY') OR
                   ((v_style IS NULL OR v_style IN (0, 3, 4, 5)) AND v_date_format = 'DMY'))
            THEN
                v_day := v_leftpart;
                v_month := v_middlepart;
                v_year := aws_sqlserver_ext.get_full_year(v_rightpart);

            ELSIF ((v_style IS NULL OR v_style = 0) AND v_date_format = 'DYM')
            THEN
                v_day := v_leftpart;
                v_month := v_rightpart;
                v_year := aws_sqlserver_ext.get_full_year(v_middlepart);

            ELSIF ((v_style IS NULL OR v_style = 0) AND v_date_format = 'MYD')
            THEN
                v_day := v_rightpart;
                v_month := v_leftpart;
                v_year := aws_sqlserver_ext.get_full_year(v_middlepart);

            ELSIF ((v_style IS NULL OR v_style = 0) AND v_date_format = 'YDM') THEN
                RAISE character_not_in_repertoire;
            ELSIF (v_style IN (101, 103, 104, 105, 110, 131)) THEN
                RAISE invalid_datetime_format;
            END IF;
        ELSE
            v_year := v_rightpart;

            IF (v_leftpart::SMALLINT <= 12)
            THEN
                IF ((v_style IN (103, 104, 105, 131) AND v_date_format <> 'DMY') OR
                    ((v_style IS NULL OR v_style IN (0, 103, 104, 105, 131)) AND v_date_format = 'DMY'))
                THEN
                    v_day := v_leftpart;
                    v_month := v_middlepart;
                ELSIF ((v_style IN (101, 110) AND v_date_format IN ('YDM', 'DMY', 'DYM')) OR
                       ((v_style IS NULL OR v_style IN (0, 101, 110)) AND v_date_format NOT IN ('YDM', 'DMY', 'DYM')))
                THEN
                    v_day := v_middlepart;
                    v_month := v_leftpart;
                ELSIF ((v_style IN (1, 2, 3, 4, 5, 10, 11, 22) AND v_date_format <> 'YDM') OR
                       ((v_style IS NULL OR v_style IN (0, 1, 2, 3, 4, 5, 10, 11, 22)) AND v_date_format = 'YDM'))
                THEN
                    RAISE invalid_datetime_format;
                END IF;
            ELSE
                IF ((v_style IN (103, 104, 105, 131) AND v_date_format <> 'DMY') OR
                    ((v_style IS NULL OR v_style IN (0, 103, 104, 105, 131)) AND v_date_format = 'DMY'))
                THEN
                    v_day := v_leftpart;
                    v_month := v_middlepart;
                ELSIF ((v_style IN (1, 2, 3, 4, 5, 10, 11, 22, 101, 110) AND v_date_format = 'DMY') OR
                       ((v_style IS NULL OR v_style IN (0, 1, 2, 3, 4, 5, 10, 11, 22, 101, 110)) AND v_date_format <> 'DMY'))
                THEN
                    RAISE invalid_datetime_format;
                END IF;
            END IF;
        END IF;
    ELSIF (v_datestring ~* YEAR_DOTMASK_REGEXP OR
           v_datestring ~* YEAR_SLASHMASK_REGEXP OR
           v_datestring ~* YEAR_DASHMASK_REGEXP)
    THEN
        IF (v_style IN (6, 7, 8, 9, 12, 13, 14, 24, 100, 106, 107, 108, 109, 112, 113, 114, 130)) THEN
            RAISE invalid_regular_expression;
        ELSIF (v_style IN (1, 2, 3, 4, 5, 10, 11, 22, 101, 103, 104, 105, 110, 131)) THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_datestring, YEAR_DOT_SLASH_DASH_REGEXP, 'gi');
        v_day := v_regmatch_groups[3];
        v_month := v_regmatch_groups[2];
        v_year := v_regmatch_groups[1];

    ELSIF (v_datestring ~* DIGITMASK1_REGEXP OR
           v_datestring ~* DIGITMASK2_REGEXP)
    THEN
        IF (v_datestring ~* DIGITMASK1_REGEXP)
        THEN
            v_day := substring(v_datestring, 5, 2);
            v_month := substring(v_datestring, 3, 2);
            v_year := aws_sqlserver_ext.get_full_year(substring(v_datestring, 1, 2));
        ELSE
            v_day := substring(v_datestring, 7, 2);
            v_month := substring(v_datestring, 5, 2);
            v_year := substring(v_datestring, 1, 4);
        END IF;
    ELSIF (v_datestring ~* HHMMSSFS_REGEXP)
    THEN
        v_fractsecs := coalesce(aws_sqlserver_ext.get_timeunit_from_string(v_datestring, 'FRACTSECONDS'), '');
        IF (v_datestring !~* HHMMSSFS_DOT_REGEXP AND char_length(v_fractsecs) > 3) THEN
            RAISE invalid_datetime_format;
        END IF;

        v_day := '01';
        v_month := '01';
        v_year := '1900';
    ELSE
        RAISE invalid_datetime_format;
    END IF;

    IF (((v_datestring ~* HHMMSSFS_REGEXP OR v_datestring ~* DIGITMASK1_REGEXP OR v_datestring ~* DIGITMASK2_REGEXP) AND v_style IN (130, 131)) OR
        ((v_datestring ~* DOT_FULLYEAR_REGEXP OR v_datestring ~* SLASH_FULLYEAR_REGEXP OR v_datestring ~* DASH_FULLYEAR_REGEXP) AND v_style = 131))
    THEN
        IF ((v_day::SMALLINT NOT BETWEEN 1 AND 29) OR
            (v_month::SMALLINT NOT BETWEEN 1 AND 12))
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_hijridate := aws_sqlserver_ext.conv_hijri_to_greg(v_day, v_month, v_year) - 1;
        v_datestring := to_char(v_hijridate, 'DD.MM.YYYY');

        v_day := split_part(v_datestring, '.', 1);
        v_month := split_part(v_datestring, '.', 2);
        v_year := split_part(v_datestring, '.', 3);
    END IF;

    RETURN to_date(concat_ws('.', v_day, v_month, v_year), 'DD.MM.YYYY');
EXCEPTION
    WHEN most_specific_type_mismatch THEN
        RAISE USING MESSAGE := 'Argument data type NUMERIC is invalid for argument 2 of conv_string_to_date function.',
                    DETAIL := 'Use of incorrect "style" parameter value during conversion process.',
                    HINT := 'Change "style" parameter to the proper value and try again.';

    WHEN invalid_parameter_value THEN
        RAISE USING MESSAGE := format('The style %s is not supported for conversions from VARCHAR to DATE.', v_style),
                    DETAIL := 'Use of incorrect "style" parameter value during conversion process.',
                    HINT := 'Change "style" parameter to the proper value and try again.';

    WHEN invalid_regular_expression THEN
        RAISE USING MESSAGE := format('The input character string doesn''t follow style %s.', v_style),
                    DETAIL := 'Selected "style" param value isn''t valid for conversion of passed character string.',
                    HINT := 'Either change the input character string or use a different style.';

    WHEN invalid_datetime_format THEN
        RAISE USING MESSAGE := 'Conversion failed when converting date from character string.',
                    DETAIL := 'Incorrect using of pair of input parameters values during conversion process.',
                    HINT := 'Check the input parameters values, correct them if needed, and try again.';

    WHEN character_not_in_repertoire THEN
        RAISE USING MESSAGE := 'The YDM date format isn''t supported when converting from this string format to date.',
                    DETAIL := 'Use of incorrect DATE_FORMAT constant value regarding string format parameter during conversion process.',
                    HINT := 'Change DATE_FORMAT constant to one of these values: MDY|DMY|DYM, recompile function and try again.';

    WHEN invalid_character_value_for_cast THEN
        RAISE USING MESSAGE := format('Invalid CONVERSION_LANG constant value - ''%s''. Allowed values are: ''English'', ''Deutsch'', etc.',
                                      CONVERSION_LANG),
                    DETAIL := 'Compiled incorrect CONVERSION_LANG constant value in function''s body.',
                    HINT := 'Correct CONVERSION_LANG constant value in function''s body, recompile it and try again.';

    WHEN invalid_text_representation THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
        v_err_message := substring(lower(v_err_message), 'integer\:\s\"(.*)\"');

        RAISE USING MESSAGE := format('Error while trying to convert "%s" value to SMALLINT data type.',
                                      v_err_message),
                    DETAIL := 'Passed argument value contains illegal characters.',
                    HINT := 'Correct passed argument value, remove all illegal characters.';
END;
]]></complex-attribute>
                        <category _I_D="204d1a8b-7b10-4755-8bca-f18310a08422" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="4c9235c0-d585-43ca-b37b-39fd3d92205a" name="conv_string_to_datetime" function-id="16575" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="conv_string_to_datetime" is-aggregate="f" language-name="plpgsql" context="conv_string_to_datetime" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="timestamp" count-arguments="3" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="conv_string_to_datetime(p_datatype text, p_datetimestring text, p_style numeric)" arguments-datatypes="text,text,numeric" comment="This function parses the TEXT string and converts it into a DATETIME value, according to specified style (conversion mask)." function-arguments="p_datatype text, p_datetimestring text, p_style numeric DEFAULT 0" function-identity-arguments="p_datatype text, p_datetimestring text, p_style numeric">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_day VARCHAR;
    v_year VARCHAR;
    v_month VARCHAR;
    v_style SMALLINT;
    v_scale SMALLINT;
    v_hours VARCHAR;
    v_hijridate DATE;
    v_minutes VARCHAR;
    v_seconds VARCHAR;
    v_fseconds VARCHAR;
    v_datatype VARCHAR;
    v_timepart VARCHAR;
    v_leftpart VARCHAR;
    v_middlepart VARCHAR;
    v_rightpart VARCHAR;
    v_datestring VARCHAR;
    v_err_message VARCHAR;
    v_date_format VARCHAR;
    v_res_datatype VARCHAR;
    v_datetimestring VARCHAR;
    v_datatype_groups TEXT[];
    v_regmatch_groups TEXT[];
    v_lang_metadata_json JSONB;
    v_compmonth_regexp VARCHAR;
    v_resdatetime TIMESTAMP(6) WITHOUT TIME ZONE;
    CONVERSION_LANG CONSTANT VARCHAR := '';
    DATE_FORMAT CONSTANT VARCHAR := '';
    DAYMM_REGEXP CONSTANT VARCHAR := '(\d{1,2})';
    FULLYEAR_REGEXP CONSTANT VARCHAR := '(\d{4})';
    SHORTYEAR_REGEXP CONSTANT VARCHAR := '(\d{1,2})';
    COMPYEAR_REGEXP CONSTANT VARCHAR := '(\d{1,2}|\d{4})';
    AMPM_REGEXP CONSTANT VARCHAR := '(?:[AP]M)';
    MASKSEP_REGEXP CONSTANT VARCHAR := '(?:\.|-|/)';
    TIMEUNIT_REGEXP CONSTANT VARCHAR := '\s*\d{1,2}\s*';
    FRACTSECS_REGEXP CONSTANT VARCHAR := '\s*\d{1,9}\s*';
    DATATYPE_REGEXP CONSTANT VARCHAR := '^(DATETIME|SMALLDATETIME|DATETIME2)\s*(?:\()?\s*((?:-)?\d+)?\s*(?:\))?$';
    HHMMSSFS_PART_REGEXP CONSTANT VARCHAR := concat(TIMEUNIT_REGEXP, AMPM_REGEXP, '|',
                                                    TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, AMPM_REGEXP, '?|',
                                                    TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '\.', FRACTSECS_REGEXP, AMPM_REGEXP, '?|',
                                                    TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, AMPM_REGEXP, '?|',
                                                    TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '(?:\.|\:)', FRACTSECS_REGEXP, AMPM_REGEXP, '?');
    HHMMSSFS_DOT_PART_REGEXP CONSTANT VARCHAR := concat(TIMEUNIT_REGEXP, AMPM_REGEXP, '|',
                                                        TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, AMPM_REGEXP, '?|',
                                                        TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '\.', FRACTSECS_REGEXP, AMPM_REGEXP, '?|',
                                                        TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, AMPM_REGEXP, '?|',
                                                        TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '(?:\.)', FRACTSECS_REGEXP, AMPM_REGEXP, '?');
    HHMMSSFS_REGEXP CONSTANT VARCHAR := concat('^(', HHMMSSFS_PART_REGEXP, ')$');
    DEFMASK1_0_REGEXP CONSTANT VARCHAR := concat('^(', HHMMSSFS_PART_REGEXP, ')?\s*',
                                                 MASKSEP_REGEXP, '*\s*($comp_month$)\s*', DAYMM_REGEXP, '\s+', COMPYEAR_REGEXP,
                                                 '\s*(', HHMMSSFS_PART_REGEXP, ')?$');
    DEFMASK1_1_REGEXP CONSTANT VARCHAR := concat('^', MASKSEP_REGEXP, '?\s*($comp_month$)\s*', DAYMM_REGEXP, '\s+', COMPYEAR_REGEXP, '$');
    DEFMASK1_2_REGEXP CONSTANT VARCHAR := concat('^', MASKSEP_REGEXP, '\s*($comp_month$)\s*', DAYMM_REGEXP, '\s+', COMPYEAR_REGEXP, '$');
    DEFMASK2_0_REGEXP CONSTANT VARCHAR := concat('^(', HHMMSSFS_PART_REGEXP, ')?\s*',
                                                 DAYMM_REGEXP, '\s*', MASKSEP_REGEXP, '*\s*($comp_month$)\s*', COMPYEAR_REGEXP,
                                                 '\s*(', HHMMSSFS_PART_REGEXP, ')?$');
    DEFMASK2_1_REGEXP CONSTANT VARCHAR := concat('^', DAYMM_REGEXP, '\s*', MASKSEP_REGEXP, '?\s*($comp_month$)\s*', COMPYEAR_REGEXP, '$');
    DEFMASK2_2_REGEXP CONSTANT VARCHAR := concat('^', DAYMM_REGEXP, '\s*', MASKSEP_REGEXP, '\s*($comp_month$)\s*', COMPYEAR_REGEXP, '$');
    DEFMASK3_0_REGEXP CONSTANT VARCHAR := concat('^(', HHMMSSFS_PART_REGEXP, ')?\s*',
                                                 FULLYEAR_REGEXP, '\s*', MASKSEP_REGEXP, '*\s*($comp_month$)\s*', DAYMM_REGEXP,
                                                 '\s*(', HHMMSSFS_PART_REGEXP, ')?$');
    DEFMASK3_1_REGEXP CONSTANT VARCHAR := concat('^', FULLYEAR_REGEXP, '\s*', MASKSEP_REGEXP, '?\s*($comp_month$)\s*', DAYMM_REGEXP, '$');
    DEFMASK3_2_REGEXP CONSTANT VARCHAR := concat('^', FULLYEAR_REGEXP, '\s*', MASKSEP_REGEXP, '\s*($comp_month$)\s*', DAYMM_REGEXP, '$');
    DEFMASK4_0_REGEXP CONSTANT VARCHAR := concat('^(', HHMMSSFS_PART_REGEXP, ')?\s*',
                                                 FULLYEAR_REGEXP, '\s+', DAYMM_REGEXP, '\s*', MASKSEP_REGEXP, '*\s*($comp_month$)',
                                                 '\s*(', HHMMSSFS_PART_REGEXP, ')?$');
    DEFMASK4_1_REGEXP CONSTANT VARCHAR := concat('^', FULLYEAR_REGEXP, '\s+', DAYMM_REGEXP, '\s*', MASKSEP_REGEXP, '?\s*($comp_month$)$');
    DEFMASK4_2_REGEXP CONSTANT VARCHAR := concat('^', FULLYEAR_REGEXP, '\s+', DAYMM_REGEXP, '\s*', MASKSEP_REGEXP, '\s*($comp_month$)$');
    DEFMASK5_0_REGEXP CONSTANT VARCHAR := concat('^(', HHMMSSFS_PART_REGEXP, ')?\s*',
                                                 DAYMM_REGEXP, '\s+', COMPYEAR_REGEXP, '\s*', MASKSEP_REGEXP, '*\s*($comp_month$)',
                                                 '\s*(', HHMMSSFS_PART_REGEXP, ')?$');
    DEFMASK5_1_REGEXP CONSTANT VARCHAR := concat('^', DAYMM_REGEXP, '\s+', COMPYEAR_REGEXP, '\s*', MASKSEP_REGEXP, '?\s*($comp_month$)$');
    DEFMASK5_2_REGEXP CONSTANT VARCHAR := concat('^', DAYMM_REGEXP, '\s+', COMPYEAR_REGEXP, '\s*', MASKSEP_REGEXP, '\s*($comp_month$)$');
    DEFMASK6_0_REGEXP CONSTANT VARCHAR := concat('^(', HHMMSSFS_PART_REGEXP, ')?\s*',
                                                 MASKSEP_REGEXP, '*\s*($comp_month$)\s*', FULLYEAR_REGEXP, '\s+', DAYMM_REGEXP,
                                                 '\s*(', HHMMSSFS_PART_REGEXP, ')?$');
    DEFMASK6_1_REGEXP CONSTANT VARCHAR := concat('^', MASKSEP_REGEXP, '?\s*($comp_month$)\s*', FULLYEAR_REGEXP, '\s+', DAYMM_REGEXP, '$');
    DEFMASK6_2_REGEXP CONSTANT VARCHAR := concat('^', MASKSEP_REGEXP, '\s*($comp_month$)\s*', FULLYEAR_REGEXP, '\s+', DAYMM_REGEXP, '$');
    DEFMASK7_0_REGEXP CONSTANT VARCHAR := concat('^(', HHMMSSFS_PART_REGEXP, ')?\s*',
                                                 MASKSEP_REGEXP, '*\s*($comp_month$)\s*', DAYMM_REGEXP, '\s*,\s*', COMPYEAR_REGEXP,
                                                 '\s*(', HHMMSSFS_PART_REGEXP, ')?$');
    DEFMASK7_1_REGEXP CONSTANT VARCHAR := concat('^', MASKSEP_REGEXP, '?\s*($comp_month$)\s*', DAYMM_REGEXP, '\s*,\s*', COMPYEAR_REGEXP, '$');
    DEFMASK7_2_REGEXP CONSTANT VARCHAR := concat('^', MASKSEP_REGEXP, '\s*($comp_month$)\s*', DAYMM_REGEXP, '\s*,\s*', COMPYEAR_REGEXP, '$');
    DEFMASK8_0_REGEXP CONSTANT VARCHAR := concat('^(', HHMMSSFS_PART_REGEXP, ')?\s*',
                                                 FULLYEAR_REGEXP, '\s*', MASKSEP_REGEXP, '*\s*($comp_month$)',
                                                 '\s*(', HHMMSSFS_PART_REGEXP, ')?$');
    DEFMASK8_1_REGEXP CONSTANT VARCHAR := concat('^', FULLYEAR_REGEXP, '\s*', MASKSEP_REGEXP, '?\s*($comp_month$)$');
    DEFMASK8_2_REGEXP CONSTANT VARCHAR := concat('^', FULLYEAR_REGEXP, '\s*', MASKSEP_REGEXP, '\s*($comp_month$)$');
    DEFMASK9_0_REGEXP CONSTANT VARCHAR := concat('^(', HHMMSSFS_PART_REGEXP, ')?\s*',
                                                 MASKSEP_REGEXP, '*\s*($comp_month$)\s*', FULLYEAR_REGEXP,
                                                 '\s*(', HHMMSSFS_PART_REGEXP, ')?$');
    DEFMASK9_1_REGEXP CONSTANT VARCHAR := concat('^', MASKSEP_REGEXP, '?\s*($comp_month$)\s*', FULLYEAR_REGEXP, '$');
    DEFMASK9_2_REGEXP CONSTANT VARCHAR := concat('^', MASKSEP_REGEXP, '\s*($comp_month$)\s*', FULLYEAR_REGEXP, '$');
    DEFMASK10_0_REGEXP CONSTANT VARCHAR := concat('^(', HHMMSSFS_PART_REGEXP, ')?\s*',
                                                  DAYMM_REGEXP, '\s*', MASKSEP_REGEXP, '\s*($comp_month$)\s*', MASKSEP_REGEXP, '\s*', COMPYEAR_REGEXP,
                                                  '\s*(', HHMMSSFS_PART_REGEXP, ')?$');
    DEFMASK10_1_REGEXP CONSTANT VARCHAR := concat('^', DAYMM_REGEXP, '\s*', MASKSEP_REGEXP, '\s*($comp_month$)\s*', MASKSEP_REGEXP, '\s*', COMPYEAR_REGEXP, '$');
    DOT_SLASH_DASH_COMPYEAR1_0_REGEXP CONSTANT VARCHAR := concat('^(', HHMMSSFS_PART_REGEXP, ')?\s*',
                                                                 DAYMM_REGEXP, '\s*(?:\.|/|-)\s*', DAYMM_REGEXP, '\s*(?:\.|/|-)\s*', COMPYEAR_REGEXP,
                                                                 '\s*(', HHMMSSFS_PART_REGEXP, ')?$');
    DOT_SLASH_DASH_COMPYEAR1_1_REGEXP CONSTANT VARCHAR := concat('^', DAYMM_REGEXP, '\s*', MASKSEP_REGEXP, '\s*', DAYMM_REGEXP, '\s*', MASKSEP_REGEXP, '\s*', COMPYEAR_REGEXP, '$');
    DOT_SLASH_DASH_SHORTYEAR_REGEXP CONSTANT VARCHAR := concat('^', DAYMM_REGEXP, '\s*', MASKSEP_REGEXP, '\s*', DAYMM_REGEXP, '\s*', MASKSEP_REGEXP, '\s*', SHORTYEAR_REGEXP, '$');
    DOT_SLASH_DASH_FULLYEAR1_0_REGEXP CONSTANT VARCHAR := concat('^(', HHMMSSFS_PART_REGEXP, ')?\s*',
                                                                 DAYMM_REGEXP, '\s*(?:\.|/|-)\s*', DAYMM_REGEXP, '\s*(?:\.|/|-)\s*', FULLYEAR_REGEXP,
                                                                 '\s*(', HHMMSSFS_PART_REGEXP, ')?$');
    DOT_SLASH_DASH_FULLYEAR1_1_REGEXP CONSTANT VARCHAR := concat('^', DAYMM_REGEXP, '\s*', MASKSEP_REGEXP, '\s*', DAYMM_REGEXP, '\s*', MASKSEP_REGEXP, '\s*', FULLYEAR_REGEXP, '$');
    FULLYEAR_DOT_SLASH_DASH1_0_REGEXP CONSTANT VARCHAR := concat('^(', HHMMSSFS_PART_REGEXP, ')?\s*',
                                                                 FULLYEAR_REGEXP, '\s*', MASKSEP_REGEXP, '\s*', DAYMM_REGEXP, '\s*', MASKSEP_REGEXP, '\s*', DAYMM_REGEXP,
                                                                 '\s*(', HHMMSSFS_PART_REGEXP, ')?$');
    FULLYEAR_DOT_SLASH_DASH1_1_REGEXP CONSTANT VARCHAR := concat('^', FULLYEAR_REGEXP, '\s*', MASKSEP_REGEXP, '\s*', DAYMM_REGEXP, '\s*', MASKSEP_REGEXP, '\s*', DAYMM_REGEXP, '$');
    SHORT_DIGITMASK1_0_REGEXP CONSTANT VARCHAR := concat('^(', HHMMSSFS_PART_REGEXP, ')?\s*\d{6}\s*(', HHMMSSFS_PART_REGEXP, ')?$');
    FULL_DIGITMASK1_0_REGEXP CONSTANT VARCHAR := concat('^(', HHMMSSFS_PART_REGEXP, ')?\s*\d{8}\s*(', HHMMSSFS_PART_REGEXP, ')?$');
BEGIN
    v_datatype := trim(p_datatype);
    v_datetimestring := upper(trim(p_datetimestring));
    v_style := floor(p_style)::SMALLINT;

    v_datatype_groups := regexp_matches(v_datatype, DATATYPE_REGEXP, 'gi');

    v_res_datatype := upper(v_datatype_groups[1]);
    v_scale := v_datatype_groups[2]::SMALLINT;

    IF (v_res_datatype IS NULL) THEN
        RAISE datatype_mismatch;
    ELSIF (v_res_datatype <> 'DATETIME2' AND v_scale IS NOT NULL)
    THEN
        RAISE invalid_indicator_parameter_value;
    ELSIF (coalesce(v_scale, 0) NOT BETWEEN 0 AND 7)
    THEN
        RAISE interval_field_overflow;
    ELSIF (v_scale IS NULL) THEN
        v_scale := 7;
    END IF;

    IF (scale(p_style) > 0) THEN
        RAISE most_specific_type_mismatch;
    ELSIF (NOT ((v_style BETWEEN 0 AND 14) OR
             (v_style BETWEEN 20 AND 25) OR
             (v_style BETWEEN 100 AND 114) OR
             (v_style IN (120, 121, 126, 127, 130, 131))) AND
             v_res_datatype = 'DATETIME2')
    THEN
        RAISE invalid_parameter_value;
    END IF;

    v_timepart := trim(substring(v_datetimestring, HHMMSSFS_PART_REGEXP));
    v_datestring := trim(regexp_replace(v_datetimestring, HHMMSSFS_PART_REGEXP, '', 'gi'));

    BEGIN
        v_lang_metadata_json := aws_sqlserver_ext.get_lang_metadata_json(CONVERSION_LANG);
    EXCEPTION
        WHEN OTHERS THEN
        RAISE invalid_escape_sequence;
    END;

    v_date_format := coalesce(nullif(DATE_FORMAT, ''), v_lang_metadata_json ->> 'date_format');

    v_compmonth_regexp := array_to_string(array_cat(ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'months_shortnames')),
                                                    ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'months_names'))), '|');

    IF (v_datetimestring ~* replace(DEFMASK1_0_REGEXP, '$comp_month$', v_compmonth_regexp) OR
        v_datetimestring ~* replace(DEFMASK2_0_REGEXP, '$comp_month$', v_compmonth_regexp) OR
        v_datetimestring ~* replace(DEFMASK3_0_REGEXP, '$comp_month$', v_compmonth_regexp) OR
        v_datetimestring ~* replace(DEFMASK4_0_REGEXP, '$comp_month$', v_compmonth_regexp) OR
        v_datetimestring ~* replace(DEFMASK5_0_REGEXP, '$comp_month$', v_compmonth_regexp) OR
        v_datetimestring ~* replace(DEFMASK6_0_REGEXP, '$comp_month$', v_compmonth_regexp) OR
        v_datetimestring ~* replace(DEFMASK7_0_REGEXP, '$comp_month$', v_compmonth_regexp) OR
        v_datetimestring ~* replace(DEFMASK8_0_REGEXP, '$comp_month$', v_compmonth_regexp) OR
        v_datetimestring ~* replace(DEFMASK9_0_REGEXP, '$comp_month$', v_compmonth_regexp) OR
        v_datetimestring ~* replace(DEFMASK10_0_REGEXP, '$comp_month$', v_compmonth_regexp))
    THEN
        IF ((v_style IN (127, 130, 131) AND v_res_datatype IN ('DATETIME', 'SMALLDATETIME')) OR
            (v_style IN (130, 131) AND v_res_datatype = 'DATETIME2'))
        THEN
            RAISE invalid_datetime_format;
        END IF;

        IF ((v_datestring ~* replace(DEFMASK1_2_REGEXP, '$comp_month$', v_compmonth_regexp) OR
             v_datestring ~* replace(DEFMASK2_2_REGEXP, '$comp_month$', v_compmonth_regexp) OR
             v_datestring ~* replace(DEFMASK3_2_REGEXP, '$comp_month$', v_compmonth_regexp) OR
             v_datestring ~* replace(DEFMASK4_2_REGEXP, '$comp_month$', v_compmonth_regexp) OR
             v_datestring ~* replace(DEFMASK5_2_REGEXP, '$comp_month$', v_compmonth_regexp) OR
             v_datestring ~* replace(DEFMASK6_2_REGEXP, '$comp_month$', v_compmonth_regexp) OR
             v_datestring ~* replace(DEFMASK7_2_REGEXP, '$comp_month$', v_compmonth_regexp) OR
             v_datestring ~* replace(DEFMASK8_2_REGEXP, '$comp_month$', v_compmonth_regexp) OR
             v_datestring ~* replace(DEFMASK9_2_REGEXP, '$comp_month$', v_compmonth_regexp)) AND
            v_res_datatype = 'DATETIME2')
        THEN
            RAISE invalid_datetime_format;
        END IF;

        IF (v_datestring ~* replace(DEFMASK1_1_REGEXP, '$comp_month$', v_compmonth_regexp))
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, replace(DEFMASK1_1_REGEXP, '$comp_month$', v_compmonth_regexp), 'gi');
            v_day := v_regmatch_groups[2];
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[1], v_lang_metadata_json);
            v_year := aws_sqlserver_ext.get_full_year(v_regmatch_groups[3]);

        ELSIF (v_datestring ~* replace(DEFMASK2_1_REGEXP, '$comp_month$', v_compmonth_regexp))
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, replace(DEFMASK2_1_REGEXP, '$comp_month$', v_compmonth_regexp), 'gi');
            v_day := v_regmatch_groups[1];
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
            v_year := aws_sqlserver_ext.get_full_year(v_regmatch_groups[3]);

        ELSIF (v_datestring ~* replace(DEFMASK3_1_REGEXP, '$comp_month$', v_compmonth_regexp))
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, replace(DEFMASK3_1_REGEXP, '$comp_month$', v_compmonth_regexp), 'gi');
            v_day := v_regmatch_groups[3];
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
            v_year := v_regmatch_groups[1];

        ELSIF (v_datestring ~* replace(DEFMASK4_1_REGEXP, '$comp_month$', v_compmonth_regexp))
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, replace(DEFMASK4_1_REGEXP, '$comp_month$', v_compmonth_regexp), 'gi');
            v_day := v_regmatch_groups[2];
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[3], v_lang_metadata_json);
            v_year := v_regmatch_groups[1];

        ELSIF (v_datestring ~* replace(DEFMASK5_1_REGEXP, '$comp_month$', v_compmonth_regexp))
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, replace(DEFMASK5_1_REGEXP, '$comp_month$', v_compmonth_regexp), 'gi');
            v_day := v_regmatch_groups[1];
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[3], v_lang_metadata_json);
            v_year := aws_sqlserver_ext.get_full_year(v_regmatch_groups[2]);

        ELSIF (v_datestring ~* replace(DEFMASK6_1_REGEXP, '$comp_month$', v_compmonth_regexp))
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, replace(DEFMASK6_1_REGEXP, '$comp_month$', v_compmonth_regexp), 'gi');
            v_day := v_regmatch_groups[3];
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[1], v_lang_metadata_json);
            v_year := v_regmatch_groups[2];

        ELSIF (v_datestring ~* replace(DEFMASK7_1_REGEXP, '$comp_month$', v_compmonth_regexp))
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, replace(DEFMASK7_1_REGEXP, '$comp_month$', v_compmonth_regexp), 'gi');
            v_day := v_regmatch_groups[2];
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[1], v_lang_metadata_json);
            v_year := aws_sqlserver_ext.get_full_year(v_regmatch_groups[3]);

        ELSIF (v_datestring ~* replace(DEFMASK8_1_REGEXP, '$comp_month$', v_compmonth_regexp))
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, replace(DEFMASK8_1_REGEXP, '$comp_month$', v_compmonth_regexp), 'gi');
            v_day := '01';
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
            v_year := v_regmatch_groups[1];

        ELSIF (v_datestring ~* replace(DEFMASK9_1_REGEXP, '$comp_month$', v_compmonth_regexp))
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, replace(DEFMASK9_1_REGEXP, '$comp_month$', v_compmonth_regexp), 'gi');
            v_day := '01';
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[1], v_lang_metadata_json);
            v_year := v_regmatch_groups[2];

        ELSIF (v_datestring ~* replace(DEFMASK10_1_REGEXP, '$comp_month$', v_compmonth_regexp))
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, replace(DEFMASK10_1_REGEXP, '$comp_month$', v_compmonth_regexp), 'gi');
            v_day := v_regmatch_groups[1];
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
            v_year := aws_sqlserver_ext.get_full_year(v_regmatch_groups[3]);
        ELSE
            RAISE invalid_character_value_for_cast;
        END IF;
    ELSIF (v_datetimestring ~* DOT_SLASH_DASH_COMPYEAR1_0_REGEXP)
    THEN
        IF (v_style IN (6, 7, 8, 9, 12, 13, 14, 24, 100, 106, 107, 108, 109, 112, 113, 114, 130) AND
            v_res_datatype = 'DATETIME2')
        THEN
            RAISE invalid_regular_expression;
        END IF;

        v_regmatch_groups := regexp_matches(v_datestring, DOT_SLASH_DASH_COMPYEAR1_1_REGEXP, 'gi');
        v_leftpart := v_regmatch_groups[1];
        v_middlepart := v_regmatch_groups[2];
        v_rightpart := v_regmatch_groups[3];

        IF (v_datestring ~* DOT_SLASH_DASH_SHORTYEAR_REGEXP)
        THEN
            IF ((v_style NOT IN (0, 1, 2, 3, 4, 5, 10, 11) AND v_res_datatype IN ('DATETIME', 'SMALLDATETIME')) OR
                (v_style NOT IN (0, 1, 2, 3, 4, 5, 10, 11, 12) AND v_res_datatype = 'DATETIME2'))
            THEN
                RAISE invalid_datetime_format;
            END IF;

            IF ((v_style IN (1, 10) AND v_date_format <> 'MDY' AND v_res_datatype IN ('DATETIME', 'SMALLDATETIME')) OR
                (v_style IN (0, 1, 10) AND v_date_format NOT IN ('DMY', 'DYM', 'MYD', 'YMD', 'YDM') AND v_res_datatype IN ('DATETIME', 'SMALLDATETIME')) OR
                (v_style IN (0, 1, 10, 22) AND v_date_format NOT IN ('DMY', 'DYM', 'MYD', 'YMD', 'YDM') AND v_res_datatype = 'DATETIME2') OR
                (v_style IN (1, 10, 22) AND v_date_format IN ('DMY', 'DYM', 'MYD', 'YMD', 'YDM') AND v_res_datatype = 'DATETIME2'))
            THEN
                v_day := v_middlepart;
                v_month := v_leftpart;
                v_year := aws_sqlserver_ext.get_full_year(v_rightpart);

            ELSIF ((v_style IN (2, 11) AND v_date_format <> 'YMD') OR
                   (v_style IN (0, 2, 11) AND v_date_format = 'YMD'))
            THEN
                v_day := v_rightpart;
                v_month := v_middlepart;
                v_year := aws_sqlserver_ext.get_full_year(v_leftpart);

            ELSIF ((v_style IN (3, 4, 5) AND v_date_format <> 'DMY') OR
                   (v_style IN (0, 3, 4, 5) AND v_date_format = 'DMY'))
            THEN
                v_day := v_leftpart;
                v_month := v_middlepart;
                v_year := aws_sqlserver_ext.get_full_year(v_rightpart);

            ELSIF (v_style = 0 AND v_date_format = 'DYM')
            THEN
                v_day = v_leftpart;
                v_month = v_rightpart;
                v_year = aws_sqlserver_ext.get_full_year(v_middlepart);

            ELSIF (v_style = 0 AND v_date_format = 'MYD')
            THEN
                v_day := v_rightpart;
                v_month := v_leftpart;
                v_year = aws_sqlserver_ext.get_full_year(v_middlepart);

            ELSIF (v_style = 0 AND v_date_format = 'YDM')
            THEN
                IF (v_res_datatype = 'DATETIME2') THEN
                    RAISE character_not_in_repertoire;
                END IF;

                v_day := v_middlepart;
                v_month := v_rightpart;
                v_year := aws_sqlserver_ext.get_full_year(v_leftpart);
            ELSE
                RAISE invalid_character_value_for_cast;
            END IF;
        ELSIF (v_datestring ~* DOT_SLASH_DASH_FULLYEAR1_1_REGEXP)
        THEN
            IF (v_style NOT IN (0, 20, 21, 101, 102, 103, 104, 105, 110, 111, 120, 121, 130, 131) AND
                v_res_datatype IN ('DATETIME', 'SMALLDATETIME'))
            THEN
                RAISE invalid_datetime_format;
            ELSIF (v_style IN (130, 131) AND v_res_datatype = 'SMALLDATETIME') THEN
                RAISE invalid_character_value_for_cast;
            END IF;

            v_year := v_rightpart;
            IF (v_leftpart::SMALLINT <= 12)
            THEN
                IF ((v_style IN (103, 104, 105, 130, 131) AND v_date_format NOT IN ('DMY', 'DYM', 'YDM')) OR
                    (v_style IN (0, 103, 104, 105, 130, 131) AND ((v_date_format = 'DMY' AND v_res_datatype = 'DATETIME2') OR
                    (v_date_format IN ('DMY', 'DYM', 'YDM') AND v_res_datatype <> 'DATETIME2'))) OR
                    (v_style IN (103, 104, 105, 130, 131) AND v_date_format IN ('DMY', 'DYM', 'YDM') AND v_res_datatype = 'DATETIME2'))
                THEN
                    v_day := v_leftpart;
                    v_month := v_middlepart;

                ELSIF ((v_style IN (20, 21, 101, 102, 110, 111, 120, 121) AND v_date_format IN ('DMY', 'DYM', 'YDM') AND v_res_datatype IN ('DATETIME', 'SMALLDATETIME')) OR
                       (v_style IN (0, 20, 21, 101, 102, 110, 111, 120, 121) AND v_date_format NOT IN ('DMY', 'DYM', 'YDM') AND v_res_datatype IN ('DATETIME', 'SMALLDATETIME')) OR
                       (v_style IN (101, 110) AND v_date_format IN ('DMY', 'DYM', 'MYD', 'YDM') AND v_res_datatype = 'DATETIME2') OR
                       (v_style IN (0, 101, 110) AND v_date_format NOT IN ('DMY', 'DYM', 'MYD', 'YDM') AND v_res_datatype = 'DATETIME2'))
                THEN
                    v_day := v_middlepart;
                    v_month := v_leftpart;
                END IF;
            ELSE
                IF ((v_style IN (103, 104, 105, 130, 131) AND v_date_format NOT IN ('DMY', 'DYM', 'YDM')) OR
                    (v_style IN (0, 103, 104, 105, 130, 131) AND ((v_date_format = 'DMY' AND v_res_datatype = 'DATETIME2') OR
                    (v_date_format IN ('DMY', 'DYM', 'YDM') AND v_res_datatype <> 'DATETIME2'))) OR
                    (v_style IN (103, 104, 105, 130, 131) AND v_date_format IN ('DMY', 'DYM', 'YDM') AND v_res_datatype = 'DATETIME2'))
                THEN
                    v_day := v_leftpart;
                    v_month := v_middlepart;
                ELSE
                    IF (v_res_datatype = 'DATETIME2') THEN
                        RAISE invalid_datetime_format;
                    END IF;

                    RAISE invalid_character_value_for_cast;
                END IF;
            END IF;
        END IF;
    ELSIF (v_datetimestring ~* FULLYEAR_DOT_SLASH_DASH1_0_REGEXP)
    THEN
        IF (v_style NOT IN (0, 20, 21, 101, 102, 103, 104, 105, 110, 111, 120, 121, 130, 131) AND
            v_res_datatype IN ('DATETIME', 'SMALLDATETIME'))
        THEN
            RAISE invalid_datetime_format;
        ELSIF (v_style IN (6, 7, 8, 9, 12, 13, 14, 24, 100, 106, 107, 108, 109, 112, 113, 114, 130) AND
            v_res_datatype = 'DATETIME2')
        THEN
            RAISE invalid_regular_expression;
        ELSIF (v_style IN (130, 131) AND v_res_datatype = 'SMALLDATETIME')
        THEN
            RAISE invalid_character_value_for_cast;
        END IF;

        v_regmatch_groups := regexp_matches(v_datestring, FULLYEAR_DOT_SLASH_DASH1_1_REGEXP, 'gi');
        v_year := v_regmatch_groups[1];
        v_middlepart := v_regmatch_groups[2];
        v_rightpart := v_regmatch_groups[3];

        IF ((v_res_datatype IN ('DATETIME', 'SMALLDATETIME') AND v_rightpart::SMALLINT <= 12) OR v_res_datatype = 'DATETIME2')
        THEN
            IF ((v_style IN (20, 21, 101, 102, 110, 111, 120, 121) AND v_date_format IN ('DMY', 'DYM', 'YDM') AND v_res_datatype <> 'DATETIME2') OR
                (v_style IN (0, 20, 21, 101, 102, 110, 111, 120, 121) AND v_date_format NOT IN ('DMY', 'DYM', 'YDM') AND v_res_datatype <> 'DATETIME2') OR                
                (v_style IN (0, 20, 21, 23, 25, 101, 102, 110, 111, 120, 121, 126, 127) AND v_res_datatype = 'DATETIME2'))
            THEN
                v_day := v_rightpart;
                v_month := v_middlepart;

            ELSIF ((v_style IN (103, 104, 105, 130, 131) AND v_date_format NOT IN ('DMY', 'DYM', 'YDM')) OR
                    v_style IN (0, 103, 104, 105, 130, 131) AND v_date_format IN ('DMY', 'DYM', 'YDM'))
            THEN
                v_day := v_middlepart;
                v_month := v_rightpart;
            END IF;
        ELSIF (v_res_datatype IN ('DATETIME', 'SMALLDATETIME') AND v_rightpart::SMALLINT > 12)
        THEN
            IF ((v_style IN (20, 21, 101, 102, 110, 111, 120, 121) AND v_date_format IN ('DMY', 'DYM', 'YDM')) OR
                (v_style IN (0, 20, 21, 101, 102, 110, 111, 120, 121) AND v_date_format NOT IN ('DMY', 'DYM', 'YDM')))
            THEN
                v_day := v_rightpart;
                v_month := v_middlepart;

            ELSIF ((v_style IN (103, 104, 105, 130, 131) AND v_date_format NOT IN ('DMY', 'DYM', 'YDM')) OR
                   (v_style IN (0, 103, 104, 105, 130, 131) AND v_date_format IN ('DMY', 'DYM', 'YDM')))
            THEN
                RAISE invalid_character_value_for_cast;
            END IF;
        END IF;
    ELSIF (v_datetimestring ~* SHORT_DIGITMASK1_0_REGEXP OR
           v_datetimestring ~* FULL_DIGITMASK1_0_REGEXP)
    THEN
        IF (v_style = 127 AND v_res_datatype <> 'DATETIME2')
        THEN
            RAISE invalid_datetime_format;
        ELSIF (v_style IN (130, 131) AND v_res_datatype = 'SMALLDATETIME')
        THEN
            RAISE invalid_character_value_for_cast;
        END IF;

        IF (v_datestring ~* '^\d{6}$')
        THEN
            v_day := substr(v_datestring, 5, 2);
            v_month := substr(v_datestring, 3, 2);
            v_year := aws_sqlserver_ext.get_full_year(substr(v_datestring, 1, 2));

        ELSIF (v_datestring ~* '^\d{8}$')
        THEN
            v_day := substr(v_datestring, 7, 2);
            v_month := substr(v_datestring, 5, 2);
            v_year := substr(v_datestring, 1, 4);
        END IF;
    ELSIF (v_datetimestring ~* HHMMSSFS_REGEXP)
    THEN
        v_day := '01';
        v_month := '01';
        v_year := '1900';
    ELSE
        RAISE invalid_datetime_format;
    END IF;

    IF (((v_datetimestring ~* HHMMSSFS_PART_REGEXP AND v_res_datatype = 'DATETIME2') OR
        (v_datetimestring ~* SHORT_DIGITMASK1_0_REGEXP OR v_datetimestring ~* FULL_DIGITMASK1_0_REGEXP OR
          v_datetimestring ~* FULLYEAR_DOT_SLASH_DASH1_0_REGEXP OR v_datetimestring ~* DOT_SLASH_DASH_FULLYEAR1_0_REGEXP)) AND
        v_style IN (130, 131))
    THEN
        v_hijridate := aws_sqlserver_ext.conv_hijri_to_greg(v_day, v_month, v_year) - 1;
        v_day = to_char(v_hijridate, 'DD');
        v_month = to_char(v_hijridate, 'MM');
        v_year = to_char(v_hijridate, 'YYYY');
    END IF;

    v_hours := coalesce(aws_sqlserver_ext.get_timeunit_from_string(v_timepart, 'HOURS'), '0');
    v_minutes := coalesce(aws_sqlserver_ext.get_timeunit_from_string(v_timepart, 'MINUTES'), '0');
    v_seconds := coalesce(aws_sqlserver_ext.get_timeunit_from_string(v_timepart, 'SECONDS'), '0');
    v_fseconds := coalesce(aws_sqlserver_ext.get_timeunit_from_string(v_timepart, 'FRACTSECONDS'), '0');

    IF ((v_res_datatype IN ('DATETIME', 'SMALLDATETIME') OR
         (v_res_datatype = 'DATETIME2' AND v_timepart !~* HHMMSSFS_DOT_PART_REGEXP)) AND
        char_length(v_fseconds) > 3)
    THEN
        RAISE invalid_datetime_format;
    END IF;

    BEGIN
        IF (v_res_datatype IN ('DATETIME', 'SMALLDATETIME'))
        THEN
            v_resdatetime := aws_sqlserver_ext.datetimefromparts(v_year, v_month, v_day,
                                                                 v_hours, v_minutes, v_seconds,
                                                                 rpad(v_fseconds, 3, '0'));
            IF (v_res_datatype = 'SMALLDATETIME' AND
                to_char(v_resdatetime, 'SS') <> '00')
            THEN
                IF (to_char(v_resdatetime, 'SS')::SMALLINT >= 30) THEN
                    v_resdatetime := v_resdatetime + INTERVAL '1 minute';
                END IF;

                v_resdatetime := to_timestamp(to_char(v_resdatetime, 'DD.MM.YYYY.HH24.MI'), 'DD.MM.YYYY.HH24.MI');
            END IF;
        ELSIF (v_res_datatype = 'DATETIME2')
        THEN
            v_fseconds := aws_sqlserver_ext.get_microsecs_from_fractsecs(v_fseconds, v_scale);
            v_seconds := concat_ws('.', v_seconds, v_fseconds);

            v_resdatetime := make_timestamp(v_year::SMALLINT, v_month::SMALLINT, v_day::SMALLINT,
                                            v_hours::SMALLINT, v_minutes::SMALLINT, v_seconds::NUMERIC);
        END IF;
    EXCEPTION
        WHEN datetime_field_overflow THEN
            RAISE invalid_datetime_format;
        WHEN OTHERS THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;

        IF (v_err_message ~* 'Cannot construct data type') THEN
            RAISE invalid_character_value_for_cast;
        END IF;
    END;

    RETURN v_resdatetime;
EXCEPTION
    WHEN most_specific_type_mismatch THEN
        RAISE USING MESSAGE := 'Argument data type NUMERIC is invalid for argument 3 of conv_string_to_datetime function.',
                    DETAIL := 'Use of incorrect "style" parameter value during conversion process.',
                    HINT := 'Change "style" parameter to the proper value and try again.';

    WHEN invalid_parameter_value THEN
        RAISE USING MESSAGE := format('The style %s is not supported for conversions from VARCHAR to %s.', v_style, v_res_datatype),
                    DETAIL := 'Use of incorrect "style" parameter value during conversion process.',
                    HINT := 'Change "style" parameter to the proper value and try again.';

    WHEN invalid_regular_expression THEN
        RAISE USING MESSAGE := format('The input character string doesn''t follow style %s.', v_style),
                    DETAIL := 'Selected "style" param value isn''t valid for conversion of passed character string.',
                    HINT := 'Either change the input character string or use a different style.';

    WHEN datatype_mismatch THEN
        RAISE USING MESSAGE := 'Data type should be one of these values: ''DATETIME'', ''SMALLDATETIME'', ''DATETIME2''/''DATETIME2(n)''.',
                    DETAIL := 'Use of incorrect "datatype" parameter value during conversion process.',
                    HINT := 'Change "datatype" parameter to the proper value and try again.';

    WHEN invalid_indicator_parameter_value THEN
        RAISE USING MESSAGE := format('Invalid attributes specified for data type %s.', v_res_datatype),
                    DETAIL := 'Use of incorrect scale value, which is not corresponding to specified data type.',
                    HINT := 'Change data type scale component or select different data type and try again.';

    WHEN interval_field_overflow THEN
        RAISE USING MESSAGE := format('Specified scale %s is invalid.', v_scale),
                    DETAIL := 'Use of incorrect data type scale value during conversion process.',
                    HINT := 'Change scale component of data type parameter to be in range [0..7] and try again.';

    WHEN invalid_datetime_format THEN
        RAISE USING MESSAGE := CASE v_res_datatype
                                  WHEN 'SMALLDATETIME' THEN 'Conversion failed when converting character string to SMALLDATETIME data type.'
                                  ELSE 'Conversion failed when converting date and time from character string.'
                               END,
                    DETAIL := 'Incorrect using of pair of input parameters values during conversion process.',
                    HINT := 'Check the input parameters values, correct them if needed, and try again.';

    WHEN invalid_character_value_for_cast THEN
        RAISE USING MESSAGE := 'The conversion of a VARCHAR data type to a DATETIME data type resulted in an out-of-range value.',
                    DETAIL := 'Use of incorrect pair of input parameter values during conversion process.',
                    HINT := 'Check input parameter values, correct them if needed, and try again.';

    WHEN character_not_in_repertoire THEN
        RAISE USING MESSAGE := 'The YDM date format isn''t supported when converting from this string format to date and time.',
                    DETAIL := 'Use of incorrect DATE_FORMAT constant value regarding string format parameter during conversion process.',
                    HINT := 'Change DATE_FORMAT constant to one of these values: MDY|DMY|DYM, recompile function and try again.';

    WHEN invalid_escape_sequence THEN
        RAISE USING MESSAGE := format('Invalid CONVERSION_LANG constant value - ''%s''. Allowed values are: ''English'', ''Deutsch'', etc.',
                                      CONVERSION_LANG),
                    DETAIL := 'Compiled incorrect CONVERSION_LANG constant value in function''s body.',
                    HINT := 'Correct CONVERSION_LANG constant value in function''s body, recompile it and try again.';

    WHEN invalid_text_representation THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
        v_err_message := substring(lower(v_err_message), 'integer\:\s\"(.*)\"');

        RAISE USING MESSAGE := format('Error while trying to convert "%s" value to SMALLINT data type.',
                                      v_err_message),
                    DETAIL := 'Passed argument value contains illegal characters.',
                    HINT := 'Correct passed argument value, remove all illegal characters.';
END;
]]></complex-attribute>
                        <category _I_D="5356dc7f-f6f2-4a68-aef4-e0928c607610" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ffd7e1bd-3be8-4779-800e-4aeb1d15e946" name="conv_string_to_time" function-id="16577" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="conv_string_to_time" is-aggregate="f" language-name="plpgsql" context="conv_string_to_time" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="time" count-arguments="3" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="conv_string_to_time(p_datatype text, p_timestring text, p_style numeric)" arguments-datatypes="text,text,numeric" comment="This function parses the TEXT string and converts it into a TIME value, according to specified style (conversion mask)." function-arguments="p_datatype text, p_timestring text, p_style numeric DEFAULT 0" function-identity-arguments="p_datatype text, p_timestring text, p_style numeric">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_hours SMALLINT;
    v_style SMALLINT;
    v_scale SMALLINT;
    v_daypart VARCHAR;
    v_seconds VARCHAR;
    v_minutes SMALLINT;
    v_fseconds VARCHAR;
    v_datatype VARCHAR;
    v_timestring VARCHAR;
    v_err_message VARCHAR;
    v_src_datatype VARCHAR;
    v_timeunit_mask VARCHAR;
    v_datatype_groups TEXT[];
    v_regmatch_groups TEXT[];
    AMPM_REGEXP CONSTANT VARCHAR := '\s*([AP]M)';
    TIMEUNIT_REGEXP CONSTANT VARCHAR := '\s*(\d{1,2})\s*';
    FRACTSECS_REGEXP CONSTANT VARCHAR := '\s*(\d{1,9})';
    HHMMSSFS_REGEXP CONSTANT VARCHAR := concat('^', TIMEUNIT_REGEXP,
                                               '\:', TIMEUNIT_REGEXP,
                                               '\:', TIMEUNIT_REGEXP,
                                               '(?:\.|\:)', FRACTSECS_REGEXP, '$');
    HHMMSS_REGEXP CONSTANT VARCHAR := concat('^', TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '$');
    HHMMFS_REGEXP CONSTANT VARCHAR := concat('^', TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '\.', FRACTSECS_REGEXP, '$');
    HHMM_REGEXP CONSTANT VARCHAR := concat('^', TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '$');
    HH_REGEXP CONSTANT VARCHAR := concat('^', TIMEUNIT_REGEXP, '$');
    DATATYPE_REGEXP CONSTANT VARCHAR := '^(TIME)\s*(?:\()?\s*((?:-)?\d+)?\s*(?:\))?$';
BEGIN
    v_datatype := trim(regexp_replace(p_datatype, 'DATETIME', 'TIME', 'gi'));
    v_timestring := upper(trim(p_timestring));
    v_style := floor(p_style)::SMALLINT;

    v_datatype_groups := regexp_matches(v_datatype, DATATYPE_REGEXP, 'gi');

    v_src_datatype := upper(v_datatype_groups[1]);
    v_scale := v_datatype_groups[2]::SMALLINT;

    IF (v_src_datatype IS NULL) THEN
        RAISE datatype_mismatch;
    ELSIF (coalesce(v_scale, 0) NOT BETWEEN 0 AND 7)
    THEN
        RAISE interval_field_overflow;
    ELSIF (v_scale IS NULL) THEN
        v_scale := 7;
    END IF;

    IF (scale(p_style) > 0) THEN
        RAISE most_specific_type_mismatch;
    ELSIF (NOT ((v_style BETWEEN 0 AND 14) OR
             (v_style BETWEEN 20 AND 25) OR
             (v_style BETWEEN 100 AND 114) OR
             v_style IN (120, 121, 126, 127, 130, 131)))
    THEN
        RAISE invalid_parameter_value;
    END IF;

    v_daypart := substring(v_timestring, 'AM|PM');
    v_timestring := trim(regexp_replace(v_timestring, coalesce(v_daypart, ''), ''));

    v_timeunit_mask :=
        CASE
           WHEN (v_timestring ~* HHMMSSFS_REGEXP) THEN HHMMSSFS_REGEXP
           WHEN (v_timestring ~* HHMMSS_REGEXP) THEN HHMMSS_REGEXP
           WHEN (v_timestring ~* HHMMFS_REGEXP) THEN HHMMFS_REGEXP
           WHEN (v_timestring ~* HHMM_REGEXP) THEN HHMM_REGEXP
           WHEN (v_timestring ~* HH_REGEXP) THEN HH_REGEXP
        END;

    IF (v_timeunit_mask IS NULL) THEN
        RAISE invalid_datetime_format;
    END IF;

    v_regmatch_groups := regexp_matches(v_timestring, v_timeunit_mask, 'gi');

    v_hours := v_regmatch_groups[1]::SMALLINT;
    v_minutes := v_regmatch_groups[2]::SMALLINT;

    IF (v_timestring ~* HHMMFS_REGEXP) THEN
        v_fseconds := v_regmatch_groups[3];
    ELSE
        v_seconds := v_regmatch_groups[3];
        v_fseconds := v_regmatch_groups[4];
    END IF;

   IF (v_daypart IS NOT NULL) THEN
      IF ((v_daypart = 'AM' AND v_hours NOT BETWEEN 0 AND 12) OR
          (v_daypart = 'PM' AND v_hours NOT BETWEEN 1 AND 23))
      THEN
          RAISE numeric_value_out_of_range;
      ELSIF (v_daypart = 'PM' AND v_hours < 12) THEN
          v_hours := v_hours + 12;
      ELSIF (v_daypart = 'AM' AND v_hours = 12) THEN
          v_hours := v_hours - 12;
      END IF;
   END IF;

    v_fseconds := aws_sqlserver_ext.get_microsecs_from_fractsecs(v_fseconds, v_scale);
    v_seconds := concat_ws('.', v_seconds, v_fseconds);

    RETURN make_time(v_hours, v_minutes, v_seconds::NUMERIC);
EXCEPTION
    WHEN most_specific_type_mismatch THEN
        RAISE USING MESSAGE := 'Argument data type NUMERIC is invalid for argument 3 of conv_string_to_time function.',
                    DETAIL := 'Use of incorrect "style" parameter value during conversion process.',
                    HINT := 'Change "style" parameter to the proper value and try again.';

    WHEN invalid_parameter_value THEN
        RAISE USING MESSAGE := format('The style %s is not supported for conversions from VARCHAR to TIME.', v_style),
                    DETAIL := 'Use of incorrect "style" parameter value during conversion process.',
                    HINT := 'Change "style" parameter to the proper value and try again.';

    WHEN datatype_mismatch THEN
        RAISE USING MESSAGE := 'Source data type should be ''TIME'' or ''TIME(n)''.',
                    DETAIL := 'Use of incorrect "datatype" parameter value during conversion process.',
                    HINT := 'Change "datatype" parameter to the proper value and try again.';

    WHEN interval_field_overflow THEN
        RAISE USING MESSAGE := format('Specified scale %s is invalid.', v_scale),
                    DETAIL := 'Use of incorrect data type scale value during conversion process.',
                    HINT := 'Change scale component of data type parameter to be in range [0..7] and try again.';

    WHEN numeric_value_out_of_range THEN
        RAISE USING MESSAGE := 'Could not extract correct hour value due to it''s inconsistency with AM|PM day part mark.',
                    DETAIL := 'Extracted hour value doesn''t fall in correct day part mark range: 0..12 for "AM" or 1..23 for "PM".',
                    HINT := 'Correct a hour value in the source string or remove AM|PM day part mark out of it.';

    WHEN invalid_datetime_format THEN
        RAISE USING MESSAGE := 'Conversion failed when converting time from character string.',
                    DETAIL := 'Incorrect using of pair of input parameters values during conversion process.',
                    HINT := 'Check the input parameters values, correct them if needed, and try again.';

    WHEN invalid_text_representation THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
        v_err_message := substring(lower(v_err_message), 'integer\:\s\"(.*)\"');

        RAISE USING MESSAGE := format('Error while trying to convert "%s" value to SMALLINT data type.',
                                      v_err_message),
                    DETAIL := 'Supplied value contains illegal characters.',
                    HINT := 'Correct supplied value, remove all illegal characters.';
END;
]]></complex-attribute>
                        <category _I_D="3ff71870-2751-45bd-9265-55611398dd0e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="7fdbc490-ec38-498a-99ec-174282323e85" name="conv_time_to_string" function-id="16571" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="conv_time_to_string" is-aggregate="f" language-name="plpgsql" context="conv_time_to_string" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="text" count-arguments="4" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="conv_time_to_string(p_datatype text, p_src_datatype text, p_timeval time without time zone, p_style numeric)" arguments-datatypes="text,text,time without time zone,numeric" comment="This function converts the TIME value into a character string, according to specified style (conversion mask)." function-arguments="p_datatype text, p_src_datatype text, p_timeval time without time zone, p_style numeric DEFAULT 25" function-identity-arguments="p_datatype text, p_src_datatype text, p_timeval time without time zone, p_style numeric">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_hours VARCHAR;
    v_style SMALLINT;
    v_scale SMALLINT;
    v_resmask VARCHAR;
    v_fseconds VARCHAR;
    v_datatype VARCHAR;
    v_resstring VARCHAR;
    v_lengthexpr VARCHAR;
    v_res_length SMALLINT;
    v_res_datatype VARCHAR;
    v_src_datatype VARCHAR;
    v_res_maxlength SMALLINT;
    VARCHAR_MAX CONSTANT SMALLINT := 8000;
    NVARCHAR_MAX CONSTANT SMALLINT := 4000;
    CHARACTER_REGEXP CONSTANT VARCHAR := 'CHAR|NCHAR|CHARACTER|NATIONAL CHARACTER';
    VARCHAR_REGEXP CONSTANT VARCHAR := 'VARCHAR|NVARCHAR|CHARACTER VARYING|NATIONAL CHARACTER VARYING';
    DATATYPE_REGEXP CONSTANT VARCHAR := concat('^\s*(', CHARACTER_REGEXP, '|', VARCHAR_REGEXP, ')\s*$');
    DATATYPE_MASK_REGEXP CONSTANT VARCHAR := concat('^\s*(?:', CHARACTER_REGEXP, '|', VARCHAR_REGEXP, ')\s*\(\s*(\d+|MAX)\s*\)\s*$');
    SRCDATATYPE_MASK_REGEXP CONSTANT VARCHAR := '^\s*(?:TIME)\s*(?:\s*\(\s*(\d+)\s*\)\s*)?\s*$';
BEGIN
    v_datatype := regexp_replace(upper(trim(p_datatype)), '\s+', ' ', 'gi');
    v_src_datatype := upper(trim(p_src_datatype));
    v_style := floor(p_style)::SMALLINT;

    IF (v_src_datatype ~* SRCDATATYPE_MASK_REGEXP)
    THEN
        v_scale := coalesce(substring(v_src_datatype, SRCDATATYPE_MASK_REGEXP)::SMALLINT, 7);

        IF (v_scale NOT BETWEEN 0 AND 7) THEN
            RAISE invalid_regular_expression;
        END IF;
    ELSE
        RAISE most_specific_type_mismatch;
    END IF;

    IF (v_datatype ~* DATATYPE_MASK_REGEXP)
    THEN
        v_res_datatype := rtrim(split_part(v_datatype, '(', 1));

        v_res_maxlength := CASE
                              WHEN substring(v_res_datatype, '^(NCHAR|NATIONAL.*)$') IS NULL
                              THEN VARCHAR_MAX
                              ELSE NVARCHAR_MAX
                           END;

        v_lengthexpr := substring(v_datatype, DATATYPE_MASK_REGEXP);

        IF (v_lengthexpr <> 'MAX' AND char_length(v_lengthexpr) > 4) THEN
            RAISE interval_field_overflow;
        END IF;

        v_res_length := CASE v_lengthexpr
                           WHEN 'MAX' THEN v_res_maxlength
                           ELSE v_lengthexpr::SMALLINT
                        END;
    ELSIF (v_datatype ~* DATATYPE_REGEXP) THEN
        v_res_datatype := v_datatype;
    ELSE
        RAISE datatype_mismatch;
    END IF;

    IF (scale(p_style) > 0) THEN
        RAISE escape_character_conflict;
    ELSIF (NOT ((v_style BETWEEN 0 AND 14) OR
                (v_style BETWEEN 20 AND 25) OR
                (v_style BETWEEN 100 AND 114) OR
                v_style IN (120, 121, 126, 127, 130, 131)))
    THEN
        RAISE invalid_parameter_value;
    ELSIF ((v_style BETWEEN 1 AND 7) OR
           (v_style BETWEEN 10 AND 12) OR
           (v_style BETWEEN 101 AND 107) OR
           (v_style BETWEEN 110 AND 112) OR
           v_style = 23)
    THEN
        RAISE invalid_datetime_format;
    END IF;

    v_hours := ltrim(to_char(p_timeval, 'HH12'), '0');
    v_fseconds := aws_sqlserver_ext.get_microsecs_from_fractsecs(to_char(p_timeval, 'US'), v_scale);

    IF (v_scale = 7) THEN
        v_fseconds := concat(v_fseconds, '0');
    END IF;

    IF (v_style IN (0, 100))
    THEN
        v_resmask := concat(v_hours, ':MIAM');
    ELSIF (v_style IN (8, 20, 24, 108, 120))
    THEN
        v_resmask := 'HH24:MI:SS';
    ELSIF (v_style IN (9, 109))
    THEN
        v_resmask := CASE
                        WHEN (char_length(v_fseconds) = 0) THEN concat(v_hours, ':MI:SSAM')
                        ELSE format('%s:MI:SS.%sAM', v_hours, v_fseconds)
                     END;
    ELSIF (v_style IN (13, 14, 21, 25, 113, 114, 121, 126, 127))
    THEN
        v_resmask := CASE
                        WHEN (char_length(v_fseconds) = 0) THEN 'HH24:MI:SS'
                        ELSE concat('HH24:MI:SS.', v_fseconds)
                     END;
    ELSIF (v_style = 22)
    THEN
        v_resmask := format('%s:MI:SS AM', lpad(v_hours, 2, ' '));
    ELSIF (v_style IN (130, 131))
    THEN
        v_resmask := CASE
                        WHEN (char_length(v_fseconds) = 0) THEN concat(lpad(v_hours, 2, ' '), ':MI:SSAM')
                        ELSE format('%s:MI:SS.%sAM', lpad(v_hours, 2, ' '), v_fseconds)
                     END;
    END IF;

    v_resstring := to_char(p_timeval, v_resmask);

    v_resstring := substring(v_resstring, 1, coalesce(v_res_length, char_length(v_resstring)));

    RETURN CASE
              WHEN substring(v_res_datatype, concat('^(', CHARACTER_REGEXP, ')$')) IS NOT NULL
              THEN rpad(v_resstring, coalesce(v_res_length, 30), ' ')
              ELSE v_resstring
           END;
EXCEPTION
    WHEN most_specific_type_mismatch THEN
        RAISE USING MESSAGE := 'Source data type should be ''TIME'' or ''TIME(n)''.',
                    DETAIL := 'Use of incorrect "src_datatype" parameter value during conversion process.',
                    HINT := 'Change "src_datatype" parameter to the proper value and try again.';

   WHEN invalid_regular_expression THEN
       RAISE USING MESSAGE := format('The source data type scale (%s) given to the convert specification exceeds the maximum allowable value (7).',
                                     v_scale),
                   DETAIL := 'Use of incorrect scale value of source data type parameter during conversion process.',
                   HINT := 'Change scale component of source data type parameter to the allowable value and try again.';

   WHEN interval_field_overflow THEN
       RAISE USING MESSAGE := format('The size (%s) given to the convert specification ''%s'' exceeds the maximum allowed for any data type (%s).',
                                     v_lengthexpr, lower(v_res_datatype), v_res_maxlength),
                   DETAIL := 'Use of incorrect size value of target data type parameter during conversion process.',
                   HINT := 'Change size component of data type parameter to the allowable value and try again.';

    WHEN escape_character_conflict THEN
        RAISE USING MESSAGE := 'Argument data type NUMERIC is invalid for argument 4 of convert function.',
                    DETAIL := 'Use of incorrect "style" parameter value during conversion process.',
                    HINT := 'Change "style" parameter to the proper value and try again.';

    WHEN invalid_parameter_value THEN
        RAISE USING MESSAGE := format('%s is not a valid style number when converting from TIME to a character string.', v_style),
                    DETAIL := 'Use of incorrect "style" parameter value during conversion process.',
                    HINT := 'Change "style" parameter to the proper value and try again.';

    WHEN datatype_mismatch THEN
        RAISE USING MESSAGE := concat('Data type should be one of these values: ''CHAR(n|MAX)'', ''NCHAR(n|MAX)'', ''VARCHAR(n|MAX)'', ''NVARCHAR(n|MAX)'', ',
                                      '''CHARACTER VARYING(n|MAX)'', ''NATIONAL CHARACTER VARYING(n|MAX)''.'),
                    DETAIL := 'Use of incorrect "datatype" parameter value during conversion process.',
                    HINT := 'Change "datatype" parameter to the proper value and try again.';

    WHEN invalid_datetime_format THEN
        RAISE USING MESSAGE := format('Error converting data type TIME to %s.',
                                      rtrim(split_part(trim(p_datatype), '(', 1))),
                    DETAIL := 'Incorrect using of pair of input parameters values during conversion process.',
                    HINT := 'Check the input parameters values, correct them if needed, and try again.';
END;
]]></complex-attribute>
                        <category _I_D="18a5a4ba-086c-47fe-90c0-b125b4ef38c6" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ccea9180-9199-4888-acc7-0283fde2283c" name="datediff" function-id="16675" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="datediff" is-aggregate="f" language-name="plpgsql" context="datediff" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" count-arguments="3" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="datediff(units character varying, start_t timestamp without time zone, end_t timestamp without time zone)" arguments-datatypes="character varying,timestamp without time zone,timestamp without time zone" function-arguments="units character varying, start_t timestamp without time zone, end_t timestamp without time zone" function-identity-arguments="units character varying, start_t timestamp without time zone, end_t timestamp without time zone">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  diff_interval INTERVAL; 
  diff INT = 0;
  years_diff INT = 0;
BEGIN
  IF units IN ('ms', 'millisecond', 'microsecond', 'mcs' ) THEN   
    IF units IN ('ms', 'millisecond') THEN   
      RETURN trunc((EXTRACT('epoch' FROM end_t) - EXTRACT('epoch' FROM start_t)) * 1000);
    END IF;
    
    IF units IN ('microsecond', 'mcs') THEN   
      RETURN trunc((EXTRACT('epoch' FROM end_t) - EXTRACT('epoch' FROM start_t)) * 1000000);
    END IF;
  END IF;
  
  IF units IN ('yy', 'yyyy', 'year', 'mm', 'm', 'month') THEN
    years_diff = DATE_PART('year', end_t) - DATE_PART('year', start_t);
 
    IF units IN ('yy', 'yyyy', 'year') THEN
      -- SQL Server does not count full years passed (only difference between year parts)
      RETURN years_diff;
    ELSE
      -- If end month is less than start month it will subtracted
      RETURN years_diff * 12 + (DATE_PART('month', end_t) - DATE_PART('month', start_t)); 
    END IF;
  END IF;

  IF units IN ('quarter', 'qq', 'q') THEN  
    -- RETURN (EXTRACT(QUARTER FROM end_t) + date_part('year',age(end_t,start_t)) * 4) - 1 QUARTER;
    years_diff = DATE_PART('year', end_t) - DATE_PART('year', start_t);
    RETURN (4-EXTRACT(QUARTER FROM start_t)) + EXTRACT(QUARTER FROM end_t) + (years_diff - 1) * 4;
  END IF;
 
  -- Minus operator returns interval 'DDD days HH:MI:SS'  
  diff_interval = date_trunc('day',end_t) - date_trunc('day',start_t);
  diff = diff + DATE_PART('day', diff_interval);
 
  IF units IN ('wk', 'ww', 'week') THEN
    diff = diff/7;
    RETURN diff;
  END IF;
 
  -- dayofyear , day, and weekday return in SQL SERVER the same value
  IF units IN ('dd', 'd', 'day', 'dayofyear', 'dy', 'y', 'weekday', 'dw', 'w' ) THEN
    RETURN diff;
  END IF;
 
  -- diff = diff * 24 + DATE_PART('hour', diff_interval); 
  diff_interval = end_t - start_t;
  diff = DATE_PART('day', diff_interval) * 24 + DATE_PART('hour', diff_interval); 
 
  IF units IN ('hh', 'hour') THEN
    IF DATE_PART('minute', diff_interval) > 0 THEN
      RETURN diff + 1;
    ELSE   
      RETURN diff;
    END IF;  
  END IF;
 
  diff = diff * 60 + DATE_PART('minute', diff_interval);
 
  IF units IN ('mi', 'n', 'minute') THEN
    IF DATE_PART('second', diff_interval) > 0 THEN
      RETURN diff + 1;
    ELSE   
      RETURN diff;
    END IF;  
  END IF;

  diff = diff * 60 + DATE_PART('second', diff_interval);                               
 
  RETURN diff;
END;
]]></complex-attribute>
                        <category _I_D="fcc6f510-d4ea-437e-b29c-83ae5a2254c2" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="9b770928-a94b-4034-8783-9132908abe5d" name="datetime2fromparts" function-id="16557" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="datetime2fromparts(p_year numeric, p_month numeric, p_day numeric, p_hour numeric, p_minute numeric, p_seconds numeric, p_fractions numeric, p_precision numeric)" is-aggregate="f" language-name="plpgsql" context="datetime2fromparts(p_year numeric, p_month numeric, p_day numeric, p_hour numeric, p_minute numeric, p_seconds numeric, p_fractions numeric, p_precision numeric)" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="timestamp" count-arguments="8" volatility="VOLATILE" is-window="f" overload-function-count="2" proc-language="plpgsql" function-signature="datetime2fromparts(p_year numeric, p_month numeric, p_day numeric, p_hour numeric, p_minute numeric, p_seconds numeric, p_fractions numeric, p_precision numeric)" arguments-datatypes="numeric,numeric,numeric,numeric,numeric,numeric,numeric,numeric" comment="This function returns a fully initialized DATETIME2 value, constructed from separate date and time parts." unique-suffix="(p_year numeric, p_month numeric, p_day numeric, p_hour numeric, p_minute numeric, p_seconds numeric, p_fractions numeric, p_precision numeric)" routine-number="16557" function-arguments="p_year numeric, p_month numeric, p_day numeric, p_hour numeric, p_minute numeric, p_seconds numeric, p_fractions numeric, p_precision numeric" function-identity-arguments="p_year numeric, p_month numeric, p_day numeric, p_hour numeric, p_minute numeric, p_seconds numeric, p_fractions numeric, p_precision numeric">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
   v_fractions VARCHAR;
   v_precision SMALLINT;
   v_err_message VARCHAR;
   v_calc_seconds NUMERIC;
BEGIN
   v_fractions := floor(p_fractions)::INTEGER::VARCHAR;
   v_precision := p_precision::SMALLINT;

   IF (scale(p_precision) > 0) THEN
      RAISE most_specific_type_mismatch;
   ELSIF ((p_year NOT BETWEEN 1 AND 9999) OR
       (p_month NOT BETWEEN 1 AND 12) OR
       (p_day NOT BETWEEN 1 AND 31) OR
       (p_hour NOT BETWEEN 0 AND 23) OR
       (p_minute NOT BETWEEN 0 AND 59) OR
       (p_seconds NOT BETWEEN 0 AND 59) OR
       (p_fractions NOT BETWEEN 0 AND 9999999) OR
       (p_fractions != 0 AND char_length(v_fractions) > p_precision))
   THEN
      RAISE invalid_datetime_format;
   ELSIF (v_precision NOT BETWEEN 0 AND 7) THEN
      RAISE invalid_parameter_value;
   END IF;

   v_calc_seconds := format('%s.%s',
                            floor(p_seconds)::SMALLINT,
                            substring(rpad(lpad(v_fractions, v_precision, '0'), 7, '0'), 1, 6))::NUMERIC;

   RETURN make_timestamp(floor(p_year)::SMALLINT,
                         floor(p_month)::SMALLINT,
                         floor(p_day)::SMALLINT,
                         floor(p_hour)::SMALLINT,
                         floor(p_minute)::SMALLINT,
                         v_calc_seconds);
EXCEPTION
   WHEN most_specific_type_mismatch THEN
      RAISE USING MESSAGE := 'Scale argument is not valid. Valid expressions for data type DATETIME2 scale argument are integer constants and integer constant expressions.',
                  DETAIL := 'Use of incorrect "precision" parameter value during conversion process.',
                  HINT := 'Change "precision" parameter to the proper value and try again.';

   WHEN invalid_parameter_value THEN
      RAISE USING MESSAGE := format('Specified scale %s is invalid.', v_precision),
                  DETAIL := 'Use of incorrect "precision" parameter value during conversion process.',
                  HINT := 'Change "precision" parameter to the proper value and try again.';

   WHEN invalid_datetime_format THEN
      RAISE USING MESSAGE := 'Cannot construct data type DATETIME2, some of the arguments have values which are not valid.',
                  DETAIL := 'Possible use of incorrect value of date or time part (which lies outside of valid range).',
                  HINT := 'Check each input argument belongs to the valid range and try again.';

   WHEN numeric_value_out_of_range THEN
      GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
      v_err_message := upper(split_part(v_err_message, ' ', 1));

      RAISE USING MESSAGE := format('Error while trying to cast to %s data type.', v_err_message),
                  DETAIL := format('Source value is out of %s data type range.', v_err_message),
                  HINT := format('Correct the source value you are trying to cast to %s data type and try again.',
                                 v_err_message);
END;
]]></complex-attribute>
                        <category _I_D="d6a173a1-d29e-4c1f-9f61-a51467f87a0c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="363af805-4cba-4549-b439-21e80f08d80d" name="datetime2fromparts" function-id="16558" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="datetime2fromparts(p_year text, p_month text, p_day text, p_hour text, p_minute text, p_seconds text, p_fractions text, p_precision text)" is-aggregate="f" language-name="plpgsql" context="datetime2fromparts(p_year text, p_month text, p_day text, p_hour text, p_minute text, p_seconds text, p_fractions text, p_precision text)" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="timestamp" count-arguments="8" volatility="VOLATILE" is-window="f" overload-function-count="2" proc-language="plpgsql" function-signature="datetime2fromparts(p_year text, p_month text, p_day text, p_hour text, p_minute text, p_seconds text, p_fractions text, p_precision text)" arguments-datatypes="text,text,text,text,text,text,text,text" comment="This function returns a fully initialized DATETIME2 value, constructed from separate date and time parts." unique-suffix="(p_year text, p_month text, p_day text, p_hour text, p_minute text, p_seconds text, p_fractions text, p_precision text)" routine-number="16558" function-arguments="p_year text, p_month text, p_day text, p_hour text, p_minute text, p_seconds text, p_fractions text, p_precision text" function-identity-arguments="p_year text, p_month text, p_day text, p_hour text, p_minute text, p_seconds text, p_fractions text, p_precision text">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_err_message VARCHAR;
BEGIN
    RETURN aws_sqlserver_ext.datetime2fromparts(p_year::NUMERIC, p_month::NUMERIC, p_day::NUMERIC,
                                                p_hour::NUMERIC, p_minute::NUMERIC, p_seconds::NUMERIC,
                                                p_fractions::NUMERIC, p_precision::NUMERIC);
EXCEPTION
    WHEN invalid_text_representation THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
        v_err_message := substring(lower(v_err_message), 'numeric\:\s\"(.*)\"');

        RAISE USING MESSAGE := format('Error while trying to convert "%s" value to NUMERIC data type.', v_err_message),
                    DETAIL := 'Supplied string value contains illegal characters.',
                    HINT := 'Correct supplied value, remove all illegal characters and try again.';
END;
]]></complex-attribute>
                        <category _I_D="f8b79cef-bf8e-4b06-9ad5-8ae852acc259" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b790b093-b0e9-4097-b9ba-220c2ddf7fe8" name="datetimefromparts" function-id="16559" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="datetimefromparts(p_year numeric, p_month numeric, p_day numeric, p_hour numeric, p_minute numeric, p_seconds numeric, p_milliseconds numeric)" is-aggregate="f" language-name="plpgsql" context="datetimefromparts(p_year numeric, p_month numeric, p_day numeric, p_hour numeric, p_minute numeric, p_seconds numeric, p_milliseconds numeric)" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="timestamp" count-arguments="7" volatility="VOLATILE" is-window="f" overload-function-count="2" proc-language="plpgsql" function-signature="datetimefromparts(p_year numeric, p_month numeric, p_day numeric, p_hour numeric, p_minute numeric, p_seconds numeric, p_milliseconds numeric)" arguments-datatypes="numeric,numeric,numeric,numeric,numeric,numeric,numeric" comment="This function returns a fully initialized DATETIME value, constructed from separate date and time parts." unique-suffix="(p_year numeric, p_month numeric, p_day numeric, p_hour numeric, p_minute numeric, p_seconds numeric, p_milliseconds numeric)" routine-number="16559" function-arguments="p_year numeric, p_month numeric, p_day numeric, p_hour numeric, p_minute numeric, p_seconds numeric, p_milliseconds numeric" function-identity-arguments="p_year numeric, p_month numeric, p_day numeric, p_hour numeric, p_minute numeric, p_seconds numeric, p_milliseconds numeric">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_err_message VARCHAR;
    v_calc_seconds NUMERIC;
    v_milliseconds SMALLINT;
    v_resdatetime TIMESTAMP WITHOUT TIME ZONE;
BEGIN
    IF ((p_year NOT BETWEEN 1753 AND 9999) OR
        (p_month NOT BETWEEN 1 AND 12) OR
        (p_day NOT BETWEEN 1 AND 31) OR
        (p_hour NOT BETWEEN 0 AND 23) OR
        (p_minute NOT BETWEEN 0 AND 59) OR
        (p_seconds NOT BETWEEN 0 AND 59) OR
        (p_milliseconds NOT BETWEEN 0 AND 999))
    THEN
        RAISE invalid_datetime_format;
    END IF;

    v_milliseconds := aws_sqlserver_ext.round_fractseconds(p_milliseconds::INTEGER);

    v_calc_seconds := format('%s.%s',
                             floor(p_seconds)::SMALLINT,
                             CASE v_milliseconds
                                WHEN 1000 THEN '0'
                                ELSE lpad(v_milliseconds::VARCHAR, 3, '0')
                             END)::NUMERIC;

    v_resdatetime := make_timestamp(floor(p_year)::SMALLINT,
                                    floor(p_month)::SMALLINT,
                                    floor(p_day)::SMALLINT,
                                    floor(p_hour)::SMALLINT,
                                    floor(p_minute)::SMALLINT,
                                    v_calc_seconds);
    RETURN CASE
              WHEN (v_milliseconds != 1000) THEN v_resdatetime
              ELSE v_resdatetime + INTERVAL '1 second'
           END;
EXCEPTION
    WHEN invalid_datetime_format THEN
        RAISE USING MESSAGE := 'Cannot construct data type datetime, some of the arguments have values which are not valid.',
                    DETAIL := 'Possible use of incorrect value of date or time part (which lies outside of valid range).',
                    HINT := 'Check each input argument belongs to the valid range and try again.';

    WHEN numeric_value_out_of_range THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
        v_err_message := upper(split_part(v_err_message, ' ', 1));

        RAISE USING MESSAGE := format('Error while trying to cast to %s data type.', v_err_message),
                    DETAIL := format('Source value is out of %s data type range.', v_err_message),
                    HINT := format('Correct the source value you are trying to cast to %s data type and try again.',
                                   v_err_message);
END;
]]></complex-attribute>
                        <category _I_D="07d5e388-7802-4157-88ea-dfb5b0f18860" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d69fbdfe-80dd-45e6-8bac-1c2822a05930" name="datetimefromparts" function-id="16560" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="datetimefromparts(p_year text, p_month text, p_day text, p_hour text, p_minute text, p_seconds text, p_milliseconds text)" is-aggregate="f" language-name="plpgsql" context="datetimefromparts(p_year text, p_month text, p_day text, p_hour text, p_minute text, p_seconds text, p_milliseconds text)" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="timestamp" count-arguments="7" volatility="VOLATILE" is-window="f" overload-function-count="2" proc-language="plpgsql" function-signature="datetimefromparts(p_year text, p_month text, p_day text, p_hour text, p_minute text, p_seconds text, p_milliseconds text)" arguments-datatypes="text,text,text,text,text,text,text" comment="This function returns a fully initialized DATETIME value, constructed from separate date and time parts." unique-suffix="(p_year text, p_month text, p_day text, p_hour text, p_minute text, p_seconds text, p_milliseconds text)" routine-number="16560" function-arguments="p_year text, p_month text, p_day text, p_hour text, p_minute text, p_seconds text, p_milliseconds text" function-identity-arguments="p_year text, p_month text, p_day text, p_hour text, p_minute text, p_seconds text, p_milliseconds text">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_err_message VARCHAR;
BEGIN
    RETURN aws_sqlserver_ext.datetimefromparts(p_year::NUMERIC, p_month::NUMERIC, p_day::NUMERIC,
                                               p_hour::NUMERIC, p_minute::NUMERIC,
                                               p_seconds::NUMERIC, p_milliseconds::NUMERIC);
EXCEPTION
    WHEN invalid_text_representation THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
        v_err_message := substring(lower(v_err_message), 'numeric\:\s\"(.*)\"');

        RAISE USING MESSAGE := format('Error while trying to convert "%s" value to NUMERIC data type.', v_err_message),
                    DETAIL := 'Supplied string value contains illegal characters.',
                    HINT := 'Correct supplied value, remove all illegal characters and try again.';
END;
]]></complex-attribute>
                        <category _I_D="b753f87f-1892-4687-96c1-18c285ccd500" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5d80cee7-79c6-4b63-b0a4-638456dcee99" name="dbts" function-id="16671" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="dbts" is-aggregate="f" language-name="plpgsql" context="dbts" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int8" count-arguments="0" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="dbts()">
                        <complex-attribute name="sql"><![CDATA[
declare
  v_res bigint;
begin
  SELECT last_value INTO v_res FROM aws_sqlserver_ext_data.inc_seq_rowversion;
  return v_res;
end;
]]></complex-attribute>
                        <category _I_D="ee2fec31-591a-4857-9b1b-1c6f908bfa45" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="80cb8e66-4c43-4421-8f59-3120e69c95e0" name="get_full_year" function-id="16563" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="get_full_year" is-aggregate="f" language-name="plpgsql" context="get_full_year" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="varchar" count-arguments="3" volatility="STABLE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="get_full_year(p_short_year text, p_base_century text, p_year_cutoff numeric)" arguments-datatypes="text,text,numeric" comment="This function transforms two-digit year to full-size four digit year value, according to base century and cutoff boundary optional parameters." function-arguments="p_short_year text, p_base_century text DEFAULT ''::text, p_year_cutoff numeric DEFAULT 49" function-identity-arguments="p_short_year text, p_base_century text, p_year_cutoff numeric">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_err_message VARCHAR;
    v_full_year SMALLINT;
    v_short_year SMALLINT;
    v_base_century SMALLINT;
    v_result_param_set JSONB;
    v_full_year_res_jsonb JSONB;
BEGIN
    v_short_year := p_short_year::SMALLINT;

    BEGIN
        v_full_year_res_jsonb := nullif(current_setting('aws_sqlserver_ext.full_year_res_json'), '')::JSONB;
    EXCEPTION
        WHEN undefined_object THEN
        v_full_year_res_jsonb := NULL;
    END;

    SELECT result
      INTO v_full_year
      FROM jsonb_to_recordset(v_full_year_res_jsonb) AS result_set (param1 SMALLINT,
                                                                    param2 TEXT,
                                                                    param3 NUMERIC,
                                                                    result VARCHAR)
     WHERE param1 = v_short_year
       AND param2 = p_base_century
       AND param3 = p_year_cutoff;

    IF (v_full_year IS NULL)
    THEN
        IF (v_short_year <= 99)
        THEN
            v_base_century := CASE
                                 WHEN (p_base_century ~ '^\s*([1-9]{1,2})\s*$') THEN concat(trim(p_base_century), '00')::SMALLINT
                                 ELSE trunc(extract(year from current_date)::NUMERIC, -2)
                              END;

            v_full_year = v_base_century + v_short_year;
            v_full_year = CASE
                             WHEN (v_short_year > p_year_cutoff) THEN v_full_year - 100
                             ELSE v_full_year
                          END;
        ELSE v_full_year := v_short_year;
        END IF;

        v_result_param_set := jsonb_build_object('param1', v_short_year,
                                                 'param2', p_base_century,
                                                 'param3', p_year_cutoff,
                                                 'result', v_full_year);
        v_full_year_res_jsonb := CASE
                                    WHEN (v_full_year_res_jsonb IS NULL) THEN jsonb_build_array(v_result_param_set)
                                    ELSE v_full_year_res_jsonb || v_result_param_set
                                 END;

        PERFORM set_config('aws_sqlserver_ext.full_year_res_json',
                           v_full_year_res_jsonb::TEXT,
                           FALSE);
    END IF;

    RETURN v_full_year;
EXCEPTION
    WHEN invalid_text_representation THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
        v_err_message := substring(lower(v_err_message), 'integer\:\s\"(.*)\"');

        RAISE USING MESSAGE := format('Error while trying to convert "%s" value to SMALLINT data type.',
                                      v_err_message),
                    DETAIL := 'Supplied value contains illegal characters.',
                    HINT := 'Correct supplied value, remove all illegal characters.';
END;
]]></complex-attribute>
                        <category _I_D="b1e3d63c-48d7-4ff9-8125-42a9c008dc29" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="99dc11e4-763d-4977-a980-24db19b09b57" name="get_id_by_name" function-id="16594" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="get_id_by_name" is-aggregate="f" language-name="plpgsql" context="get_id_by_name" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int8" count-arguments="1" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="get_id_by_name(object_name text)" arguments-datatypes="text" function-arguments="object_name text" function-identity-arguments="object_name text">
                        <complex-attribute name="sql"><![CDATA[
declare res bigint;
begin
  execute 'select x''' || substring(encode(digest(object_name, 'sha1'), 'hex'), 1, 8) || '''::bigint' into res;
  return res;  
end;
]]></complex-attribute>
                        <category _I_D="3675935d-bf5f-40cc-958d-b979ca159b18" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b110197f-5979-40cb-a465-16b2304128af" name="get_int_part" function-id="16544" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="get_int_part" is-aggregate="f" language-name="plpgsql" context="get_int_part" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="float8" count-arguments="1" volatility="STABLE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="get_int_part(p_srcnumber double precision)" arguments-datatypes="double precision" comment="This function returns an integer part of the passed value. Rounding to integer is applied according to the special logic." function-arguments="p_srcnumber double precision" function-identity-arguments="p_srcnumber double precision">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    RETURN CASE
              WHEN (p_srcnumber < -0.0000001) THEN ceil(p_srcnumber - 0.0000001)
              ELSE floor(p_srcnumber + 0.0000001)
           END;
END;
]]></complex-attribute>
                        <category _I_D="6e26634a-4060-4b60-b930-2b372dd5e51b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="1f221c0b-abb5-48c0-a42d-bd188262486c" name="get_jobs" function-id="16595" schema-id="16397" function-type="RET_DATASET" is-trigger-function="0" unique-function-name="get_jobs" is-aggregate="f" language-name="plpgsql" context="get_jobs" subcategories-loading="none" object-loading="extended" is-returning-set="t" ret-datatype="table" count-arguments="0" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="get_jobs()" arguments-datatypes="integer,text,character varying">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_job integer;
  var_what text;
  var_search_path varchar;
BEGIN

  SELECT js.job_step_id, js.command, '' 
    FROM aws_sqlserver_ext.sysjobschedules s
   INNER JOIN aws_sqlserver_ext.sysjobs j on j.job_id = s.job_id
   INNER JOIN aws_sqlserver_ext.sysjobsteps js ON js.job_id = j.job_id
    INTO var_job, var_what, var_search_path 
   WHERE (s.next_run_date + s.next_run_time) <= now()::timestamp
     AND j.enabled = 1
   ORDER BY (s.next_run_date + s.next_run_time) ASC
   LIMIT 1;

  IF var_job > 0
  THEN
    return query select var_job, var_what, var_search_path;
  END IF;

END;
]]></complex-attribute>
                        <category _I_D="7e9ce541-fb81-41d0-bba9-c180d5ec9b34" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="7d504e3b-8b59-45f7-87b8-5c417c540b1e" name="get_lang_metadata_json" function-id="16547" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="get_lang_metadata_json" is-aggregate="f" language-name="plpgsql" context="get_lang_metadata_json" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="jsonb" count-arguments="1" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="get_lang_metadata_json(p_lang_spec_culture text)" arguments-datatypes="text" comment="This function returns language metadata JSON by corresponding lang name or spec culture abbreviation." function-arguments="p_lang_spec_culture text" function-identity-arguments="p_lang_spec_culture text">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_locale_parts TEXT[];
    v_lang_data_jsonb JSONB;
    v_lang_spec_culture VARCHAR;
    v_is_cached BOOLEAN := FALSE;
BEGIN
    v_lang_spec_culture := upper(trim(p_lang_spec_culture));

    IF (char_length(v_lang_spec_culture) > 0)
    THEN
        BEGIN
            v_lang_data_jsonb := nullif(current_setting(format('aws_sqlserver_ext.lang_metadata_json.%s',
                                                               v_lang_spec_culture)), '')::JSONB;
        EXCEPTION
            WHEN undefined_object THEN
            v_lang_data_jsonb := NULL;
        END;

        IF (v_lang_data_jsonb IS NULL)
        THEN
            IF (v_lang_spec_culture IN ('AR', 'FI') OR
                v_lang_spec_culture ~ '-')
            THEN
                SELECT lang_data_jsonb
                  INTO STRICT v_lang_data_jsonb
                  FROM aws_sqlserver_ext.sys_languages
                 WHERE spec_culture = v_lang_spec_culture;
            ELSE
                SELECT lang_data_jsonb
                  INTO STRICT v_lang_data_jsonb
                  FROM aws_sqlserver_ext.sys_languages
                 WHERE lang_name_mssql = v_lang_spec_culture
                    OR lang_alias_mssql = v_lang_spec_culture;
            END IF;
        ELSE
            v_is_cached := TRUE;
        END IF;
    ELSE
        v_lang_spec_culture := current_setting('LC_TIME');

        v_lang_spec_culture := CASE
                                  WHEN (v_lang_spec_culture !~ '\.') THEN v_lang_spec_culture
                                  ELSE substring(v_lang_spec_culture, '(.*)(?:\.)')
                               END;

        v_lang_spec_culture := upper(regexp_replace(v_lang_spec_culture, '_|,\s*', '-', 'gi'));

        BEGIN
            v_lang_data_jsonb := nullif(current_setting(format('aws_sqlserver_ext.lang_metadata_json.%s',
                                                               v_lang_spec_culture)), '')::JSONB;
        EXCEPTION
            WHEN undefined_object THEN
            v_lang_data_jsonb := NULL;
        END;

        IF (v_lang_data_jsonb IS NULL)
        THEN
            BEGIN
                IF (char_length(v_lang_spec_culture) = 5)
                THEN
                    SELECT lang_data_jsonb
                      INTO STRICT v_lang_data_jsonb
                      FROM aws_sqlserver_ext.sys_languages
                     WHERE spec_culture = v_lang_spec_culture;
                ELSE
                    v_locale_parts := string_to_array(v_lang_spec_culture, '-');

                    SELECT lang_data_jsonb
                      INTO STRICT v_lang_data_jsonb
                      FROM aws_sqlserver_ext.sys_languages
                     WHERE lang_name_pg = v_locale_parts[1]
                       AND territory = v_locale_parts[2];
                END IF;
            EXCEPTION
                WHEN OTHERS THEN
                    v_lang_spec_culture := 'EN-US';

                    SELECT lang_data_jsonb
                      INTO v_lang_data_jsonb
                      FROM aws_sqlserver_ext.sys_languages
                     WHERE spec_culture = v_lang_spec_culture;
            END;
        ELSE
            v_is_cached := TRUE;
        END IF;
    END IF;

    IF (NOT v_is_cached) THEN
        PERFORM set_config(format('aws_sqlserver_ext.lang_metadata_json.%s',
                                  v_lang_spec_culture),
                           v_lang_data_jsonb::TEXT,
                           FALSE);
    END IF;

    RETURN v_lang_data_jsonb;
EXCEPTION
    WHEN invalid_text_representation THEN
        RAISE USING MESSAGE := format('The language metadata JSON value extracted from chache is not a valid JSON object.',
                                      p_lang_spec_culture),
                    HINT := 'Drop the current session, fix the appropriate record in "aws_sqlserver_ext.sys_languages" table, and try again after reconnection.';

    WHEN OTHERS THEN
        RAISE USING MESSAGE := format('"%s" is not a valid special culture or language name parameter.',
                                      p_lang_spec_culture),
                    DETAIL := 'Use of incorrect "lang_spec_culture" parameter value during conversion process.',
                    HINT := 'Change "lang_spec_culture" parameter to the proper value and try again.';
END;
]]></complex-attribute>
                        <category _I_D="200788e8-a562-4810-a7fc-10ba4a581d1d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="7abc3785-4f74-455c-90ea-e73af214626c" name="get_microsecs_from_fractsecs" function-id="16556" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="get_microsecs_from_fractsecs" is-aggregate="f" language-name="plpgsql" context="get_microsecs_from_fractsecs" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="varchar" count-arguments="2" volatility="STABLE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="get_microsecs_from_fractsecs(p_fractsecs text, p_scale numeric)" arguments-datatypes="text,numeric" comment="This function transforms MS SQL Server DATETIME2 fractions and precision (scale) parts into PostgreSQL microsecond values." function-arguments="p_fractsecs text, p_scale numeric DEFAULT 7" function-identity-arguments="p_fractsecs text, p_scale numeric">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_scale SMALLINT;
    v_decplaces INTEGER;
    v_fractsecs VARCHAR;
    v_pureplaces VARCHAR;
    v_rnd_fractsecs INTEGER;
    v_fractsecs_len INTEGER;
    v_pureplaces_len INTEGER;
    v_err_message VARCHAR;
BEGIN
    v_fractsecs := trim(p_fractsecs);
    v_fractsecs_len := char_length(v_fractsecs);
    v_scale := floor(p_scale)::SMALLINT;

    IF (v_fractsecs_len < 7) THEN
        v_fractsecs := rpad(v_fractsecs, 7, '0');
        v_fractsecs_len := char_length(v_fractsecs);
    END IF;

    v_pureplaces := trim(leading '0' from v_fractsecs);
    v_pureplaces_len := char_length(v_pureplaces);

    v_decplaces := v_fractsecs_len - v_pureplaces_len;

    v_rnd_fractsecs := round(v_fractsecs::INTEGER, (v_pureplaces_len - (v_scale - (v_fractsecs_len - v_pureplaces_len))) * (-1));

    v_fractsecs := concat(replace(rpad('', v_decplaces), ' ', '0'), v_rnd_fractsecs);

    RETURN substring(v_fractsecs, 1, CASE
                                        WHEN (v_scale >= 7) THEN 6
                                        ELSE v_scale
                                     END);
EXCEPTION
    WHEN invalid_text_representation THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
        v_err_message := substring(lower(v_err_message), 'integer\:\s\"(.*)\"');

        RAISE USING MESSAGE := format('Error while trying to convert "%s" value to SMALLINT data type.', v_err_message),
                    DETAIL := 'Supplied value contains illegal characters.',
                    HINT := 'Correct supplied value, remove all illegal characters.';
END;
]]></complex-attribute>
                        <category _I_D="27742aee-4d67-42e4-839d-68cc9ea6a245" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5e89d066-77b3-4461-8b29-1175d1c34dcb" name="get_monthnum_by_name" function-id="16566" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="get_monthnum_by_name" is-aggregate="f" language-name="plpgsql" context="get_monthnum_by_name" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int2" count-arguments="2" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="get_monthnum_by_name(p_monthname text, p_lang_metadata_json jsonb)" arguments-datatypes="text,jsonb" comment="This function returns month number (1-12) by corresponding month name, matched from language metadata JSON." function-arguments="p_monthname text, p_lang_metadata_json jsonb" function-identity-arguments="p_monthname text, p_lang_metadata_json jsonb">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_monthname TEXT;
    v_monthnum SMALLINT;
BEGIN
    v_monthname := lower(trim(p_monthname));

    v_monthnum := array_position(ARRAY(SELECT lower(jsonb_array_elements_text(p_lang_metadata_json -> 'months_shortnames'))), v_monthname);

    v_monthnum := coalesce(v_monthnum,
                           array_position(ARRAY(SELECT lower(jsonb_array_elements_text(p_lang_metadata_json -> 'months_names'))), v_monthname));

    v_monthnum := coalesce(v_monthnum,
                           array_position(ARRAY(SELECT lower(jsonb_array_elements_text(p_lang_metadata_json -> 'months_extrashortnames'))), v_monthname));

    v_monthnum := coalesce(v_monthnum,
                           array_position(ARRAY(SELECT lower(jsonb_array_elements_text(p_lang_metadata_json -> 'months_extranames'))), v_monthname));

    IF (v_monthnum IS NULL) THEN
        RAISE datetime_field_overflow;
    END IF;

    RETURN v_monthnum;
EXCEPTION
    WHEN datetime_field_overflow THEN
        RAISE USING MESSAGE := format('Can not convert value "%s" to a correct month number.',
                                      trim(p_monthname)),
                    DETAIL := 'Supplied month name is not valid.',
                    HINT := 'Correct supplied month name value and try again.';
END;
]]></complex-attribute>
                        <category _I_D="22b2ce0c-64ac-4853-bf48-0d21bcc9c2ed" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2fcb1e1d-ca01-4ee2-a455-ee840448e6f7" name="get_sequence_value" function-id="16596" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="get_sequence_value" is-aggregate="f" language-name="plpgsql" context="get_sequence_value" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int8" count-arguments="1" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="get_sequence_value(sequence_name character varying)" arguments-datatypes="character varying" function-arguments="sequence_name character varying" function-identity-arguments="sequence_name character varying">
                        <complex-attribute name="sql"><![CDATA[
declare
  v_res bigint;
begin
  execute 'select last_value from '|| sequence_name into v_res;
  return v_res;
end;
]]></complex-attribute>
                        <category _I_D="99b8238a-7d8a-403b-82ed-551b7d3f6bd0" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="9a8553ef-4bdf-4f48-93cd-e4e3c7a59109" name="get_service_setting" function-id="16674" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="get_service_setting" is-aggregate="f" language-name="plpgsql" context="get_service_setting" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="varchar" count-arguments="2" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="get_service_setting(p_service character varying, p_setting character varying)" arguments-datatypes="character varying,character varying" function-arguments="p_service character varying, p_setting character varying" function-identity-arguments="p_service character varying, p_setting character varying">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  settingValue aws_sqlserver_ext_data.service_settings.value%TYPE;
BEGIN
  SELECT value
    INTO settingValue 
    FROM aws_sqlserver_ext_data.service_settings 
   WHERE service = p_service 
     AND setting = p_setting;
 
  RETURN settingValue;
END;
]]></complex-attribute>
                        <category _I_D="b7c63ea1-0cc7-4650-a6f8-5a157c58159f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="dc0e0a64-17da-400d-9755-338ec009fb5e" name="get_timeunit_from_string" function-id="16564" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="get_timeunit_from_string" is-aggregate="f" language-name="plpgsql" context="get_timeunit_from_string" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="varchar" count-arguments="2" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="get_timeunit_from_string(p_timepart text, p_timeunit text)" arguments-datatypes="text,text" comment="This function returns certain time part (identified by p_timeunit param) extracted from the source string." function-arguments="p_timepart text, p_timeunit text" function-identity-arguments="p_timepart text, p_timeunit text">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_hours VARCHAR;
    v_minutes VARCHAR;
    v_seconds VARCHAR;
    v_fractsecs VARCHAR;
    v_daypart VARCHAR;
    v_timepart VARCHAR;
    v_timeunit VARCHAR;
    v_err_message VARCHAR;
    v_timeunit_mask VARCHAR;
    v_regmatch_groups TEXT[];
    AMPM_REGEXP CONSTANT VARCHAR := '\s*([AP]M)';
    TIMEUNIT_REGEXP CONSTANT VARCHAR := '\s*(\d{1,2})\s*';
    FRACTSECS_REGEXP CONSTANT VARCHAR := '\s*(\d{1,9})';
    HHMMSSFS_REGEXP CONSTANT VARCHAR := concat('^', TIMEUNIT_REGEXP,
                                               '\:', TIMEUNIT_REGEXP,
                                               '\:', TIMEUNIT_REGEXP,
                                               '(?:\.|\:)', FRACTSECS_REGEXP, '$');
    HHMMSS_REGEXP CONSTANT VARCHAR := concat('^', TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '$');
    HHMMFS_REGEXP CONSTANT VARCHAR := concat('^', TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '\.', FRACTSECS_REGEXP, '$');
    HHMM_REGEXP CONSTANT VARCHAR := concat('^', TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '$');
    HH_REGEXP CONSTANT VARCHAR := concat('^', TIMEUNIT_REGEXP, '$');
BEGIN
    v_timepart := upper(trim(p_timepart));
    v_timeunit := upper(trim(p_timeunit));

    v_daypart := substring(v_timepart, 'AM|PM');
    v_timepart := trim(regexp_replace(v_timepart, coalesce(v_daypart, ''), ''));

    v_timeunit_mask :=
        CASE
           WHEN (v_timepart ~* HHMMSSFS_REGEXP) THEN HHMMSSFS_REGEXP
           WHEN (v_timepart ~* HHMMSS_REGEXP) THEN HHMMSS_REGEXP
           WHEN (v_timepart ~* HHMMFS_REGEXP) THEN HHMMFS_REGEXP
           WHEN (v_timepart ~* HHMM_REGEXP) THEN HHMM_REGEXP
           WHEN (v_timepart ~* HH_REGEXP) THEN HH_REGEXP
        END;

    v_regmatch_groups := regexp_matches(v_timepart, v_timeunit_mask, 'gi');

    v_hours := v_regmatch_groups[1];
    v_minutes := v_regmatch_groups[2];

    IF (v_timepart ~* HHMMFS_REGEXP) THEN
        v_fractsecs := v_regmatch_groups[3];
    ELSE
        v_seconds := v_regmatch_groups[3];
        v_fractsecs := v_regmatch_groups[4];
    END IF;

    IF (v_timeunit = 'HOURS' AND v_daypart IS NOT NULL)
    THEN
        IF ((v_daypart = 'AM' AND v_hours::SMALLINT NOT BETWEEN 0 AND 12) OR
            (v_daypart = 'PM' AND v_hours::SMALLINT NOT BETWEEN 1 AND 23))
        THEN
            RAISE numeric_value_out_of_range;
        ELSIF (v_daypart = 'PM' AND v_hours::SMALLINT < 12) THEN
            v_hours := (v_hours::SMALLINT + 12)::VARCHAR;
        ELSIF (v_daypart = 'AM' AND v_hours::SMALLINT = 12) THEN
            v_hours := (v_hours::SMALLINT - 12)::VARCHAR;
        END IF;
    END IF;

    RETURN CASE v_timeunit
              WHEN 'HOURS' THEN v_hours
              WHEN 'MINUTES' THEN v_minutes
              WHEN 'SECONDS' THEN v_seconds
              WHEN 'FRACTSECONDS' THEN v_fractsecs
           END;
EXCEPTION
    WHEN numeric_value_out_of_range THEN
        RAISE USING MESSAGE := 'Could not extract correct hour value due to it''s inconsistency with AM|PM day part mark.',
                    DETAIL := 'Extracted hour value doesn''t fall in correct day part mark range: 0..12 for "AM" or 1..23 for "PM".',
                    HINT := 'Correct a hour value in the source string or remove AM|PM day part mark out of it.';

    WHEN invalid_text_representation THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
        v_err_message := substring(lower(v_err_message), 'integer\:\s\"(.*)\"');

        RAISE USING MESSAGE := format('Error while trying to convert "%s" value to SMALLINT data type.', v_err_message),
                    DETAIL := 'Supplied value contains illegal characters.',
                    HINT := 'Correct supplied value, remove all illegal characters.';
END;
]]></complex-attribute>
                        <category _I_D="7cc01506-d36b-4254-af3a-d6354c1d365a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="76de05c9-1b75-4ebc-8a88-995b3ef2f29b" name="get_version" function-id="16597" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="get_version" is-aggregate="f" language-name="plpgsql" context="get_version" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="varchar" count-arguments="1" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="get_version(pcomponentname character varying)" arguments-datatypes="character varying" function-arguments="pcomponentname character varying" function-identity-arguments="pcomponentname character varying">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  lComponentVersion VARCHAR(256);
BEGIN
	SELECT componentversion 
	  INTO lComponentVersion 
	  FROM aws_sqlserver_ext.versions
	 WHERE extpackcomponentname = pComponentName;

	RETURN lComponentVersion;
END;
]]></complex-attribute>
                        <category _I_D="ee774b9a-95bf-42d5-802e-2cdead61682c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="82f6df51-62de-416f-a93d-df9558d590f0" name="get_weekdaynum_by_name" function-id="16565" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="get_weekdaynum_by_name" is-aggregate="f" language-name="plpgsql" context="get_weekdaynum_by_name" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int2" count-arguments="2" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="get_weekdaynum_by_name(p_weekdayname text, p_lang_metadata_json jsonb)" arguments-datatypes="text,jsonb" comment="This function returns weekday number (1-7) by corresponding weekday name, matched from language metadata JSON." function-arguments="p_weekdayname text, p_lang_metadata_json jsonb" function-identity-arguments="p_weekdayname text, p_lang_metadata_json jsonb">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_weekdayname TEXT;
    v_weekdaynum SMALLINT;
BEGIN
    v_weekdayname := lower(trim(p_weekdayname));

    v_weekdaynum := array_position(ARRAY(SELECT lower(jsonb_array_elements_text(p_lang_metadata_json -> 'days_names'))), v_weekdayname);

    v_weekdaynum := coalesce(v_weekdaynum,
                             array_position(ARRAY(SELECT lower(jsonb_array_elements_text(p_lang_metadata_json -> 'days_shortnames'))), v_weekdayname));

    v_weekdaynum := coalesce(v_weekdaynum,
                             array_position(ARRAY(SELECT lower(jsonb_array_elements_text(p_lang_metadata_json -> 'days_extrashortnames'))), v_weekdayname));

    IF (v_weekdaynum IS NULL) THEN
        RAISE datetime_field_overflow;
    END IF;

    RETURN v_weekdaynum;
EXCEPTION
    WHEN datetime_field_overflow THEN
        RAISE USING MESSAGE := format('Can not convert value "%s" to a correct weekday number.',
                                      trim(p_weekdayname)),
                    DETAIL := 'Supplied weekday name is not valid.',
                    HINT := 'Correct supplied weekday name value and try again.';
END;
]]></complex-attribute>
                        <category _I_D="7e81ec10-cd48-4a5e-9dbf-2dda5d437c55" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ffc4c1c9-5d2d-4689-a987-4fda34896711" name="isdate" function-id="16598" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="isdate" is-aggregate="f" language-name="plpgsql" context="isdate" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="bool" count-arguments="1" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="isdate(v text)" arguments-datatypes="text" function-arguments="v text" function-identity-arguments="v text">
                        <complex-attribute name="sql"><![CDATA[
begin
  perform v::date;
  return true;
exception
  when others then
   return false;
end
]]></complex-attribute>
                        <category _I_D="cd4122bf-df52-46f9-878b-e8fa75427e4f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="bb850af8-3a66-4176-96cd-1d46193fdf33" name="isnumeric" function-id="16599" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="isnumeric(_input numeric)" is-aggregate="f" language-name="plpgsql" context="isnumeric(_input numeric)" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="bool" count-arguments="1" volatility="IMMUTABLE" is-window="f" overload-function-count="2" proc-language="plpgsql" function-signature="isnumeric(_input numeric)" arguments-datatypes="numeric" unique-suffix="(_input numeric)" routine-number="16599" function-arguments="_input numeric" function-identity-arguments="_input numeric">
                        <complex-attribute name="sql"><![CDATA[
DECLARE x NUMERIC;
/***************************************************************
EXTENSION PACK function ISNUMERIC(x)
***************************************************************/
BEGIN
    x = $1::VARCHAR::NUMERIC;
    RETURN TRUE;
EXCEPTION WHEN others THEN
    RETURN FALSE;
END;
]]></complex-attribute>
                        <category _I_D="72529500-6b12-4e9a-8352-f9b1a0b40d2b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="529a5be8-b605-403e-a5a0-b8917b11b72a" name="isnumeric" function-id="16600" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="isnumeric(_input text)" is-aggregate="f" language-name="plpgsql" context="isnumeric(_input text)" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="bool" count-arguments="1" volatility="IMMUTABLE" is-window="f" overload-function-count="2" proc-language="plpgsql" function-signature="isnumeric(_input text)" arguments-datatypes="text" unique-suffix="(_input text)" routine-number="16600" function-arguments="_input text" function-identity-arguments="_input text">
                        <complex-attribute name="sql"><![CDATA[
DECLARE x NUMERIC;
/***************************************************************
EXTENSION PACK function ISNUMERIC(x)
***************************************************************/
BEGIN
    x = $1::VARCHAR::NUMERIC;
    RETURN TRUE;
EXCEPTION WHEN others THEN
    RETURN FALSE;
END;
]]></complex-attribute>
                        <category _I_D="3008538d-dede-429b-88e7-67e1736c209e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c74fb1a3-6851-4d59-822f-54d4d87c48be" name="istime" function-id="16601" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="istime" is-aggregate="f" language-name="plpgsql" context="istime" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="bool" count-arguments="1" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="istime(v text)" arguments-datatypes="text" function-arguments="v text" function-identity-arguments="v text">
                        <complex-attribute name="sql"><![CDATA[
begin
  perform v::time;
  return true;
exception
  when others then
   return false;
end
]]></complex-attribute>
                        <category _I_D="05ea0259-9f84-4f50-a653-b2f1ec439289" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e4489808-bcb0-44cb-b923-002fd881626b" name="newid" function-id="16602" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="newid" is-aggregate="f" language-name="plpgsql" context="newid" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="uuid" count-arguments="0" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="newid()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
  CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
  RETURN uuid_generate_v4();
END;
]]></complex-attribute>
                        <category _I_D="7604b366-3f71-4b90-8f89-da0dd4bf0e7e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b0fe3ec7-e89e-4fbf-897a-020551c87259" name="object_id" function-id="16670" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="object_id" is-aggregate="f" language-name="plpgsql" context="object_id" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" count-arguments="2" volatility="STABLE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="object_id(object_name character varying, object_type character)" arguments-datatypes="character varying,character" function-arguments="object_name character varying, object_type character DEFAULT ''::bpchar" function-identity-arguments="object_name character varying, object_type character">
                        <complex-attribute name="sql"><![CDATA[ 
declare id oid;
        lower_object_name character varying;
        is_temp_object boolean;
begin

  id := null;  
  lower_object_name := lower(object_name);
  is_temp_object := position('tempdb..#' in lower_object_name) > 0;
  
  while position('.' in lower_object_name) > 0 loop
    lower_object_name := substring(lower_object_name from strpos(lower_object_name, '.') + 1);
  end loop;
   
  if object_type <> '' then
    case 
      when upper(object_type) in ('S', 'U', 'V', 'IT', 'ET', 'SO') and is_temp_object then 
	id := (select oid from pg_class where lower(relname) = lower_object_name and relpersistence in ('u', 't') limit 1); 
	           
      when upper(object_type) in ('S', 'U', 'V', 'IT', 'ET', 'SO') and not is_temp_object then 
	id := (select oid from pg_class where lower(relname) = lower_object_name limit 1);      
	
      when upper(object_type) in ('C', 'D', 'F', 'PK', 'UQ') then 
	id := (select oid from pg_constraint where lower(conname) = lower_object_name limit 1);            
	
      when upper(object_type) in ('AF', 'FN', 'FS', 'FT', 'IF', 'P', 'PC', 'TF', 'RF', 'X') then 
	id := (select oid from pg_proc where lower(proname) = lower_object_name limit 1);      
	
      when upper(object_type) in ('TR', 'TA') then 
	id := (select oid from pg_trigger where lower(tgname) = lower_object_name limit 1);            

      -- unsupported object_type
      else id := null;
    end case;
  else 
    if not is_temp_object then id := (
				      select oid from pg_class where lower(relname) = lower_object_name
					union
				      select oid from pg_constraint where lower(conname) = lower_object_name
					union
				      select oid from pg_proc where lower(proname) = lower_object_name
					union
				      select oid from pg_trigger where lower(tgname) = lower_object_name
				      limit 1);
    else
      -- temp object without "object_type" in-argument 
      id := (select oid from pg_class where lower(relname) = lower_object_name and relpersistence in ('u', 't') limit 1);     
    end if;
  end if;  

  return id::integer;
  
end; 
]]></complex-attribute>
                        <category _I_D="a23bdcf4-d9a0-4498-a9f8-3a06accea42c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="db548636-5d1b-42f9-8dee-6263be59b216" name="openxml" function-id="16870" schema-id="16397" function-type="RET_DATASET" is-trigger-function="0" unique-function-name="openxml" is-aggregate="f" language-name="plpgsql" context="openxml" subcategories-loading="none" object-loading="extended" is-returning-set="t" ret-datatype="table" count-arguments="1" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="openxml(dochandle bigint)" arguments-datatypes="bigint,xml" function-arguments="dochandle bigint" function-identity-arguments="dochandle bigint">
                        <complex-attribute name="sql"><![CDATA[
DECLARE                       
   XmlDocument$data XML;
BEGIN
	 
    SELECT t.XmlData     
	  INTO STRICT XmlDocument$data
	  FROM aws_sqlserver_ext$openxml t
	 WHERE t.DocID = DocHandle;	  
   
   RETURN QUERY SELECT XmlDocument$data;
  
   EXCEPTION
	  WHEN SQLSTATE '42P01' OR SQLSTATE 'P0002' THEN 
	      RAISE EXCEPTION '%','Could not find prepared statement with handle '||CASE 
                                                                              WHEN DocHandle IS NULL THEN 'null'
                                                                                ELSE DocHandle::TEXT
                                                                             END;
END;
]]></complex-attribute>
                        <category _I_D="d8de4c9d-cea9-490f-b2de-349d824080b0" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f59d56b1-6df9-4f2e-8495-8e642fcdeff8" name="parse_to_date" function-id="16585" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="parse_to_date" is-aggregate="f" language-name="plpgsql" context="parse_to_date" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="date" count-arguments="2" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="parse_to_date(p_datestring text, p_culture text)" arguments-datatypes="text,text" comment="This function parses the TEXT string and translate it into a DATE value, according to specified culture (conversion mask)." function-arguments="p_datestring text, p_culture text DEFAULT ''::text" function-identity-arguments="p_datestring text, p_culture text">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_day VARCHAR;
    v_year SMALLINT;
    v_month VARCHAR;
    v_res_date DATE;
    v_hijridate DATE;
    v_culture VARCHAR;
    v_dayparts TEXT[];
    v_resmask VARCHAR;
    v_raw_year VARCHAR;
    v_left_part VARCHAR;
    v_right_part VARCHAR;
    v_resmask_fi VARCHAR;
    v_datestring VARCHAR;
    v_timestring VARCHAR;
    v_correctnum VARCHAR;
    v_weekdaynum SMALLINT;
    v_err_message VARCHAR;
    v_date_format VARCHAR;
    v_weekdaynames TEXT[];
    v_hours SMALLINT := 0;
    v_minutes SMALLINT := 0;
    v_seconds NUMERIC := 0;
    v_found BOOLEAN := TRUE;
    v_compday_regexp VARCHAR;
    v_regmatch_groups TEXT[];
    v_compmonth_regexp VARCHAR;
    v_lang_metadata_json JSONB;
    v_resmask_cnt SMALLINT := 10;
    DAYMM_REGEXP CONSTANT VARCHAR := '(\d{1,2})';
    FULLYEAR_REGEXP CONSTANT VARCHAR := '(\d{3,4})';
    SHORTYEAR_REGEXP CONSTANT VARCHAR := '(\d{1,2})';
    COMPYEAR_REGEXP CONSTANT VARCHAR := '(\d{1,4})';
    AMPM_REGEXP CONSTANT VARCHAR := '(?:[AP]M|ص|م)';
    TIMEUNIT_REGEXP CONSTANT VARCHAR := '\s*\d{1,2}\s*';
    MASKSEPONE_REGEXP CONSTANT VARCHAR := '\s*(?:/|-)?';
    MASKSEPTWO_REGEXP CONSTANT VARCHAR := '\s*(?:\s|/|-|\.|,)';
    MASKSEPTWO_FI_REGEXP CONSTANT VARCHAR := '\s*(?:\s|/|-|,)';
    MASKSEPTHREE_REGEXP CONSTANT VARCHAR := '\s*(?:/|-|\.|,)';
    TIME_MASKSEP_REGEXP CONSTANT VARCHAR := '(?:\s|\.|,)*';
    TIME_MASKSEP_FI_REGEXP CONSTANT VARCHAR := '(?:\s|,)*';
    WEEKDAYAMPM_START_REGEXP CONSTANT VARCHAR := '(^|[[:digit:][:space:]\.,])';
    WEEKDAYAMPM_END_REGEXP CONSTANT VARCHAR := '([[:digit:][:space:]\.,]|$)(?=[^/-]|$)';
    CORRECTNUM_REGEXP CONSTANT VARCHAR := '(?:([+-]\d{1,4})(?:[[:space:]\.,]|[AP]M|ص|م|$))';
    ANNO_DOMINI_REGEXP VARCHAR := '(AD|A\.D\.)';
    ANNO_DOMINI_COMPREGEXP VARCHAR := concat(WEEKDAYAMPM_START_REGEXP, ANNO_DOMINI_REGEXP, WEEKDAYAMPM_END_REGEXP);
    HHMMSSFS_PART_REGEXP CONSTANT VARCHAR :=
        concat(TIMEUNIT_REGEXP, AMPM_REGEXP, '|',
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '\:', TIME_MASKSEP_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '(?!\d)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?|',
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '\:', TIME_MASKSEP_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '\:', TIME_MASKSEP_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '(?!\d)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?|',
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '\:', TIME_MASKSEP_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '\:', TIME_MASKSEP_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\s*\d{1,2}\.\d+(?!\d)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?|',
               AMPM_REGEXP, '?');
    HHMMSSFS_PART_FI_REGEXP CONSTANT VARCHAR :=
        concat(TIMEUNIT_REGEXP, AMPM_REGEXP, '|',
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '[\:\.]', TIME_MASKSEP_FI_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '(?!\d)', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?\.?|',
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '[\:\.]', TIME_MASKSEP_FI_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '[\:\.]', TIME_MASKSEP_FI_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '(?!\d)', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?|',
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '[\:\.]', TIME_MASKSEP_FI_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '[\:\.]', TIME_MASKSEP_FI_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, '\s*\d{1,2}\.\d+(?!\d)\.?', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?|',
               AMPM_REGEXP, '?');
    v_defmask1_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        TIME_MASKSEP_REGEXP, '(?:[\.|,]+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)', TIME_MASKSEP_REGEXP, '$');
    v_defmask1_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP,
                                           '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_FI_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:', MASKSEPTWO_FI_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP,
                                           CORRECTNUM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[,]+', AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           TIME_MASKSEP_FI_REGEXP, '(?:[\.|,]+', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask2_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        FULLYEAR_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        AMPM_REGEXP, TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        TIME_MASKSEP_REGEXP, '(?:(?:[\.|,]+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?)|',
                                        CORRECTNUM_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP, '$');
    v_defmask2_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP,
                                           '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           CORRECTNUM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP,
                                           FULLYEAR_REGEXP,
                                           '(?:(?:', MASKSEPTWO_FI_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:', TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP,
                                           AMPM_REGEXP, TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           TIME_MASKSEP_FI_REGEXP, '(?:(?:[\.|,]+', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?)|',
                                           CORRECTNUM_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask3_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, ')|',
                                        '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        FULLYEAR_REGEXP,
                                        TIME_MASKSEP_REGEXP, '(', TIME_MASKSEP_REGEXP, AMPM_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask3_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           TIME_MASKSEP_FI_REGEXP, '[\./]?', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)',
                                           FULLYEAR_REGEXP,
                                           TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask4_0_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP, '\s*(', AMPM_REGEXP, ')',
                                          TIME_MASKSEP_REGEXP, '$');
    v_defmask4_1_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          '(?:\s|,)+',
                                          DAYMM_REGEXP, '\s*(', AMPM_REGEXP, ')',
                                          TIME_MASKSEP_REGEXP, '$');
    v_defmask4_2_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          '\s*[\.]+', TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP, '\s*(', AMPM_REGEXP, ')',
                                          TIME_MASKSEP_REGEXP, '$');
    v_defmask5_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        FULLYEAR_REGEXP,
                                        TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask5_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           FULLYEAR_REGEXP,
                                           TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask6_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        FULLYEAR_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '((?:(?:\s|\.|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_REGEXP, '))?', TIME_MASKSEP_REGEXP, '$');
    v_defmask6_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           FULLYEAR_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:\s*[\.])?',
                                           '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask7_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        FULLYEAR_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '((?:(?:\s|\.|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_REGEXP, '))?', TIME_MASKSEP_REGEXP, '$');
    v_defmask7_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           FULLYEAR_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask8_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:[\.|,]+', AMPM_REGEXP, ')?',
                                        TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask8_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_FI_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:[\,]+|\s*/\s*)', AMPM_REGEXP, ')?',
                                           TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask9_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(',
                                        HHMMSSFS_PART_REGEXP,
                                        ')', TIME_MASKSEP_REGEXP, '$');
    v_defmask9_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, '(',
                                           HHMMSSFS_PART_FI_REGEXP,
                                           ')', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask10_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)?', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask10_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            DAYMM_REGEXP,
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)?', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask11_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask11_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           '($comp_month$)',
                                           '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask12_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         FULLYEAR_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                         '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask12_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            FULLYEAR_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                            '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask13_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         FULLYEAR_REGEXP,
                                         TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$');
    v_defmask13_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            '($comp_month$)',
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                            FULLYEAR_REGEXP,
                                            TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask14_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)'
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)', TIME_MASKSEP_REGEXP,
                                         COMPYEAR_REGEXP,
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask14_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            '($comp_month$)'
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_FI_REGEXP,
                                            DAYMM_REGEXP,
                                            '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)', TIME_MASKSEP_FI_REGEXP,
                                            COMPYEAR_REGEXP,
                                            '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask15_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                         '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         COMPYEAR_REGEXP,
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask15_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            DAYMM_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                            '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                            COMPYEAR_REGEXP,
                                            '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask16_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)', TIME_MASKSEP_REGEXP,
                                         COMPYEAR_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                         '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask16_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            DAYMM_REGEXP,
                                            '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)', TIME_MASKSEP_REGEXP,
                                            COMPYEAR_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                            '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask17_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         FULLYEAR_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                         '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask17_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            FULLYEAR_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                            '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                            DAYMM_REGEXP,
                                            '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask18_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         FULLYEAR_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                         '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                         '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask18_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            FULLYEAR_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                            '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                            DAYMM_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                            '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask19_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         FULLYEAR_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                         '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '((?:(?:\s|\.|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_REGEXP, '))?', TIME_MASKSEP_REGEXP, '$');
    v_defmask19_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            '($comp_month$)',
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                            FULLYEAR_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                            '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                            DAYMM_REGEXP,
                                            '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    CONVERSION_LANG CONSTANT VARCHAR := '';
    DATE_FORMAT CONSTANT VARCHAR := '';
BEGIN
    v_datestring := upper(trim(p_datestring));
    v_culture := coalesce(nullif(upper(trim(p_culture)), ''), 'EN-US');

    v_dayparts := ARRAY(SELECT upper(array_to_string(regexp_matches(v_datestring, '[AP]M|ص|م', 'gi'), '')));

    IF (array_length(v_dayparts, 1) > 1) THEN
        RAISE invalid_datetime_format;
    END IF;

    BEGIN
        v_lang_metadata_json := aws_sqlserver_ext.get_lang_metadata_json(coalesce(nullif(CONVERSION_LANG, ''), p_culture));
    EXCEPTION
        WHEN OTHERS THEN
        RAISE invalid_parameter_value;
    END;

    v_compday_regexp := array_to_string(array_cat(array_cat(ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'days_names')),
                                                            ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'days_shortnames'))),
                                                  ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'days_extrashortnames'))), '|');

    v_weekdaynames := ARRAY(SELECT array_to_string(regexp_matches(v_datestring, v_compday_regexp, 'gi'), ''));

    IF (array_length(v_weekdaynames, 1) > 1) THEN
        RAISE invalid_datetime_format;
    END IF;

    IF (v_weekdaynames[1] IS NOT NULL AND
        v_datestring ~* concat(WEEKDAYAMPM_START_REGEXP, '(', v_compday_regexp, ')', WEEKDAYAMPM_END_REGEXP))
    THEN
        v_datestring := replace(v_datestring, v_weekdaynames[1], ' ');
    END IF;

    IF (v_datestring ~* ANNO_DOMINI_COMPREGEXP)
    THEN
        IF (v_culture !~ 'EN[-_]US|DA[-_]DK|SV[-_]SE|EN[-_]GB|HI[-_]IS') THEN
            RAISE invalid_datetime_format;
        END IF;

        v_datestring := regexp_replace(v_datestring,
                                       ANNO_DOMINI_COMPREGEXP,
                                       regexp_replace(array_to_string(regexp_matches(v_datestring, ANNO_DOMINI_COMPREGEXP, 'gi'), ''),
                                                      ANNO_DOMINI_REGEXP, ' ', 'gi'),
                                       'gi');
    END IF;

    v_date_format := coalesce(nullif(upper(trim(DATE_FORMAT)), ''), v_lang_metadata_json ->> 'date_format');

    v_compmonth_regexp :=
        array_to_string(array_cat(array_cat(ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'months_shortnames')),
                                            ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'months_names'))),
                                  array_cat(ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'months_extrashortnames')),
                                            ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'months_extranames')))
                                 ), '|');

    IF ((v_datestring ~* v_defmask1_regexp AND v_culture <> 'FI') OR
        (v_datestring ~* v_defmask1_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_datestring ~ concat(CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                  CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP,
                                  AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}|',
                                  '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                  CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
            v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV')
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_datestring, CASE v_culture
                                                             WHEN 'FI' THEN v_defmask1_fi_regexp
                                                             ELSE v_defmask1_regexp
                                                          END, 'gi');
        v_timestring := v_regmatch_groups[2];
        v_correctnum := coalesce(v_regmatch_groups[1], v_regmatch_groups[3],
                                 v_regmatch_groups[5], v_regmatch_groups[6]);

        IF (v_date_format = 'DMY' OR
            v_culture IN ('SV-SE', 'SV_SE', 'LV-LV', 'LV_LV'))
        THEN
            v_day := v_regmatch_groups[4];
            v_month := v_regmatch_groups[7];
        ELSE
            v_day := v_regmatch_groups[7];
            v_month := v_regmatch_groups[4];
        END IF;

        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA'))
        THEN
            IF (v_day::SMALLINT > 30 OR
                v_month::SMALLINT > 12) THEN
                RAISE invalid_datetime_format;
            END IF;

            v_raw_year := to_char(aws_sqlserver_ext.conv_greg_to_hijri(current_date + 1), 'YYYY');
            v_hijridate := aws_sqlserver_ext.conv_hijri_to_greg(v_day, v_month, v_raw_year) - 1;

            v_day := to_char(v_hijridate, 'DD');
            v_month := to_char(v_hijridate, 'MM');
            v_year := to_char(v_hijridate, 'YYYY')::SMALLINT;
        ELSE
            v_year := to_char(current_date, 'YYYY')::SMALLINT;
        END IF;

    ELSIF ((v_datestring ~* v_defmask6_regexp AND v_culture <> 'FI') OR
           (v_datestring ~* v_defmask6_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA') OR
            (v_datestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{3,4}',
                                   '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                   '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP, '\d{1,2}|',
                                   '\d{3,4}', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP,
                                   TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}\s*(?:\.)+|',
                                   '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
             v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV'))
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_datestring, CASE v_culture
                                                             WHEN 'FI' THEN v_defmask6_fi_regexp
                                                             ELSE v_defmask6_regexp
                                                          END, 'gi');
        v_timestring := concat(v_regmatch_groups[1], v_regmatch_groups[5]);
        v_day := v_regmatch_groups[4];
        v_month := v_regmatch_groups[3];
        v_year := CASE
                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_regmatch_groups[2]::SMALLINT - 543
                     ELSE v_regmatch_groups[2]::SMALLINT
                  END;

    ELSIF ((v_datestring ~* v_defmask2_regexp AND v_culture <> 'FI') OR
           (v_datestring ~* v_defmask2_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA') OR
            (v_datestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{3,4}',
                                   '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                   '(?:', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                   AMPM_REGEXP, TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?))', TIME_MASKSEP_REGEXP, '\d{1,2}|',
                                   '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
             v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV'))
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_datestring, CASE v_culture
                                                             WHEN 'FI' THEN v_defmask2_fi_regexp
                                                             ELSE v_defmask2_regexp
                                                          END, 'gi');
        v_timestring := v_regmatch_groups[2];
        v_correctnum := coalesce(v_regmatch_groups[1], v_regmatch_groups[3], v_regmatch_groups[5],
                                 v_regmatch_groups[6], v_regmatch_groups[8], v_regmatch_groups[9]);
        v_day := '01';
        v_month := v_regmatch_groups[7];
        v_year := CASE
                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_regmatch_groups[4]::SMALLINT - 543
                     ELSE v_regmatch_groups[4]::SMALLINT
                  END;

    ELSIF (v_datestring ~* v_defmask4_1_regexp OR
           (v_datestring ~* v_defmask4_2_regexp AND v_culture !~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV') OR
           (v_datestring ~* v_defmask9_regexp AND v_culture <> 'FI') OR
           (v_datestring ~* v_defmask9_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_datestring ~ concat('\d+\s*\.?(?:,+|,*', AMPM_REGEXP, ')', TIME_MASKSEP_FI_REGEXP, '\.+', TIME_MASKSEP_REGEXP, '$|',
                                  '\d+\s*\.', TIME_MASKSEP_FI_REGEXP, '\.', TIME_MASKSEP_FI_REGEXP, '$') AND
            v_culture = 'FI')
        THEN
            RAISE invalid_datetime_format;
        END IF;

        IF (v_datestring ~* v_defmask4_0_regexp) THEN
            v_timestring := (regexp_matches(v_datestring, v_defmask4_0_regexp, 'gi'))[1];
        ELSE
            v_timestring := v_datestring;
        END IF;

        v_res_date := current_date;
        v_day := to_char(v_res_date, 'DD');
        v_month := to_char(v_res_date, 'MM');
        v_year := to_char(v_res_date, 'YYYY')::SMALLINT;

    ELSIF ((v_datestring ~* v_defmask3_regexp AND v_culture <> 'FI') OR
           (v_datestring ~* v_defmask3_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA') OR
            (v_datestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?',
                                   TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP, '|',
                                   '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
             v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV'))
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_datestring, CASE v_culture
                                                             WHEN 'FI' THEN v_defmask3_fi_regexp
                                                             ELSE v_defmask3_regexp
                                                          END, 'gi');
        v_timestring := v_regmatch_groups[1];
        v_day := '01';
        v_month := v_regmatch_groups[2];
        v_year := CASE
                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_regmatch_groups[3]::SMALLINT - 543
                     ELSE v_regmatch_groups[3]::SMALLINT
                  END;

    ELSIF ((v_datestring ~* v_defmask5_regexp AND v_culture <> 'FI') OR
           (v_datestring ~* v_defmask5_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA') OR
            (v_datestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP,
                                   TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP,
                                   TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{3,4}', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$|',
                                   '\d{1,2}', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{3,4}\s*(?:\.)+|',
                                   '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
             v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV'))
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_datestring, v_defmask5_regexp, 'gi');
        v_timestring := concat(v_regmatch_groups[1], v_regmatch_groups[5]);
        v_year := CASE
                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_regmatch_groups[4]::SMALLINT - 543
                     ELSE v_regmatch_groups[4]::SMALLINT
                  END;

        IF (v_date_format = 'DMY' OR
            v_culture IN ('LV-LV', 'LV_LV'))
        THEN
            v_day := v_regmatch_groups[2];
            v_month := v_regmatch_groups[3];
        ELSE
            v_day := v_regmatch_groups[3];
            v_month := v_regmatch_groups[2];
        END IF;

    ELSIF ((v_datestring ~* v_defmask7_regexp AND v_culture <> 'FI') OR
           (v_datestring ~* v_defmask7_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA') OR
            (v_datestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}',
                                   MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{3,4}|',
                                   '\d{3,4}', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}\s*(?:\.)+|',
                                   '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
             v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV'))
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_datestring, CASE v_culture
                                                             WHEN 'FI' THEN v_defmask7_fi_regexp
                                                             ELSE v_defmask7_regexp
                                                          END, 'gi');
        v_timestring := concat(v_regmatch_groups[1], v_regmatch_groups[5]);
        v_day := v_regmatch_groups[4];
        v_month := v_regmatch_groups[2];
        v_year := CASE
                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_regmatch_groups[3]::SMALLINT - 543
                     ELSE v_regmatch_groups[3]::SMALLINT
                  END;

    ELSIF ((v_datestring ~* v_defmask8_regexp AND v_culture <> 'FI') OR
           (v_datestring ~* v_defmask8_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_datestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}',
                                  MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP,
                                  TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}|',
                                  '\d{1,2}', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP,
                                  TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}\s*(?:\.)+|',
                                  '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
            v_culture ~ 'FI|DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV')
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_datestring, CASE v_culture
                                                             WHEN 'FI' THEN v_defmask8_fi_regexp
                                                             ELSE v_defmask8_regexp
                                                          END, 'gi');
        v_timestring := concat(v_regmatch_groups[1], v_regmatch_groups[5]);

        IF (v_date_format = 'DMY' OR
            v_culture IN ('LV-LV', 'LV_LV'))
        THEN
            v_day := v_regmatch_groups[2];
            v_month := v_regmatch_groups[3];
            v_raw_year := v_regmatch_groups[4];
        ELSIF (v_date_format = 'YMD')
        THEN
            v_day := v_regmatch_groups[4];
            v_month := v_regmatch_groups[3];
            v_raw_year := v_regmatch_groups[2];
        ELSE
            v_day := v_regmatch_groups[3];
            v_month := v_regmatch_groups[2];
            v_raw_year := v_regmatch_groups[4];
        END IF;

        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA'))
        THEN
            IF (v_day::SMALLINT > 30 OR
                v_month::SMALLINT > 12) THEN
                RAISE invalid_datetime_format;
            END IF;

            v_raw_year := aws_sqlserver_ext.get_full_year(v_raw_year, '14');
            v_hijridate := aws_sqlserver_ext.conv_hijri_to_greg(v_day, v_month, v_raw_year) - 1;

            v_day := to_char(v_hijridate, 'DD');
            v_month := to_char(v_hijridate, 'MM');
            v_year := to_char(v_hijridate, 'YYYY')::SMALLINT;

        ELSIF (v_culture IN ('TH-TH', 'TH_TH')) THEN
            v_year := aws_sqlserver_ext.get_full_year(v_raw_year)::SMALLINT - 43;
        ELSE
            v_year := aws_sqlserver_ext.get_full_year(v_raw_year, '', 29)::SMALLINT;
        END IF;
    ELSE
        v_found := FALSE;
    END IF;

    WHILE (NOT v_found AND v_resmask_cnt < 20)
    LOOP
        v_resmask := replace(CASE v_resmask_cnt
                                WHEN 10 THEN v_defmask10_regexp
                                WHEN 11 THEN v_defmask11_regexp
                                WHEN 12 THEN v_defmask12_regexp
                                WHEN 13 THEN v_defmask13_regexp
                                WHEN 14 THEN v_defmask14_regexp
                                WHEN 15 THEN v_defmask15_regexp
                                WHEN 16 THEN v_defmask16_regexp
                                WHEN 17 THEN v_defmask17_regexp
                                WHEN 18 THEN v_defmask18_regexp
                                WHEN 19 THEN v_defmask19_regexp
                             END,
                             '$comp_month$', v_compmonth_regexp);

        v_resmask_fi := replace(CASE v_resmask_cnt
                                   WHEN 10 THEN v_defmask10_fi_regexp
                                   WHEN 11 THEN v_defmask11_fi_regexp
                                   WHEN 12 THEN v_defmask12_fi_regexp
                                   WHEN 13 THEN v_defmask13_fi_regexp
                                   WHEN 14 THEN v_defmask14_fi_regexp
                                   WHEN 15 THEN v_defmask15_fi_regexp
                                   WHEN 16 THEN v_defmask16_fi_regexp
                                   WHEN 17 THEN v_defmask17_fi_regexp
                                   WHEN 18 THEN v_defmask18_fi_regexp
                                   WHEN 19 THEN v_defmask19_fi_regexp
                                END,
                                '$comp_month$', v_compmonth_regexp);

        IF ((v_datestring ~* v_resmask AND v_culture <> 'FI') OR
            (v_datestring ~* v_resmask_fi AND v_culture = 'FI'))
        THEN
            v_found := TRUE;
            v_regmatch_groups := regexp_matches(v_datestring, CASE v_culture
                                                                 WHEN 'FI' THEN v_resmask_fi
                                                                 ELSE v_resmask
                                                              END, 'gi');
            v_timestring := CASE
                               WHEN v_resmask_cnt IN (10, 11, 12, 13) THEN concat(v_regmatch_groups[1], v_regmatch_groups[4])
                               ELSE concat(v_regmatch_groups[1], v_regmatch_groups[5])
                            END;

            IF (v_resmask_cnt = 10)
            THEN
                IF (v_regmatch_groups[3] = 'MAR' AND
                    v_culture IN ('IT-IT', 'IT_IT'))
                THEN
                    RAISE invalid_datetime_format;
                END IF;

                IF (v_date_format = 'YMD' AND v_culture NOT IN ('SV-SE', 'SV_SE', 'LV-LV', 'LV_LV'))
                THEN
                    v_day := '01';
                    v_year := aws_sqlserver_ext.get_full_year(v_regmatch_groups[2], '', 29)::SMALLINT;
                ELSE
                    v_day := v_regmatch_groups[2];
                    v_year := to_char(current_date, 'YYYY')::SMALLINT;
                END IF;

                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[3], v_lang_metadata_json);
                v_raw_year := to_char(aws_sqlserver_ext.conv_greg_to_hijri(current_date + 1), 'YYYY');

            ELSIF (v_resmask_cnt = 11)
            THEN
                IF (v_date_format IN ('YMD', 'MDY') AND v_culture NOT IN ('SV-SE', 'SV_SE'))
                THEN
                    v_day := v_regmatch_groups[3];
                    v_year := to_char(current_date, 'YYYY')::SMALLINT;
                ELSE
                    v_day := '01';
                    v_year := CASE
                                 WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_regmatch_groups[3])::SMALLINT - 43
                                 ELSE aws_sqlserver_ext.get_full_year(v_regmatch_groups[3], '', 29)::SMALLINT
                              END;
                END IF;

                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
                v_raw_year := aws_sqlserver_ext.get_full_year(substring(v_year::TEXT, 3, 2), '14');

            ELSIF (v_resmask_cnt = 12)
            THEN
                v_day := '01';
                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[3], v_lang_metadata_json);
                v_raw_year := v_regmatch_groups[2];

            ELSIF (v_resmask_cnt = 13)
            THEN
                v_day := '01';
                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
                v_raw_year := v_regmatch_groups[3];

            ELSIF (v_resmask_cnt IN (14, 15, 16))
            THEN
                IF (v_resmask_cnt = 14)
                THEN
                    v_left_part := v_regmatch_groups[4];
                    v_right_part := v_regmatch_groups[3];
                    v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
                ELSIF (v_resmask_cnt = 15)
                THEN
                    v_left_part := v_regmatch_groups[4];
                    v_right_part := v_regmatch_groups[2];
                    v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[3], v_lang_metadata_json);
                ELSE
                    v_left_part := v_regmatch_groups[3];
                    v_right_part := v_regmatch_groups[2];
                    v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[4], v_lang_metadata_json);
                END IF;

                IF (char_length(v_left_part) <= 2)
                THEN
                    IF (v_date_format = 'YMD' AND v_culture NOT IN ('LV-LV', 'LV_LV'))
                    THEN
                        v_day := v_left_part;
                        v_raw_year := aws_sqlserver_ext.get_full_year(v_right_part, '14');
                        v_year := CASE
                                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_right_part)::SMALLINT - 43
                                     ELSE aws_sqlserver_ext.get_full_year(v_right_part, '', 29)::SMALLINT
                                  END;
                        BEGIN
                            v_res_date := make_date(v_year, v_month::SMALLINT, v_day::SMALLINT);
                        EXCEPTION
                        WHEN OTHERS THEN
                            v_day := v_right_part;
                            v_raw_year := aws_sqlserver_ext.get_full_year(v_left_part, '14');
                            v_year := CASE
                                         WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_left_part)::SMALLINT - 43
                                         ELSE aws_sqlserver_ext.get_full_year(v_left_part, '', 29)::SMALLINT
                                      END;
                        END;
                    END IF;

                    IF (v_date_format IN ('MDY', 'DMY') OR v_culture IN ('LV-LV', 'LV_LV'))
                    THEN
                        v_day := v_right_part;
                        v_raw_year := aws_sqlserver_ext.get_full_year(v_left_part, '14');
                        v_year := CASE
                                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_left_part)::SMALLINT - 43
                                     ELSE aws_sqlserver_ext.get_full_year(v_left_part, '', 29)::SMALLINT
                                  END;
                        BEGIN
                            v_res_date := make_date(v_year, v_month::SMALLINT, v_day::SMALLINT);
                        EXCEPTION
                        WHEN OTHERS THEN
                            v_day := v_left_part;
                            v_raw_year := aws_sqlserver_ext.get_full_year(v_right_part, '14');
                            v_year := CASE
                                         WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_right_part)::SMALLINT - 43
                                         ELSE aws_sqlserver_ext.get_full_year(v_right_part, '', 29)::SMALLINT
                                      END;
                        END;
                    END IF;
                ELSE
                    v_day := v_right_part;
                    v_raw_year := v_left_part;
	            v_year := CASE
                                 WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_left_part::SMALLINT - 543
                                 ELSE v_left_part::SMALLINT
                              END;
                END IF;

            ELSIF (v_resmask_cnt = 17)
            THEN
                v_day := v_regmatch_groups[4];
                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[3], v_lang_metadata_json);
                v_raw_year := v_regmatch_groups[2];

            ELSIF (v_resmask_cnt = 18)
            THEN
                v_day := v_regmatch_groups[3];
                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[4], v_lang_metadata_json);
                v_raw_year := v_regmatch_groups[2];

            ELSIF (v_resmask_cnt = 19)
            THEN
                v_day := v_regmatch_groups[4];
                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
                v_raw_year := v_regmatch_groups[3];
            END IF;

            IF (v_resmask_cnt NOT IN (10, 11, 14, 15, 16))
            THEN
                v_year := CASE
                             WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_raw_year::SMALLINT - 543
                             ELSE v_raw_year::SMALLINT
                          END;
            END IF;

            IF (v_culture IN ('AR', 'AR-SA', 'AR_SA'))
            THEN
                IF (v_day::SMALLINT > 30 OR
                    (v_resmask_cnt NOT IN (10, 11, 14, 15, 16) AND v_year NOT BETWEEN 1318 AND 1501) OR
                    (v_resmask_cnt IN (14, 15, 16) AND v_raw_year::SMALLINT NOT BETWEEN 1318 AND 1501))
                THEN
                    RAISE invalid_datetime_format;
                END IF;

                v_hijridate := aws_sqlserver_ext.conv_hijri_to_greg(v_day, v_month, v_raw_year) - 1;

                v_day := to_char(v_hijridate, 'DD');
                v_month := to_char(v_hijridate, 'MM');
                v_year := to_char(v_hijridate, 'YYYY')::SMALLINT;
            END IF;
        END IF;

        v_resmask_cnt := v_resmask_cnt + 1;
    END LOOP;

    IF (NOT v_found) THEN
        RAISE invalid_datetime_format;
    END IF;

    IF (char_length(v_timestring) > 0 AND v_timestring NOT IN ('AM', 'ص', 'PM', 'م'))
    THEN
        IF (v_culture = 'FI') THEN
            v_timestring := translate(v_timestring, '.,', ': ');

            IF (char_length(split_part(v_timestring, ':', 4)) > 0) THEN
                v_timestring := regexp_replace(v_timestring, ':(?=\s*\d+\s*:?\s*(?:[AP]M|ص|م)?\s*$)', '.');
            END IF;
        END IF;

        v_timestring := replace(regexp_replace(v_timestring, '\.?[AP]M|ص|م|\s|\,|\.\D|[\.|:]$', '', 'gi'), ':.', ':');
        BEGIN
            v_hours := coalesce(split_part(v_timestring, ':', 1)::SMALLINT, 0);

            IF ((v_dayparts[1] IN ('AM', 'ص') AND v_hours NOT BETWEEN 0 AND 12) OR
                (v_dayparts[1] IN ('PM', 'م') AND v_hours NOT BETWEEN 1 AND 23))
            THEN
                RAISE invalid_datetime_format;
            END IF;

            v_minutes := coalesce(nullif(split_part(v_timestring, ':', 2), '')::SMALLINT, 0);
            v_seconds := coalesce(nullif(split_part(v_timestring, ':', 3), '')::NUMERIC, 0);
        EXCEPTION
            WHEN OTHERS THEN
            RAISE invalid_datetime_format;
        END;
    ELSIF (v_dayparts[1] IN ('PM', 'م'))
    THEN
        v_hours := 12;
    END IF;

    v_res_date := make_timestamp(v_year, v_month::SMALLINT, v_day::SMALLINT,
                                 v_hours, v_minutes, v_seconds);

    IF (v_weekdaynames[1] IS NOT NULL) THEN
        v_weekdaynum := aws_sqlserver_ext.get_weekdaynum_by_name(v_weekdaynames[1], v_lang_metadata_json);

        IF (CASE date_part('dow', v_res_date)::SMALLINT
               WHEN 0 THEN 7
               ELSE date_part('dow', v_res_date)::SMALLINT
            END <> v_weekdaynum)
        THEN
            RAISE invalid_datetime_format;
        END IF;
    END IF;

    RETURN v_res_date;
EXCEPTION
    WHEN invalid_datetime_format OR datetime_field_overflow THEN
        RAISE USING MESSAGE := format('Error converting string value ''%s'' into data type DATE using culture ''%s''.',
                                      p_datestring, p_culture),
                    DETAIL := 'Incorrect using of pair of input parameters values during conversion process.',
                    HINT := 'Check the input parameters values, correct them if needed, and try again.';

    WHEN invalid_parameter_value THEN
        RAISE USING MESSAGE := CASE char_length(coalesce(CONVERSION_LANG, ''))
                                  WHEN 0 THEN format('The culture parameter ''%s'' provided in the function call is not supported.',
                                                     p_culture)
                                  ELSE format('Invalid CONVERSION_LANG constant value - ''%s''. Allowed values are: ''English'', ''Deutsch'', etc.',
                                              CONVERSION_LANG)
                               END,
                    DETAIL := 'Passed incorrect value for "p_culture" parameter or compiled incorrect CONVERSION_LANG constant value in function''s body.',
                    HINT := 'Check "p_culture" input parameter value, correct it if needed, and try again. Also check CONVERSION_LANG constant value.';

    WHEN invalid_text_representation THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
        v_err_message := substring(lower(v_err_message), 'integer\:\s\"(.*)\"');

        RAISE USING MESSAGE := format('Error while trying to convert "%s" value to SMALLINT data type.',
                                      v_err_message),
                    DETAIL := 'Supplied value contains illegal characters.',
                    HINT := 'Correct supplied value, remove all illegal characters.';
END;
]]></complex-attribute>
                        <category _I_D="a4f7d0b2-a5af-4c8d-8465-31b0eea1e71c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="9e814332-4dda-4d54-a8ce-a049b8f05120" name="parse_to_datetime" function-id="16587" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="parse_to_datetime" is-aggregate="f" language-name="plpgsql" context="parse_to_datetime" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="timestamp" count-arguments="3" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="parse_to_datetime(p_datatype text, p_datetimestring text, p_culture text)" arguments-datatypes="text,text,text" comment="This function parses the TEXT string and converts it into a DATETIME value, according to specified culture (conversion mask)." function-arguments="p_datatype text, p_datetimestring text, p_culture text DEFAULT ''::text" function-identity-arguments="p_datatype text, p_datetimestring text, p_culture text">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_day VARCHAR;
    v_year SMALLINT;
    v_month VARCHAR;
    v_res_date DATE;
    v_scale SMALLINT;
    v_hijridate DATE;
    v_culture VARCHAR;
    v_dayparts TEXT[];
    v_resmask VARCHAR;
    v_datatype VARCHAR;
    v_raw_year VARCHAR;
    v_left_part VARCHAR;
    v_right_part VARCHAR;
    v_resmask_fi VARCHAR;
    v_timestring VARCHAR;
    v_correctnum VARCHAR;
    v_weekdaynum SMALLINT;
    v_err_message VARCHAR;
    v_date_format VARCHAR;
    v_weekdaynames TEXT[];
    v_hours SMALLINT := 0;
    v_minutes SMALLINT := 0;
    v_res_datatype VARCHAR;
    v_error_message VARCHAR;
    v_found BOOLEAN := TRUE;
    v_compday_regexp VARCHAR;
    v_regmatch_groups TEXT[];
    v_datatype_groups TEXT[];
    v_datetimestring VARCHAR;
    v_seconds VARCHAR := '0';
    v_fseconds VARCHAR := '0';
    v_compmonth_regexp VARCHAR;
    v_lang_metadata_json JSONB;
    v_resmask_cnt SMALLINT := 10;
    v_res_datetime TIMESTAMP(6) WITHOUT TIME ZONE;
    DAYMM_REGEXP CONSTANT VARCHAR := '(\d{1,2})';
    FULLYEAR_REGEXP CONSTANT VARCHAR := '(\d{3,4})';
    SHORTYEAR_REGEXP CONSTANT VARCHAR := '(\d{1,2})';
    COMPYEAR_REGEXP CONSTANT VARCHAR := '(\d{1,4})';
    AMPM_REGEXP CONSTANT VARCHAR := '(?:[AP]M|ص|م)';
    TIMEUNIT_REGEXP CONSTANT VARCHAR := '\s*\d{1,2}\s*';
    MASKSEPONE_REGEXP CONSTANT VARCHAR := '\s*(?:/|-)?';
    MASKSEPTWO_REGEXP CONSTANT VARCHAR := '\s*(?:\s|/|-|\.|,)';
    MASKSEPTWO_FI_REGEXP CONSTANT VARCHAR := '\s*(?:\s|/|-|,)';
    MASKSEPTHREE_REGEXP CONSTANT VARCHAR := '\s*(?:/|-|\.|,)';
    TIME_MASKSEP_REGEXP CONSTANT VARCHAR := '(?:\s|\.|,)*';
    TIME_MASKSEP_FI_REGEXP CONSTANT VARCHAR := '(?:\s|,)*';
    WEEKDAYAMPM_START_REGEXP CONSTANT VARCHAR := '(^|[[:digit:][:space:]\.,])';
    WEEKDAYAMPM_END_REGEXP CONSTANT VARCHAR := '([[:digit:][:space:]\.,]|$)(?=[^/-]|$)';
    CORRECTNUM_REGEXP CONSTANT VARCHAR := '(?:([+-]\d{1,4})(?:[[:space:]\.,]|[AP]M|ص|م|$))';
    DATATYPE_REGEXP CONSTANT VARCHAR := '^(DATETIME|SMALLDATETIME|DATETIME2)\s*(?:\()?\s*((?:-)?\d+)?\s*(?:\))?$';
    ANNO_DOMINI_REGEXP VARCHAR := '(AD|A\.D\.)';
    ANNO_DOMINI_COMPREGEXP VARCHAR := concat(WEEKDAYAMPM_START_REGEXP, ANNO_DOMINI_REGEXP, WEEKDAYAMPM_END_REGEXP);
    HHMMSSFS_PART_REGEXP CONSTANT VARCHAR :=
        concat(TIMEUNIT_REGEXP, AMPM_REGEXP, '|',
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '\:', TIME_MASKSEP_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '(?!\d)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?|',
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '\:', TIME_MASKSEP_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '\:', TIME_MASKSEP_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '(?!\d)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?|',
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '\:', TIME_MASKSEP_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '\:', TIME_MASKSEP_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\s*\d{1,2}\.\d+(?!\d)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?|',
               AMPM_REGEXP, '?');
    HHMMSSFS_PART_FI_REGEXP CONSTANT VARCHAR :=
        concat(TIMEUNIT_REGEXP, AMPM_REGEXP, '|',
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '[\:\.]', TIME_MASKSEP_FI_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '(?!\d)', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?\.?|',
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '[\:\.]', TIME_MASKSEP_FI_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '[\:\.]', TIME_MASKSEP_FI_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '(?!\d)', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?|',
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '[\:\.]', TIME_MASKSEP_FI_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '[\:\.]', TIME_MASKSEP_FI_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, '\s*\d{1,2}\.\d+(?!\d)\.?', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?|',
               AMPM_REGEXP, '?');
    v_defmask1_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        TIME_MASKSEP_REGEXP, '(?:[\.|,]+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)', TIME_MASKSEP_REGEXP, '$');
    v_defmask1_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP,
                                           '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_FI_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:', MASKSEPTWO_FI_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP,
                                           CORRECTNUM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[,]+', AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           TIME_MASKSEP_FI_REGEXP, '(?:[\.|,]+', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask2_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        FULLYEAR_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        AMPM_REGEXP, TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        TIME_MASKSEP_REGEXP, '(?:(?:[\.|,]+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?)|',
                                        CORRECTNUM_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP, '$');
    v_defmask2_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP,
                                           '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           CORRECTNUM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP,
                                           FULLYEAR_REGEXP,
                                           '(?:(?:', MASKSEPTWO_FI_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:', TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP,
                                           AMPM_REGEXP, TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           TIME_MASKSEP_FI_REGEXP, '(?:(?:[\.|,]+', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?)|',
                                           CORRECTNUM_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask3_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, ')|',
                                        '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        FULLYEAR_REGEXP,
                                        TIME_MASKSEP_REGEXP, '(', TIME_MASKSEP_REGEXP, AMPM_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask3_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           TIME_MASKSEP_FI_REGEXP, '[\./]?', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)',
                                           FULLYEAR_REGEXP,
                                           TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask4_0_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP, '\s*(', AMPM_REGEXP, ')',
                                          TIME_MASKSEP_REGEXP, '$');
    v_defmask4_1_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          '(?:\s|,)+',
                                          DAYMM_REGEXP, '\s*(', AMPM_REGEXP, ')',
                                          TIME_MASKSEP_REGEXP, '$');
    v_defmask4_2_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          '\s*[\.]+', TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP, '\s*(', AMPM_REGEXP, ')',
                                          TIME_MASKSEP_REGEXP, '$');
    v_defmask5_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        FULLYEAR_REGEXP,
                                        TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask5_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           FULLYEAR_REGEXP,
                                           TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask6_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        FULLYEAR_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '((?:(?:\s|\.|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_REGEXP, '))?', TIME_MASKSEP_REGEXP, '$');
    v_defmask6_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           FULLYEAR_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:\s*[\.])?',
                                           '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask7_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        FULLYEAR_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '((?:(?:\s|\.|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_REGEXP, '))?', TIME_MASKSEP_REGEXP, '$');
    v_defmask7_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           FULLYEAR_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask8_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:[\.|,]+', AMPM_REGEXP, ')?',
                                        TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask8_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_FI_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:[\,]+|\s*/\s*)', AMPM_REGEXP, ')?',
                                           TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask9_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(',
                                        HHMMSSFS_PART_REGEXP,
                                        ')', TIME_MASKSEP_REGEXP, '$');
    v_defmask9_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, '(',
                                           HHMMSSFS_PART_FI_REGEXP,
                                           ')', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask10_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)?', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask10_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            DAYMM_REGEXP,
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)?', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask11_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask11_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           '($comp_month$)',
                                           '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask12_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         FULLYEAR_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                         '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask12_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            FULLYEAR_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                            '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask13_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         FULLYEAR_REGEXP,
                                         TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$');
    v_defmask13_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            '($comp_month$)',
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                            FULLYEAR_REGEXP,
                                            TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask14_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)'
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)', TIME_MASKSEP_REGEXP,
                                         COMPYEAR_REGEXP,
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask14_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            '($comp_month$)'
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_FI_REGEXP,
                                            DAYMM_REGEXP,
                                            '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)', TIME_MASKSEP_FI_REGEXP,
                                            COMPYEAR_REGEXP,
                                            '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask15_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                         '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         COMPYEAR_REGEXP,
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask15_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            DAYMM_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                            '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                            COMPYEAR_REGEXP,
                                            '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask16_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)', TIME_MASKSEP_REGEXP,
                                         COMPYEAR_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                         '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask16_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            DAYMM_REGEXP,
                                            '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)', TIME_MASKSEP_REGEXP,
                                            COMPYEAR_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                            '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask17_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         FULLYEAR_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                         '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask17_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            FULLYEAR_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                            '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                            DAYMM_REGEXP,
                                            '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask18_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         FULLYEAR_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                         '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                         '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask18_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            FULLYEAR_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                            '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                            DAYMM_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                            '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask19_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         FULLYEAR_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                         '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '((?:(?:\s|\.|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_REGEXP, '))?', TIME_MASKSEP_REGEXP, '$');
    v_defmask19_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            '($comp_month$)',
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                            FULLYEAR_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                            '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                            DAYMM_REGEXP,
                                            '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    CONVERSION_LANG CONSTANT VARCHAR := '';
    DATE_FORMAT CONSTANT VARCHAR := '';
BEGIN
    v_datatype := trim(p_datatype);
    v_datetimestring := upper(trim(p_datetimestring));
    v_culture := coalesce(nullif(upper(trim(p_culture)), ''), 'EN-US');

    v_datatype_groups := regexp_matches(v_datatype, DATATYPE_REGEXP, 'gi');

    v_res_datatype := upper(v_datatype_groups[1]);
    v_scale := v_datatype_groups[2]::SMALLINT;

    IF (v_res_datatype IS NULL) THEN
        RAISE datatype_mismatch;
    ELSIF (v_res_datatype <> 'DATETIME2' AND v_scale IS NOT NULL)
    THEN
        RAISE invalid_indicator_parameter_value;
    ELSIF (coalesce(v_scale, 0) NOT BETWEEN 0 AND 7)
    THEN
        RAISE interval_field_overflow;
    ELSIF (v_scale IS NULL) THEN
        v_scale := 7;
    END IF;

    v_dayparts := ARRAY(SELECT upper(array_to_string(regexp_matches(v_datetimestring, '[AP]M|ص|م', 'gi'), '')));

    IF (array_length(v_dayparts, 1) > 1) THEN
        RAISE invalid_datetime_format;
    END IF;

    BEGIN
        v_lang_metadata_json := aws_sqlserver_ext.get_lang_metadata_json(coalesce(nullif(CONVERSION_LANG, ''), p_culture));
    EXCEPTION
        WHEN OTHERS THEN
        RAISE invalid_parameter_value;
    END;

    v_compday_regexp := array_to_string(array_cat(array_cat(ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'days_names')),
                                                            ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'days_shortnames'))),
                                                  ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'days_extrashortnames'))), '|');

    v_weekdaynames := ARRAY(SELECT array_to_string(regexp_matches(v_datetimestring, v_compday_regexp, 'gi'), ''));

    IF (array_length(v_weekdaynames, 1) > 1) THEN
        RAISE invalid_datetime_format;
    END IF;

    IF (v_weekdaynames[1] IS NOT NULL AND
        v_datetimestring ~* concat(WEEKDAYAMPM_START_REGEXP, '(', v_compday_regexp, ')', WEEKDAYAMPM_END_REGEXP))
    THEN
        v_datetimestring := replace(v_datetimestring, v_weekdaynames[1], ' ');
    END IF;

    IF (v_datetimestring ~* ANNO_DOMINI_COMPREGEXP)
    THEN
        IF (v_culture !~ 'EN[-_]US|DA[-_]DK|SV[-_]SE|EN[-_]GB|HI[-_]IS') THEN
            RAISE invalid_datetime_format;
        END IF;

        v_datetimestring := regexp_replace(v_datetimestring,
                                           ANNO_DOMINI_COMPREGEXP,
                                           regexp_replace(array_to_string(regexp_matches(v_datetimestring, ANNO_DOMINI_COMPREGEXP, 'gi'), ''),
                                                          ANNO_DOMINI_REGEXP, ' ', 'gi'),
                                           'gi');
    END IF;

    v_date_format := coalesce(nullif(upper(trim(DATE_FORMAT)), ''), v_lang_metadata_json ->> 'date_format');

    v_compmonth_regexp :=
        array_to_string(array_cat(array_cat(ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'months_shortnames')),
                                            ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'months_names'))),
                                  array_cat(ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'months_extrashortnames')),
                                            ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'months_extranames')))
                                 ), '|');

    IF ((v_datetimestring ~* v_defmask1_regexp AND v_culture <> 'FI') OR
        (v_datetimestring ~* v_defmask1_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_datetimestring ~ concat(CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                      CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP,
                                      AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}|',
                                      '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                      CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
            v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV')
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_datetimestring, CASE v_culture
                                                                 WHEN 'FI' THEN v_defmask1_fi_regexp
                                                                 ELSE v_defmask1_regexp
                                                              END, 'gi');
        v_timestring := v_regmatch_groups[2];
        v_correctnum := coalesce(v_regmatch_groups[1], v_regmatch_groups[3],
                                 v_regmatch_groups[5], v_regmatch_groups[6]);

        IF (v_date_format = 'DMY' OR
            v_culture IN ('SV-SE', 'SV_SE', 'LV-LV', 'LV_LV'))
        THEN
            v_day := v_regmatch_groups[4];
            v_month := v_regmatch_groups[7];
        ELSE
            v_day := v_regmatch_groups[7];
            v_month := v_regmatch_groups[4];
        END IF;

        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA'))
        THEN
            IF (v_day::SMALLINT > 30 OR
                v_month::SMALLINT > 12) THEN
                RAISE invalid_datetime_format;
            END IF;

            v_raw_year := to_char(aws_sqlserver_ext.conv_greg_to_hijri(current_date + 1), 'YYYY');
            v_hijridate := aws_sqlserver_ext.conv_hijri_to_greg(v_day, v_month, v_raw_year) - 1;

            v_day := to_char(v_hijridate, 'DD');
            v_month := to_char(v_hijridate, 'MM');
            v_year := to_char(v_hijridate, 'YYYY')::SMALLINT;
        ELSE
            v_year := to_char(current_date, 'YYYY')::SMALLINT;
        END IF;

    ELSIF ((v_datetimestring ~* v_defmask6_regexp AND v_culture <> 'FI') OR
           (v_datetimestring ~* v_defmask6_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA') OR
            (v_datetimestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{3,4}',
                                       '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                       '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP, '\d{1,2}|',
                                       '\d{3,4}', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP,
                                       TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}\s*(?:\.)+|',
                                       '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
             v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV'))
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_datetimestring, CASE v_culture
                                                                 WHEN 'FI' THEN v_defmask6_fi_regexp
                                                                 ELSE v_defmask6_regexp
                                                              END, 'gi');
        v_timestring := concat(v_regmatch_groups[1], v_regmatch_groups[5]);
        v_day := v_regmatch_groups[4];
        v_month := v_regmatch_groups[3];
        v_year := CASE
                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_regmatch_groups[2]::SMALLINT - 543
                     ELSE v_regmatch_groups[2]::SMALLINT
                  END;

    ELSIF ((v_datetimestring ~* v_defmask2_regexp AND v_culture <> 'FI') OR
           (v_datetimestring ~* v_defmask2_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA') OR
            (v_datetimestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{3,4}',
                                       '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                       '(?:', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                       AMPM_REGEXP, TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?))', TIME_MASKSEP_REGEXP, '\d{1,2}|',
                                       '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
             v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV'))
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_datetimestring, CASE v_culture
                                                                 WHEN 'FI' THEN v_defmask2_fi_regexp
                                                                 ELSE v_defmask2_regexp
                                                              END, 'gi');
        v_timestring := v_regmatch_groups[2];
        v_correctnum := coalesce(v_regmatch_groups[1], v_regmatch_groups[3], v_regmatch_groups[5],
                                 v_regmatch_groups[6], v_regmatch_groups[8], v_regmatch_groups[9]);
        v_day := '01';
        v_month := v_regmatch_groups[7];
        v_year := CASE
                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_regmatch_groups[4]::SMALLINT - 543
                     ELSE v_regmatch_groups[4]::SMALLINT
                  END;

    ELSIF (v_datetimestring ~* v_defmask4_1_regexp OR
           (v_datetimestring ~* v_defmask4_2_regexp AND v_culture !~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV') OR
           (v_datetimestring ~* v_defmask9_regexp AND v_culture <> 'FI') OR
           (v_datetimestring ~* v_defmask9_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_datetimestring ~ concat('\d+\s*\.?(?:,+|,*', AMPM_REGEXP, ')', TIME_MASKSEP_FI_REGEXP, '\.+', TIME_MASKSEP_REGEXP, '$|',
                                      '\d+\s*\.', TIME_MASKSEP_FI_REGEXP, '\.', TIME_MASKSEP_FI_REGEXP, '$') AND
            v_culture = 'FI')
        THEN
            RAISE invalid_datetime_format;
        END IF;

        IF (v_datetimestring ~* v_defmask4_0_regexp) THEN
            v_timestring := (regexp_matches(v_datetimestring, v_defmask4_0_regexp, 'gi'))[1];
        ELSE
            v_timestring := v_datetimestring;
        END IF;

        v_res_date := current_date;
        v_day := to_char(v_res_date, 'DD');
        v_month := to_char(v_res_date, 'MM');
        v_year := to_char(v_res_date, 'YYYY')::SMALLINT;

    ELSIF ((v_datetimestring ~* v_defmask3_regexp AND v_culture <> 'FI') OR
           (v_datetimestring ~* v_defmask3_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA') OR
            (v_datetimestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?',
                                       TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP, '|',
                                       '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
             v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV'))
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_datetimestring, CASE v_culture
                                                                 WHEN 'FI' THEN v_defmask3_fi_regexp
                                                                 ELSE v_defmask3_regexp
                                                              END, 'gi');
        v_timestring := v_regmatch_groups[1];
        v_day := '01';
        v_month := v_regmatch_groups[2];
        v_year := CASE
                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_regmatch_groups[3]::SMALLINT - 543
                     ELSE v_regmatch_groups[3]::SMALLINT
                  END;

    ELSIF ((v_datetimestring ~* v_defmask5_regexp AND v_culture <> 'FI') OR
           (v_datetimestring ~* v_defmask5_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA') OR
            (v_datetimestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP,
                                       TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP,
                                       TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{3,4}', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$|',
                                       '\d{1,2}', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{3,4}\s*(?:\.)+|',
                                       '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
             v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV'))
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_datetimestring, v_defmask5_regexp, 'gi');
        v_timestring := concat(v_regmatch_groups[1], v_regmatch_groups[5]);
        v_year := CASE
                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_regmatch_groups[4]::SMALLINT - 543
                     ELSE v_regmatch_groups[4]::SMALLINT
                  END;

        IF (v_date_format = 'DMY' OR
            v_culture IN ('LV-LV', 'LV_LV'))
        THEN
            v_day := v_regmatch_groups[2];
            v_month := v_regmatch_groups[3];
        ELSE
            v_day := v_regmatch_groups[3];
            v_month := v_regmatch_groups[2];
        END IF;

    ELSIF ((v_datetimestring ~* v_defmask7_regexp AND v_culture <> 'FI') OR
           (v_datetimestring ~* v_defmask7_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA') OR
            (v_datetimestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}',
                                       MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{3,4}|',
                                       '\d{3,4}', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}\s*(?:\.)+|',
                                       '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
             v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV'))
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_datetimestring, CASE v_culture
                                                                 WHEN 'FI' THEN v_defmask7_fi_regexp
                                                                 ELSE v_defmask7_regexp
                                                              END, 'gi');
        v_timestring := concat(v_regmatch_groups[1], v_regmatch_groups[5]);
        v_day := v_regmatch_groups[4];
        v_month := v_regmatch_groups[2];
        v_year := CASE
                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_regmatch_groups[3]::SMALLINT - 543
                     ELSE v_regmatch_groups[3]::SMALLINT
                  END;

    ELSIF ((v_datetimestring ~* v_defmask8_regexp AND v_culture <> 'FI') OR
           (v_datetimestring ~* v_defmask8_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_datetimestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}',
                                      MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP,
                                      TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}|',
                                      '\d{1,2}', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP,
                                      TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}\s*(?:\.)+|',
                                      '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
            v_culture ~ 'FI|DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV')
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_datetimestring, CASE v_culture
                                                                 WHEN 'FI' THEN v_defmask8_fi_regexp
                                                                 ELSE v_defmask8_regexp
                                                              END, 'gi');
        v_timestring := concat(v_regmatch_groups[1], v_regmatch_groups[5]);

        IF (v_date_format = 'DMY' OR
            v_culture IN ('LV-LV', 'LV_LV'))
        THEN
            v_day := v_regmatch_groups[2];
            v_month := v_regmatch_groups[3];
            v_raw_year := v_regmatch_groups[4];
        ELSIF (v_date_format = 'YMD')
        THEN
            v_day := v_regmatch_groups[4];
            v_month := v_regmatch_groups[3];
            v_raw_year := v_regmatch_groups[2];
        ELSE
            v_day := v_regmatch_groups[3];
            v_month := v_regmatch_groups[2];
            v_raw_year := v_regmatch_groups[4];
        END IF;

        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA'))
        THEN
            IF (v_day::SMALLINT > 30 OR
                v_month::SMALLINT > 12) THEN
                RAISE invalid_datetime_format;
            END IF;

            v_raw_year := aws_sqlserver_ext.get_full_year(v_raw_year, '14');
            v_hijridate := aws_sqlserver_ext.conv_hijri_to_greg(v_day, v_month, v_raw_year) - 1;

            v_day := to_char(v_hijridate, 'DD');
            v_month := to_char(v_hijridate, 'MM');
            v_year := to_char(v_hijridate, 'YYYY')::SMALLINT;

        ELSIF (v_culture IN ('TH-TH', 'TH_TH')) THEN
            v_year := aws_sqlserver_ext.get_full_year(v_raw_year)::SMALLINT - 43;
        ELSE
            v_year := aws_sqlserver_ext.get_full_year(v_raw_year, '', 29)::SMALLINT;
        END IF;
    ELSE
        v_found := FALSE;
    END IF;

    WHILE (NOT v_found AND v_resmask_cnt < 20)
    LOOP
        v_resmask := replace(CASE v_resmask_cnt
                                WHEN 10 THEN v_defmask10_regexp
                                WHEN 11 THEN v_defmask11_regexp
                                WHEN 12 THEN v_defmask12_regexp
                                WHEN 13 THEN v_defmask13_regexp
                                WHEN 14 THEN v_defmask14_regexp
                                WHEN 15 THEN v_defmask15_regexp
                                WHEN 16 THEN v_defmask16_regexp
                                WHEN 17 THEN v_defmask17_regexp
                                WHEN 18 THEN v_defmask18_regexp
                                WHEN 19 THEN v_defmask19_regexp
                             END,
                             '$comp_month$', v_compmonth_regexp);

        v_resmask_fi := replace(CASE v_resmask_cnt
                                   WHEN 10 THEN v_defmask10_fi_regexp
                                   WHEN 11 THEN v_defmask11_fi_regexp
                                   WHEN 12 THEN v_defmask12_fi_regexp
                                   WHEN 13 THEN v_defmask13_fi_regexp
                                   WHEN 14 THEN v_defmask14_fi_regexp
                                   WHEN 15 THEN v_defmask15_fi_regexp
                                   WHEN 16 THEN v_defmask16_fi_regexp
                                   WHEN 17 THEN v_defmask17_fi_regexp
                                   WHEN 18 THEN v_defmask18_fi_regexp
                                   WHEN 19 THEN v_defmask19_fi_regexp
                                END,
                                '$comp_month$', v_compmonth_regexp);

        IF ((v_datetimestring ~* v_resmask AND v_culture <> 'FI') OR
            (v_datetimestring ~* v_resmask_fi AND v_culture = 'FI'))
        THEN
            v_found := TRUE;
            v_regmatch_groups := regexp_matches(v_datetimestring, CASE v_culture
                                                                     WHEN 'FI' THEN v_resmask_fi
                                                                     ELSE v_resmask
                                                                  END, 'gi');
            v_timestring := CASE
                               WHEN v_resmask_cnt IN (10, 11, 12, 13) THEN concat(v_regmatch_groups[1], v_regmatch_groups[4])
                               ELSE concat(v_regmatch_groups[1], v_regmatch_groups[5])
                            END;

            IF (v_resmask_cnt = 10)
            THEN
                IF (v_regmatch_groups[3] = 'MAR' AND
                    v_culture IN ('IT-IT', 'IT_IT'))
                THEN
                    RAISE invalid_datetime_format;
                END IF;

                IF (v_date_format = 'YMD' AND v_culture NOT IN ('SV-SE', 'SV_SE', 'LV-LV', 'LV_LV'))
                THEN
                    v_day := '01';
                    v_year := aws_sqlserver_ext.get_full_year(v_regmatch_groups[2], '', 29)::SMALLINT;
                ELSE
                    v_day := v_regmatch_groups[2];
                    v_year := to_char(current_date, 'YYYY')::SMALLINT;
                END IF;

                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[3], v_lang_metadata_json);
                v_raw_year := to_char(aws_sqlserver_ext.conv_greg_to_hijri(current_date + 1), 'YYYY');

            ELSIF (v_resmask_cnt = 11)
            THEN
                IF (v_date_format IN ('YMD', 'MDY') AND v_culture NOT IN ('SV-SE', 'SV_SE'))
                THEN
                    v_day := v_regmatch_groups[3];
                    v_year := to_char(current_date, 'YYYY')::SMALLINT;
                ELSE
                    v_day := '01';
                    v_year := CASE
                                 WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_regmatch_groups[3])::SMALLINT - 43
                                 ELSE aws_sqlserver_ext.get_full_year(v_regmatch_groups[3], '', 29)::SMALLINT
                              END;
                END IF;

                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
                v_raw_year := aws_sqlserver_ext.get_full_year(substring(v_year::TEXT, 3, 2), '14');

            ELSIF (v_resmask_cnt = 12)
            THEN
                v_day := '01';
                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[3], v_lang_metadata_json);
                v_raw_year := v_regmatch_groups[2];

            ELSIF (v_resmask_cnt = 13)
            THEN
                v_day := '01';
                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
                v_raw_year := v_regmatch_groups[3];

            ELSIF (v_resmask_cnt IN (14, 15, 16))
            THEN
                IF (v_resmask_cnt = 14)
                THEN
                    v_left_part := v_regmatch_groups[4];
                    v_right_part := v_regmatch_groups[3];
                    v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
                ELSIF (v_resmask_cnt = 15)
                THEN
                    v_left_part := v_regmatch_groups[4];
                    v_right_part := v_regmatch_groups[2];
                    v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[3], v_lang_metadata_json);
                ELSE
                    v_left_part := v_regmatch_groups[3];
                    v_right_part := v_regmatch_groups[2];
                    v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[4], v_lang_metadata_json);
                END IF;

                IF (char_length(v_left_part) <= 2)
                THEN
                    IF (v_date_format = 'YMD' AND v_culture NOT IN ('LV-LV', 'LV_LV'))
                    THEN
                        v_day := v_left_part;
                        v_raw_year := aws_sqlserver_ext.get_full_year(v_right_part, '14');
                        v_year := CASE
                                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_right_part)::SMALLINT - 43
                                     ELSE aws_sqlserver_ext.get_full_year(v_right_part, '', 29)::SMALLINT
                                  END;
                        BEGIN
                            v_res_date := make_date(v_year, v_month::SMALLINT, v_day::SMALLINT);
                        EXCEPTION
                        WHEN OTHERS THEN
                            v_day := v_right_part;
                            v_raw_year := aws_sqlserver_ext.get_full_year(v_left_part, '14');
                            v_year := CASE
                                         WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_left_part)::SMALLINT - 43
                                         ELSE aws_sqlserver_ext.get_full_year(v_left_part, '', 29)::SMALLINT
                                      END;
                        END;
                    END IF;

                    IF (v_date_format IN ('MDY', 'DMY') OR v_culture IN ('LV-LV', 'LV_LV'))
                    THEN
                        v_day := v_right_part;
                        v_raw_year := aws_sqlserver_ext.get_full_year(v_left_part, '14');
                        v_year := CASE
                                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_left_part)::SMALLINT - 43
                                     ELSE aws_sqlserver_ext.get_full_year(v_left_part, '', 29)::SMALLINT
                                  END;
                        BEGIN
                            v_res_date := make_date(v_year, v_month::SMALLINT, v_day::SMALLINT);
                        EXCEPTION
                        WHEN OTHERS THEN
                            v_day := v_left_part;
                            v_raw_year := aws_sqlserver_ext.get_full_year(v_right_part, '14');
                            v_year := CASE
                                         WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_right_part)::SMALLINT - 43
                                         ELSE aws_sqlserver_ext.get_full_year(v_right_part, '', 29)::SMALLINT
                                      END;
                        END;
                    END IF;
                ELSE
                    v_day := v_right_part;
                    v_raw_year := v_left_part;
	            v_year := CASE
                                 WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_left_part::SMALLINT - 543
                                 ELSE v_left_part::SMALLINT
                              END;
                END IF;

            ELSIF (v_resmask_cnt = 17)
            THEN
                v_day := v_regmatch_groups[4];
                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[3], v_lang_metadata_json);
                v_raw_year := v_regmatch_groups[2];

            ELSIF (v_resmask_cnt = 18)
            THEN
                v_day := v_regmatch_groups[3];
                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[4], v_lang_metadata_json);
                v_raw_year := v_regmatch_groups[2];

            ELSIF (v_resmask_cnt = 19)
            THEN
                v_day := v_regmatch_groups[4];
                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
                v_raw_year := v_regmatch_groups[3];
            END IF;

            IF (v_resmask_cnt NOT IN (10, 11, 14, 15, 16))
            THEN
                v_year := CASE
                             WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_raw_year::SMALLINT - 543
                             ELSE v_raw_year::SMALLINT
                          END;
            END IF;

            IF (v_culture IN ('AR', 'AR-SA', 'AR_SA'))
            THEN
                IF (v_day::SMALLINT > 30 OR
                    (v_resmask_cnt NOT IN (10, 11, 14, 15, 16) AND v_year NOT BETWEEN 1318 AND 1501) OR
                    (v_resmask_cnt IN (14, 15, 16) AND v_raw_year::SMALLINT NOT BETWEEN 1318 AND 1501))
                THEN
                    RAISE invalid_datetime_format;
                END IF;

                v_hijridate := aws_sqlserver_ext.conv_hijri_to_greg(v_day, v_month, v_raw_year) - 1;

                v_day := to_char(v_hijridate, 'DD');
                v_month := to_char(v_hijridate, 'MM');
                v_year := to_char(v_hijridate, 'YYYY')::SMALLINT;
            END IF;
        END IF;

        v_resmask_cnt := v_resmask_cnt + 1;
    END LOOP;

    IF (NOT v_found) THEN
        RAISE invalid_datetime_format;
    END IF;

    IF (char_length(v_timestring) > 0 AND v_timestring NOT IN ('AM', 'ص', 'PM', 'م'))
    THEN
        IF (v_culture = 'FI') THEN
            v_timestring := translate(v_timestring, '.,', ': ');

            IF (char_length(split_part(v_timestring, ':', 4)) > 0) THEN
                v_timestring := regexp_replace(v_timestring, ':(?=\s*\d+\s*:?\s*(?:[AP]M|ص|م)?\s*$)', '.');
            END IF;
        END IF;

        v_timestring := replace(regexp_replace(v_timestring, '\.?[AP]M|ص|م|\s|\,|\.\D|[\.|:]$', '', 'gi'), ':.', ':');
        BEGIN
            v_hours := coalesce(split_part(v_timestring, ':', 1)::SMALLINT, 0);

            IF ((v_dayparts[1] IN ('AM', 'ص') AND v_hours NOT BETWEEN 0 AND 12) OR
                (v_dayparts[1] IN ('PM', 'م') AND v_hours NOT BETWEEN 1 AND 23))
            THEN
                RAISE invalid_datetime_format;
            ELSIF (v_dayparts[1] = 'PM' AND v_hours < 12) THEN
                v_hours := v_hours + 12;
            ELSIF (v_dayparts[1] = 'AM' AND v_hours = 12) THEN
                v_hours := v_hours - 12;
            END IF;

            v_minutes := coalesce(nullif(split_part(v_timestring, ':', 2), '')::SMALLINT, 0);
            v_seconds := coalesce(nullif(split_part(v_timestring, ':', 3), ''), '0');

            IF (v_seconds ~ '\.') THEN
                v_fseconds := split_part(v_seconds, '.', 2);
                v_seconds := split_part(v_seconds, '.', 1);
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
            RAISE invalid_datetime_format;
        END;
    ELSIF (v_dayparts[1] IN ('PM', 'م'))
    THEN
        v_hours := 12;
    END IF;

    BEGIN
        IF (v_res_datatype IN ('DATETIME', 'SMALLDATETIME'))
        THEN
            v_res_datetime := aws_sqlserver_ext.datetimefromparts(v_year, v_month::SMALLINT, v_day::SMALLINT,
                                                                  v_hours, v_minutes, v_seconds::SMALLINT,
                                                                  rpad(v_fseconds, 3, '0')::NUMERIC);
            IF (v_res_datatype = 'SMALLDATETIME' AND
                to_char(v_res_datetime, 'SS') <> '00')
            THEN
                IF (to_char(v_res_datetime, 'SS')::SMALLINT >= 30) THEN
                    v_res_datetime := v_res_datetime + INTERVAL '1 minute';
                END IF;

                v_res_datetime := to_timestamp(to_char(v_res_datetime, 'DD.MM.YYYY.HH24.MI'), 'DD.MM.YYYY.HH24.MI');
            END IF;
        ELSE
            v_fseconds := aws_sqlserver_ext.get_microsecs_from_fractsecs(rpad(v_fseconds, 9, '0'), v_scale);
            v_seconds := concat_ws('.', v_seconds, v_fseconds);

            v_res_datetime := make_timestamp(v_year, v_month::SMALLINT, v_day::SMALLINT,
                                             v_hours, v_minutes, v_seconds::NUMERIC);
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;

        IF (v_err_message ~* 'Cannot construct data type') THEN
            RAISE invalid_datetime_format;
        END IF;
    END;

    IF (v_weekdaynames[1] IS NOT NULL) THEN
        v_weekdaynum := aws_sqlserver_ext.get_weekdaynum_by_name(v_weekdaynames[1], v_lang_metadata_json);

        IF (CASE date_part('dow', v_res_date)::SMALLINT
               WHEN 0 THEN 7
               ELSE date_part('dow', v_res_date)::SMALLINT
            END <> v_weekdaynum)
        THEN
            RAISE invalid_datetime_format;
        END IF;
    END IF;

    RETURN v_res_datetime;
EXCEPTION
    WHEN invalid_datetime_format OR datetime_field_overflow THEN
        RAISE USING MESSAGE := format('Error converting string value ''%s'' into data type %s using culture ''%s''.',
                                      p_datetimestring, v_res_datatype, p_culture),
                    DETAIL := 'Incorrect using of pair of input parameters values during conversion process.',
                    HINT := 'Check the input parameters values, correct them if needed, and try again.';

    WHEN datatype_mismatch THEN
        RAISE USING MESSAGE := 'Data type should be one of these values: ''DATETIME'', ''SMALLDATETIME'', ''DATETIME2''/''DATETIME2(n)''.',
                    DETAIL := 'Use of incorrect "datatype" parameter value during conversion process.',
                    HINT := 'Change "datatype" parameter to the proper value and try again.';

    WHEN invalid_indicator_parameter_value THEN
        RAISE USING MESSAGE := format('Invalid attributes specified for data type %s.', v_res_datatype),
                    DETAIL := 'Use of incorrect scale value, which is not corresponding to specified data type.',
                    HINT := 'Change data type scale component or select different data type and try again.';

    WHEN interval_field_overflow THEN
        RAISE USING MESSAGE := format('Specified scale %s is invalid.', v_scale),
                    DETAIL := 'Use of incorrect data type scale value during conversion process.',
                    HINT := 'Change scale component of data type parameter to be in range [0..7] and try again.';

    WHEN invalid_parameter_value THEN
        RAISE USING MESSAGE := CASE char_length(coalesce(CONVERSION_LANG, ''))
                                  WHEN 0 THEN format('The culture parameter ''%s'' provided in the function call is not supported.',
                                                     p_culture)
                                  ELSE format('Invalid CONVERSION_LANG constant value - ''%s''. Allowed values are: ''English'', ''Deutsch'', etc.',
                                              CONVERSION_LANG)
                               END,
                    DETAIL := 'Passed incorrect value for "p_culture" parameter or compiled incorrect CONVERSION_LANG constant value in function''s body.',
                    HINT := 'Check "p_culture" input parameter value, correct it if needed, and try again. Also check CONVERSION_LANG constant value.';

    WHEN invalid_text_representation THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
        v_err_message := substring(lower(v_err_message), 'integer\:\s\"(.*)\"');

        RAISE USING MESSAGE := format('Error while trying to convert "%s" value to SMALLINT data type.',
                                      v_err_message),
                    DETAIL := 'Supplied value contains illegal characters.',
                    HINT := 'Correct supplied value, remove all illegal characters.';
END;
]]></complex-attribute>
                        <category _I_D="ceae7c2a-87f5-43fc-9b9a-bb2c135347cf" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b7a67c44-7ded-41cc-83b4-481499094ce6" name="parse_to_time" function-id="16589" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="parse_to_time" is-aggregate="f" language-name="plpgsql" context="parse_to_time" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="time" count-arguments="3" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="parse_to_time(p_datatype text, p_srctimestring text, p_culture text)" arguments-datatypes="text,text,text" comment="This function parses the TEXT string and converts it into a TIME value, according to specified culture (conversion mask)." function-arguments="p_datatype text, p_srctimestring text, p_culture text DEFAULT ''::text" function-identity-arguments="p_datatype text, p_srctimestring text, p_culture text">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_day VARCHAR;
    v_year SMALLINT;
    v_month VARCHAR;
    v_res_date DATE;
    v_scale SMALLINT;
    v_hijridate DATE;
    v_culture VARCHAR;
    v_dayparts TEXT[];
    v_resmask VARCHAR;
    v_datatype VARCHAR;
    v_raw_year VARCHAR;
    v_left_part VARCHAR;
    v_right_part VARCHAR;
    v_resmask_fi VARCHAR;
    v_timestring VARCHAR;
    v_correctnum VARCHAR;
    v_weekdaynum SMALLINT;
    v_err_message VARCHAR;
    v_date_format VARCHAR;
    v_weekdaynames TEXT[];
    v_hours SMALLINT := 0;
    v_srctimestring VARCHAR;
    v_minutes SMALLINT := 0;
    v_res_datatype VARCHAR;
    v_error_message VARCHAR;
    v_found BOOLEAN := TRUE;
    v_compday_regexp VARCHAR;
    v_regmatch_groups TEXT[];
    v_datatype_groups TEXT[];
    v_seconds VARCHAR := '0';
    v_fseconds VARCHAR := '0';
    v_compmonth_regexp VARCHAR;
    v_lang_metadata_json JSONB;
    v_resmask_cnt SMALLINT := 10;
    v_res_time TIME WITHOUT TIME ZONE;
    DAYMM_REGEXP CONSTANT VARCHAR := '(\d{1,2})';
    FULLYEAR_REGEXP CONSTANT VARCHAR := '(\d{3,4})';
    SHORTYEAR_REGEXP CONSTANT VARCHAR := '(\d{1,2})';
    COMPYEAR_REGEXP CONSTANT VARCHAR := '(\d{1,4})';
    AMPM_REGEXP CONSTANT VARCHAR := '(?:[AP]M|ص|م)';
    TIMEUNIT_REGEXP CONSTANT VARCHAR := '\s*\d{1,2}\s*';
    MASKSEPONE_REGEXP CONSTANT VARCHAR := '\s*(?:/|-)?';
    MASKSEPTWO_REGEXP CONSTANT VARCHAR := '\s*(?:\s|/|-|\.|,)';
    MASKSEPTWO_FI_REGEXP CONSTANT VARCHAR := '\s*(?:\s|/|-|,)';
    MASKSEPTHREE_REGEXP CONSTANT VARCHAR := '\s*(?:/|-|\.|,)';
    TIME_MASKSEP_REGEXP CONSTANT VARCHAR := '(?:\s|\.|,)*';
    TIME_MASKSEP_FI_REGEXP CONSTANT VARCHAR := '(?:\s|,)*';
    WEEKDAYAMPM_START_REGEXP CONSTANT VARCHAR := '(^|[[:digit:][:space:]\.,])';
    WEEKDAYAMPM_END_REGEXP CONSTANT VARCHAR := '([[:digit:][:space:]\.,]|$)(?=[^/-]|$)';
    CORRECTNUM_REGEXP CONSTANT VARCHAR := '(?:([+-]\d{1,4})(?:[[:space:]\.,]|[AP]M|ص|م|$))';
    DATATYPE_REGEXP CONSTANT VARCHAR := '^(TIME)\s*(?:\()?\s*((?:-)?\d+)?\s*(?:\))?$';
    ANNO_DOMINI_REGEXP VARCHAR := '(AD|A\.D\.)';
    ANNO_DOMINI_COMPREGEXP VARCHAR := concat(WEEKDAYAMPM_START_REGEXP, ANNO_DOMINI_REGEXP, WEEKDAYAMPM_END_REGEXP);
    HHMMSSFS_PART_REGEXP CONSTANT VARCHAR :=
        concat(TIMEUNIT_REGEXP, AMPM_REGEXP, '|',
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '\:', TIME_MASKSEP_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '(?!\d)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?|',
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '\:', TIME_MASKSEP_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '\:', TIME_MASKSEP_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '(?!\d)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?|',
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '\:', TIME_MASKSEP_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '\:', TIME_MASKSEP_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\s*\d{1,2}\.\d+(?!\d)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?|',
               AMPM_REGEXP, '?');
    HHMMSSFS_PART_FI_REGEXP CONSTANT VARCHAR :=
        concat(TIMEUNIT_REGEXP, AMPM_REGEXP, '|',
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '[\:\.]', TIME_MASKSEP_FI_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '(?!\d)', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?\.?|',
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '[\:\.]', TIME_MASKSEP_FI_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '[\:\.]', TIME_MASKSEP_FI_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '(?!\d)', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?|',
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '[\:\.]', TIME_MASKSEP_FI_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '[\:\.]', TIME_MASKSEP_FI_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, '\s*\d{1,2}\.\d+(?!\d)\.?', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?|',
               AMPM_REGEXP, '?');
    v_defmask1_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        TIME_MASKSEP_REGEXP, '(?:[\.|,]+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)', TIME_MASKSEP_REGEXP, '$');
    v_defmask1_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP,
                                           '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_FI_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:', MASKSEPTWO_FI_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP,
                                           CORRECTNUM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[,]+', AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           TIME_MASKSEP_FI_REGEXP, '(?:[\.|,]+', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask2_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        FULLYEAR_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        AMPM_REGEXP, TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        TIME_MASKSEP_REGEXP, '(?:(?:[\.|,]+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?)|',
                                        CORRECTNUM_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP, '$');
    v_defmask2_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP,
                                           '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           CORRECTNUM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP,
                                           FULLYEAR_REGEXP,
                                           '(?:(?:', MASKSEPTWO_FI_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:', TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP,
                                           AMPM_REGEXP, TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           TIME_MASKSEP_FI_REGEXP, '(?:(?:[\.|,]+', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?)|',
                                           CORRECTNUM_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask3_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, ')|',
                                        '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        FULLYEAR_REGEXP,
                                        TIME_MASKSEP_REGEXP, '(', TIME_MASKSEP_REGEXP, AMPM_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask3_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           TIME_MASKSEP_FI_REGEXP, '[\./]?', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)',
                                           FULLYEAR_REGEXP,
                                           TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask4_0_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP, '\s*(', AMPM_REGEXP, ')',
                                          TIME_MASKSEP_REGEXP, '$');
    v_defmask4_1_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          '(?:\s|,)+',
                                          DAYMM_REGEXP, '\s*(', AMPM_REGEXP, ')',
                                          TIME_MASKSEP_REGEXP, '$');
    v_defmask4_2_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          '\s*[\.]+', TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP, '\s*(', AMPM_REGEXP, ')',
                                          TIME_MASKSEP_REGEXP, '$');
    v_defmask5_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        FULLYEAR_REGEXP,
                                        TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask5_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           FULLYEAR_REGEXP,
                                           TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask6_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        FULLYEAR_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '((?:(?:\s|\.|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_REGEXP, '))?', TIME_MASKSEP_REGEXP, '$');
    v_defmask6_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           FULLYEAR_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:\s*[\.])?',
                                           '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask7_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        FULLYEAR_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '((?:(?:\s|\.|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_REGEXP, '))?', TIME_MASKSEP_REGEXP, '$');
    v_defmask7_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           FULLYEAR_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask8_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:[\.|,]+', AMPM_REGEXP, ')?',
                                        TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask8_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_FI_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:[\,]+|\s*/\s*)', AMPM_REGEXP, ')?',
                                           TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask9_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(',
                                        HHMMSSFS_PART_REGEXP,
                                        ')', TIME_MASKSEP_REGEXP, '$');
    v_defmask9_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, '(',
                                           HHMMSSFS_PART_FI_REGEXP,
                                           ')', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask10_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)?', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask10_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            DAYMM_REGEXP,
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)?', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask11_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask11_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           '($comp_month$)',
                                           '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask12_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         FULLYEAR_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                         '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask12_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            FULLYEAR_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                            '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask13_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         FULLYEAR_REGEXP,
                                         TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$');
    v_defmask13_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            '($comp_month$)',
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                            FULLYEAR_REGEXP,
                                            TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask14_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)'
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)', TIME_MASKSEP_REGEXP,
                                         COMPYEAR_REGEXP,
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask14_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            '($comp_month$)'
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_FI_REGEXP,
                                            DAYMM_REGEXP,
                                            '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)', TIME_MASKSEP_FI_REGEXP,
                                            COMPYEAR_REGEXP,
                                            '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask15_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                         '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         COMPYEAR_REGEXP,
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask15_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            DAYMM_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                            '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                            COMPYEAR_REGEXP,
                                            '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask16_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)', TIME_MASKSEP_REGEXP,
                                         COMPYEAR_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                         '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask16_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            DAYMM_REGEXP,
                                            '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)', TIME_MASKSEP_REGEXP,
                                            COMPYEAR_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                            '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask17_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         FULLYEAR_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                         '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask17_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            FULLYEAR_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                            '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                            DAYMM_REGEXP,
                                            '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask18_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         FULLYEAR_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                         '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                         '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask18_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            FULLYEAR_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                            '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                            DAYMM_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                            '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask19_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         FULLYEAR_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                         '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '((?:(?:\s|\.|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_REGEXP, '))?', TIME_MASKSEP_REGEXP, '$');
    v_defmask19_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            '($comp_month$)',
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                            FULLYEAR_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                            '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                            DAYMM_REGEXP,
                                            '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    CONVERSION_LANG CONSTANT VARCHAR := '';
    DATE_FORMAT CONSTANT VARCHAR := '';
BEGIN
    v_datatype := trim(p_datatype);
    v_srctimestring := upper(trim(p_srctimestring));
    v_culture := coalesce(nullif(upper(trim(p_culture)), ''), 'EN-US');

    v_datatype_groups := regexp_matches(v_datatype, DATATYPE_REGEXP, 'gi');

    v_res_datatype := upper(v_datatype_groups[1]);
    v_scale := v_datatype_groups[2]::SMALLINT;

    IF (v_res_datatype IS NULL) THEN
        RAISE datatype_mismatch;
    ELSIF (coalesce(v_scale, 0) NOT BETWEEN 0 AND 7)
    THEN
        RAISE interval_field_overflow;
    ELSIF (v_scale IS NULL) THEN
        v_scale := 7;
    END IF;

    v_dayparts := ARRAY(SELECT upper(array_to_string(regexp_matches(v_srctimestring, '[AP]M|ص|م', 'gi'), '')));

    IF (array_length(v_dayparts, 1) > 1) THEN
        RAISE invalid_datetime_format;
    END IF;

    BEGIN
        v_lang_metadata_json := aws_sqlserver_ext.get_lang_metadata_json(coalesce(nullif(CONVERSION_LANG, ''), p_culture));
    EXCEPTION
        WHEN OTHERS THEN
        RAISE invalid_parameter_value;
    END;

    v_compday_regexp := array_to_string(array_cat(array_cat(ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'days_names')),
                                                            ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'days_shortnames'))),
                                                  ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'days_extrashortnames'))), '|');

    v_weekdaynames := ARRAY(SELECT array_to_string(regexp_matches(v_srctimestring, v_compday_regexp, 'gi'), ''));

    IF (array_length(v_weekdaynames, 1) > 1) THEN
        RAISE invalid_datetime_format;
    END IF;

    IF (v_weekdaynames[1] IS NOT NULL AND
        v_srctimestring ~* concat(WEEKDAYAMPM_START_REGEXP, '(', v_compday_regexp, ')', WEEKDAYAMPM_END_REGEXP))
    THEN
        v_srctimestring := replace(v_srctimestring, v_weekdaynames[1], ' ');
    END IF;

    IF (v_srctimestring ~* ANNO_DOMINI_COMPREGEXP)
    THEN
        IF (v_culture !~ 'EN[-_]US|DA[-_]DK|SV[-_]SE|EN[-_]GB|HI[-_]IS') THEN
            RAISE invalid_datetime_format;
        END IF;

        v_srctimestring := regexp_replace(v_srctimestring,
                                          ANNO_DOMINI_COMPREGEXP,
                                          regexp_replace(array_to_string(regexp_matches(v_srctimestring, ANNO_DOMINI_COMPREGEXP, 'gi'), ''),
                                                         ANNO_DOMINI_REGEXP, ' ', 'gi'),
                                          'gi');
    END IF;

    v_date_format := coalesce(nullif(upper(trim(DATE_FORMAT)), ''), v_lang_metadata_json ->> 'date_format');

    v_compmonth_regexp :=
        array_to_string(array_cat(array_cat(ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'months_shortnames')),
                                            ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'months_names'))),
                                  array_cat(ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'months_extrashortnames')),
                                            ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'months_extranames')))
                                 ), '|');

    IF ((v_srctimestring ~* v_defmask1_regexp AND v_culture <> 'FI') OR
        (v_srctimestring ~* v_defmask1_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_srctimestring ~ concat(CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                     CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP,
                                     AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}|',
                                     '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                     CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
            v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV')
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_srctimestring, CASE v_culture
                                                                WHEN 'FI' THEN v_defmask1_fi_regexp
                                                                ELSE v_defmask1_regexp
                                                             END, 'gi');
        v_timestring := v_regmatch_groups[2];
        v_correctnum := coalesce(v_regmatch_groups[1], v_regmatch_groups[3],
                                 v_regmatch_groups[5], v_regmatch_groups[6]);

        IF (v_date_format = 'DMY' OR
            v_culture IN ('SV-SE', 'SV_SE', 'LV-LV', 'LV_LV'))
        THEN
            v_day := v_regmatch_groups[4];
            v_month := v_regmatch_groups[7];
        ELSE
            v_day := v_regmatch_groups[7];
            v_month := v_regmatch_groups[4];
        END IF;

        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA'))
        THEN
            IF (v_day::SMALLINT > 30 OR
                v_month::SMALLINT > 12) THEN
                RAISE invalid_datetime_format;
            END IF;

            v_raw_year := to_char(aws_sqlserver_ext.conv_greg_to_hijri(current_date + 1), 'YYYY');
            v_hijridate := aws_sqlserver_ext.conv_hijri_to_greg(v_day, v_month, v_raw_year) - 1;

            v_day := to_char(v_hijridate, 'DD');
            v_month := to_char(v_hijridate, 'MM');
            v_year := to_char(v_hijridate, 'YYYY')::SMALLINT;
        ELSE
            v_year := to_char(current_date, 'YYYY')::SMALLINT;
        END IF;

    ELSIF ((v_srctimestring ~* v_defmask6_regexp AND v_culture <> 'FI') OR
           (v_srctimestring ~* v_defmask6_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA') OR
            (v_srctimestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{3,4}',
                                      '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                      '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP, '\d{1,2}|',
                                      '\d{3,4}', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP,
                                      TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}\s*(?:\.)+|',
                                      '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
             v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV'))
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_srctimestring, CASE v_culture
                                                                WHEN 'FI' THEN v_defmask6_fi_regexp
                                                                ELSE v_defmask6_regexp
                                                             END, 'gi');
        v_timestring := concat(v_regmatch_groups[1], v_regmatch_groups[5]);
        v_day := v_regmatch_groups[4];
        v_month := v_regmatch_groups[3];
        v_year := CASE
                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_regmatch_groups[2]::SMALLINT - 543
                     ELSE v_regmatch_groups[2]::SMALLINT
                  END;

    ELSIF ((v_srctimestring ~* v_defmask2_regexp AND v_culture <> 'FI') OR
           (v_srctimestring ~* v_defmask2_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA') OR
            (v_srctimestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{3,4}',
                                      '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                      '(?:', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                      AMPM_REGEXP, TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?))', TIME_MASKSEP_REGEXP, '\d{1,2}|',
                                      '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
             v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV'))
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_srctimestring, CASE v_culture
                                                                WHEN 'FI' THEN v_defmask2_fi_regexp
                                                                ELSE v_defmask2_regexp
                                                             END, 'gi');
        v_timestring := v_regmatch_groups[2];
        v_correctnum := coalesce(v_regmatch_groups[1], v_regmatch_groups[3], v_regmatch_groups[5],
                                 v_regmatch_groups[6], v_regmatch_groups[8], v_regmatch_groups[9]);
        v_day := '01';
        v_month := v_regmatch_groups[7];
        v_year := CASE
                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_regmatch_groups[4]::SMALLINT - 543
                     ELSE v_regmatch_groups[4]::SMALLINT
                  END;

    ELSIF (v_srctimestring ~* v_defmask4_1_regexp OR
           (v_srctimestring ~* v_defmask4_2_regexp AND v_culture !~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV') OR
           (v_srctimestring ~* v_defmask9_regexp AND v_culture <> 'FI') OR
           (v_srctimestring ~* v_defmask9_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_srctimestring ~ concat('\d+\s*\.?(?:,+|,*', AMPM_REGEXP, ')', TIME_MASKSEP_FI_REGEXP, '\.+', TIME_MASKSEP_REGEXP, '$|',
                                     '\d+\s*\.', TIME_MASKSEP_FI_REGEXP, '\.', TIME_MASKSEP_FI_REGEXP, '$') AND
            v_culture = 'FI')
        THEN
            RAISE invalid_datetime_format;
        END IF;

        IF (v_srctimestring ~* v_defmask4_0_regexp) THEN
            v_timestring := (regexp_matches(v_srctimestring, v_defmask4_0_regexp, 'gi'))[1];
        ELSE
            v_timestring := v_srctimestring;
        END IF;

        v_res_date := current_date;
        v_day := to_char(v_res_date, 'DD');
        v_month := to_char(v_res_date, 'MM');
        v_year := to_char(v_res_date, 'YYYY')::SMALLINT;

    ELSIF ((v_srctimestring ~* v_defmask3_regexp AND v_culture <> 'FI') OR
           (v_srctimestring ~* v_defmask3_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA') OR
            (v_srctimestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?',
                                      TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP, '|',
                                      '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
             v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV'))
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_srctimestring, CASE v_culture
                                                                WHEN 'FI' THEN v_defmask3_fi_regexp
                                                                ELSE v_defmask3_regexp
                                                             END, 'gi');
        v_timestring := v_regmatch_groups[1];
        v_day := '01';
        v_month := v_regmatch_groups[2];
        v_year := CASE
                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_regmatch_groups[3]::SMALLINT - 543
                     ELSE v_regmatch_groups[3]::SMALLINT
                  END;

    ELSIF ((v_srctimestring ~* v_defmask5_regexp AND v_culture <> 'FI') OR
           (v_srctimestring ~* v_defmask5_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA') OR
            (v_srctimestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP,
                                      TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP,
                                      TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{3,4}', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$|',
                                      '\d{1,2}', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{3,4}\s*(?:\.)+|',
                                      '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
             v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV'))
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_srctimestring, v_defmask5_regexp, 'gi');
        v_timestring := concat(v_regmatch_groups[1], v_regmatch_groups[5]);
        v_year := CASE
                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_regmatch_groups[4]::SMALLINT - 543
                     ELSE v_regmatch_groups[4]::SMALLINT
                  END;

        IF (v_date_format = 'DMY' OR
            v_culture IN ('LV-LV', 'LV_LV'))
        THEN
            v_day := v_regmatch_groups[2];
            v_month := v_regmatch_groups[3];
        ELSE
            v_day := v_regmatch_groups[3];
            v_month := v_regmatch_groups[2];
        END IF;

    ELSIF ((v_srctimestring ~* v_defmask7_regexp AND v_culture <> 'FI') OR
           (v_srctimestring ~* v_defmask7_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA') OR
            (v_srctimestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}',
                                      MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{3,4}|',
                                      '\d{3,4}', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}\s*(?:\.)+|',
                                      '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
             v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV'))
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_srctimestring, CASE v_culture
                                                                WHEN 'FI' THEN v_defmask7_fi_regexp
                                                                ELSE v_defmask7_regexp
                                                             END, 'gi');
        v_timestring := concat(v_regmatch_groups[1], v_regmatch_groups[5]);
        v_day := v_regmatch_groups[4];
        v_month := v_regmatch_groups[2];
        v_year := CASE
                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_regmatch_groups[3]::SMALLINT - 543
                     ELSE v_regmatch_groups[3]::SMALLINT
                  END;

    ELSIF ((v_srctimestring ~* v_defmask8_regexp AND v_culture <> 'FI') OR
           (v_srctimestring ~* v_defmask8_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_srctimestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}',
                                     MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP,
                                     TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}|',
                                     '\d{1,2}', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP,
                                     TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}\s*(?:\.)+|',
                                     '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
            v_culture ~ 'FI|DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV')
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_srctimestring, CASE v_culture
                                                                WHEN 'FI' THEN v_defmask8_fi_regexp
                                                                ELSE v_defmask8_regexp
                                                             END, 'gi');
        v_timestring := concat(v_regmatch_groups[1], v_regmatch_groups[5]);

        IF (v_date_format = 'DMY' OR
            v_culture IN ('LV-LV', 'LV_LV'))
        THEN
            v_day := v_regmatch_groups[2];
            v_month := v_regmatch_groups[3];
            v_raw_year := v_regmatch_groups[4];
        ELSIF (v_date_format = 'YMD')
        THEN
            v_day := v_regmatch_groups[4];
            v_month := v_regmatch_groups[3];
            v_raw_year := v_regmatch_groups[2];
        ELSE
            v_day := v_regmatch_groups[3];
            v_month := v_regmatch_groups[2];
            v_raw_year := v_regmatch_groups[4];
        END IF;

        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA'))
        THEN
            IF (v_day::SMALLINT > 30 OR
                v_month::SMALLINT > 12) THEN
                RAISE invalid_datetime_format;
            END IF;

            v_raw_year := aws_sqlserver_ext.get_full_year(v_raw_year, '14');
            v_hijridate := aws_sqlserver_ext.conv_hijri_to_greg(v_day, v_month, v_raw_year) - 1;

            v_day := to_char(v_hijridate, 'DD');
            v_month := to_char(v_hijridate, 'MM');
            v_year := to_char(v_hijridate, 'YYYY')::SMALLINT;

        ELSIF (v_culture IN ('TH-TH', 'TH_TH')) THEN
            v_year := aws_sqlserver_ext.get_full_year(v_raw_year)::SMALLINT - 43;
        ELSE
            v_year := aws_sqlserver_ext.get_full_year(v_raw_year, '', 29)::SMALLINT;
        END IF;
    ELSE
        v_found := FALSE;
    END IF;

    WHILE (NOT v_found AND v_resmask_cnt < 20)
    LOOP
        v_resmask := replace(CASE v_resmask_cnt
                                WHEN 10 THEN v_defmask10_regexp
                                WHEN 11 THEN v_defmask11_regexp
                                WHEN 12 THEN v_defmask12_regexp
                                WHEN 13 THEN v_defmask13_regexp
                                WHEN 14 THEN v_defmask14_regexp
                                WHEN 15 THEN v_defmask15_regexp
                                WHEN 16 THEN v_defmask16_regexp
                                WHEN 17 THEN v_defmask17_regexp
                                WHEN 18 THEN v_defmask18_regexp
                                WHEN 19 THEN v_defmask19_regexp
                             END,
                             '$comp_month$', v_compmonth_regexp);

        v_resmask_fi := replace(CASE v_resmask_cnt
                                   WHEN 10 THEN v_defmask10_fi_regexp
                                   WHEN 11 THEN v_defmask11_fi_regexp
                                   WHEN 12 THEN v_defmask12_fi_regexp
                                   WHEN 13 THEN v_defmask13_fi_regexp
                                   WHEN 14 THEN v_defmask14_fi_regexp
                                   WHEN 15 THEN v_defmask15_fi_regexp
                                   WHEN 16 THEN v_defmask16_fi_regexp
                                   WHEN 17 THEN v_defmask17_fi_regexp
                                   WHEN 18 THEN v_defmask18_fi_regexp
                                   WHEN 19 THEN v_defmask19_fi_regexp
                                END,
                                '$comp_month$', v_compmonth_regexp);

        IF ((v_srctimestring ~* v_resmask AND v_culture <> 'FI') OR
            (v_srctimestring ~* v_resmask_fi AND v_culture = 'FI'))
        THEN
            v_found := TRUE;
            v_regmatch_groups := regexp_matches(v_srctimestring, CASE v_culture
                                                                    WHEN 'FI' THEN v_resmask_fi
                                                                    ELSE v_resmask
                                                                 END, 'gi');
            v_timestring := CASE
                               WHEN v_resmask_cnt IN (10, 11, 12, 13) THEN concat(v_regmatch_groups[1], v_regmatch_groups[4])
                               ELSE concat(v_regmatch_groups[1], v_regmatch_groups[5])
                            END;

            IF (v_resmask_cnt = 10)
            THEN
                IF (v_regmatch_groups[3] = 'MAR' AND
                    v_culture IN ('IT-IT', 'IT_IT'))
                THEN
                    RAISE invalid_datetime_format;
                END IF;

                IF (v_date_format = 'YMD' AND v_culture NOT IN ('SV-SE', 'SV_SE', 'LV-LV', 'LV_LV'))
                THEN
                    v_day := '01';
                    v_year := aws_sqlserver_ext.get_full_year(v_regmatch_groups[2], '', 29)::SMALLINT;
                ELSE
                    v_day := v_regmatch_groups[2];
                    v_year := to_char(current_date, 'YYYY')::SMALLINT;
                END IF;

                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[3], v_lang_metadata_json);
                v_raw_year := to_char(aws_sqlserver_ext.conv_greg_to_hijri(current_date + 1), 'YYYY');

            ELSIF (v_resmask_cnt = 11)
            THEN
                IF (v_date_format IN ('YMD', 'MDY') AND v_culture NOT IN ('SV-SE', 'SV_SE'))
                THEN
                    v_day := v_regmatch_groups[3];
                    v_year := to_char(current_date, 'YYYY')::SMALLINT;
                ELSE
                    v_day := '01';
                    v_year := CASE
                                 WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_regmatch_groups[3])::SMALLINT - 43
                                 ELSE aws_sqlserver_ext.get_full_year(v_regmatch_groups[3], '', 29)::SMALLINT
                              END;
                END IF;

                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
                v_raw_year := aws_sqlserver_ext.get_full_year(substring(v_year::TEXT, 3, 2), '14');

            ELSIF (v_resmask_cnt = 12)
            THEN
                v_day := '01';
                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[3], v_lang_metadata_json);
                v_raw_year := v_regmatch_groups[2];

            ELSIF (v_resmask_cnt = 13)
            THEN
                v_day := '01';
                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
                v_raw_year := v_regmatch_groups[3];

            ELSIF (v_resmask_cnt IN (14, 15, 16))
            THEN
                IF (v_resmask_cnt = 14)
                THEN
                    v_left_part := v_regmatch_groups[4];
                    v_right_part := v_regmatch_groups[3];
                    v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
                ELSIF (v_resmask_cnt = 15)
                THEN
                    v_left_part := v_regmatch_groups[4];
                    v_right_part := v_regmatch_groups[2];
                    v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[3], v_lang_metadata_json);
                ELSE
                    v_left_part := v_regmatch_groups[3];
                    v_right_part := v_regmatch_groups[2];
                    v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[4], v_lang_metadata_json);
                END IF;

                IF (char_length(v_left_part) <= 2)
                THEN
                    IF (v_date_format = 'YMD' AND v_culture NOT IN ('LV-LV', 'LV_LV'))
                    THEN
                        v_day := v_left_part;
                        v_raw_year := aws_sqlserver_ext.get_full_year(v_right_part, '14');
                        v_year := CASE
                                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_right_part)::SMALLINT - 43
                                     ELSE aws_sqlserver_ext.get_full_year(v_right_part, '', 29)::SMALLINT
                                  END;
                        BEGIN
                            v_res_date := make_date(v_year, v_month::SMALLINT, v_day::SMALLINT);
                        EXCEPTION
                        WHEN OTHERS THEN
                            v_day := v_right_part;
                            v_raw_year := aws_sqlserver_ext.get_full_year(v_left_part, '14');
                            v_year := CASE
                                         WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_left_part)::SMALLINT - 43
                                         ELSE aws_sqlserver_ext.get_full_year(v_left_part, '', 29)::SMALLINT
                                      END;
                        END;
                    END IF;

                    IF (v_date_format IN ('MDY', 'DMY') OR v_culture IN ('LV-LV', 'LV_LV'))
                    THEN
                        v_day := v_right_part;
                        v_raw_year := aws_sqlserver_ext.get_full_year(v_left_part, '14');
                        v_year := CASE
                                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_left_part)::SMALLINT - 43
                                     ELSE aws_sqlserver_ext.get_full_year(v_left_part, '', 29)::SMALLINT
                                  END;
                        BEGIN
                            v_res_date := make_date(v_year, v_month::SMALLINT, v_day::SMALLINT);
                        EXCEPTION
                        WHEN OTHERS THEN
                            v_day := v_left_part;
                            v_raw_year := aws_sqlserver_ext.get_full_year(v_right_part, '14');
                            v_year := CASE
                                         WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_right_part)::SMALLINT - 43
                                         ELSE aws_sqlserver_ext.get_full_year(v_right_part, '', 29)::SMALLINT
                                      END;
                        END;
                    END IF;
                ELSE
                    v_day := v_right_part;
                    v_raw_year := v_left_part;
	            v_year := CASE
                                 WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_left_part::SMALLINT - 543
                                 ELSE v_left_part::SMALLINT
                              END;
                END IF;

            ELSIF (v_resmask_cnt = 17)
            THEN
                v_day := v_regmatch_groups[4];
                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[3], v_lang_metadata_json);
                v_raw_year := v_regmatch_groups[2];

            ELSIF (v_resmask_cnt = 18)
            THEN
                v_day := v_regmatch_groups[3];
                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[4], v_lang_metadata_json);
                v_raw_year := v_regmatch_groups[2];

            ELSIF (v_resmask_cnt = 19)
            THEN
                v_day := v_regmatch_groups[4];
                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
                v_raw_year := v_regmatch_groups[3];
            END IF;

            IF (v_resmask_cnt NOT IN (10, 11, 14, 15, 16))
            THEN
                v_year := CASE
                             WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_raw_year::SMALLINT - 543
                             ELSE v_raw_year::SMALLINT
                          END;
            END IF;

            IF (v_culture IN ('AR', 'AR-SA', 'AR_SA'))
            THEN
                IF (v_day::SMALLINT > 30 OR
                    (v_resmask_cnt NOT IN (10, 11, 14, 15, 16) AND v_year NOT BETWEEN 1318 AND 1501) OR
                    (v_resmask_cnt IN (14, 15, 16) AND v_raw_year::SMALLINT NOT BETWEEN 1318 AND 1501))
                THEN
                    RAISE invalid_datetime_format;
                END IF;

                v_hijridate := aws_sqlserver_ext.conv_hijri_to_greg(v_day, v_month, v_raw_year) - 1;

                v_day := to_char(v_hijridate, 'DD');
                v_month := to_char(v_hijridate, 'MM');
                v_year := to_char(v_hijridate, 'YYYY')::SMALLINT;
            END IF;
        END IF;

        v_resmask_cnt := v_resmask_cnt + 1;
    END LOOP;

    IF (NOT v_found) THEN
        RAISE invalid_datetime_format;
    END IF;

    v_res_date := make_date(v_year, v_month::SMALLINT, v_day::SMALLINT);

    IF (v_weekdaynames[1] IS NOT NULL) THEN
        v_weekdaynum := aws_sqlserver_ext.get_weekdaynum_by_name(v_weekdaynames[1], v_lang_metadata_json);

        IF (date_part('dow', v_res_date)::SMALLINT <> v_weekdaynum) THEN
            RAISE invalid_datetime_format;
        END IF;
    END IF;

    IF (char_length(v_timestring) > 0 AND v_timestring NOT IN ('AM', 'ص', 'PM', 'م'))
    THEN
        IF (v_culture = 'FI') THEN
            v_timestring := translate(v_timestring, '.,', ': ');

            IF (char_length(split_part(v_timestring, ':', 4)) > 0) THEN
                v_timestring := regexp_replace(v_timestring, ':(?=\s*\d+\s*:?\s*(?:[AP]M|ص|م)?\s*$)', '.');
            END IF;
        END IF;

        v_timestring := replace(regexp_replace(v_timestring, '\.?[AP]M|ص|م|\s|\,|\.\D|[\.|:]$', '', 'gi'), ':.', ':');

        BEGIN
            v_hours := coalesce(split_part(v_timestring, ':', 1)::SMALLINT, 0);

            IF ((v_dayparts[1] IN ('AM', 'ص') AND v_hours NOT BETWEEN 0 AND 12) OR
                (v_dayparts[1] IN ('PM', 'م') AND v_hours NOT BETWEEN 1 AND 23))
            THEN
                RAISE invalid_datetime_format;
            ELSIF (v_dayparts[1] = 'PM' AND v_hours < 12) THEN
                v_hours := v_hours + 12;
            ELSIF (v_dayparts[1] = 'AM' AND v_hours = 12) THEN
                v_hours := v_hours - 12;
            END IF;

            v_minutes := coalesce(nullif(split_part(v_timestring, ':', 2), '')::SMALLINT, 0);
            v_seconds := coalesce(nullif(split_part(v_timestring, ':', 3), ''), '0');

            IF (v_seconds ~ '\.') THEN
                v_fseconds := split_part(v_seconds, '.', 2);
                v_seconds := split_part(v_seconds, '.', 1);
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
            RAISE invalid_datetime_format;
        END;
    ELSIF (v_dayparts[1] IN ('PM', 'م'))
    THEN
        v_hours := 12;
    END IF;

    v_fseconds := aws_sqlserver_ext.get_microsecs_from_fractsecs(rpad(v_fseconds, 9, '0'), v_scale);
    v_seconds := concat_ws('.', v_seconds, v_fseconds);

    v_res_time := make_time(v_hours, v_minutes, v_seconds::NUMERIC);

    RETURN v_res_time;
EXCEPTION
    WHEN invalid_datetime_format OR datetime_field_overflow THEN
        RAISE USING MESSAGE := format('Error converting string value ''%s'' into data type %s using culture ''%s''.',
                                      p_srctimestring, v_res_datatype, p_culture),
                    DETAIL := 'Incorrect using of pair of input parameters values during conversion process.',
                    HINT := 'Check the input parameters values, correct them if needed, and try again.';

    WHEN datatype_mismatch THEN
        RAISE USING MESSAGE := 'Source data type should be ''TIME'' or ''TIME(n)''.',
                    DETAIL := 'Use of incorrect "datatype" parameter value during conversion process.',
                    HINT := 'Change "datatype" parameter to the proper value and try again.';

    WHEN invalid_indicator_parameter_value THEN
        RAISE USING MESSAGE := format('Invalid attributes specified for data type %s.', v_res_datatype),
                    DETAIL := 'Use of incorrect scale value, which is not corresponding to specified data type.',
                    HINT := 'Change data type scale component or select different data type and try again.';

    WHEN interval_field_overflow THEN
        RAISE USING MESSAGE := format('Specified scale %s is invalid.', v_scale),
                    DETAIL := 'Use of incorrect data type scale value during conversion process.',
                    HINT := 'Change scale component of data type parameter to be in range [0..7] and try again.';

    WHEN invalid_parameter_value THEN
        RAISE USING MESSAGE := CASE char_length(coalesce(CONVERSION_LANG, ''))
                                  WHEN 0 THEN format('The culture parameter ''%s'' provided in the function call is not supported.',
                                                     p_culture)
                                  ELSE format('Invalid CONVERSION_LANG constant value - ''%s''. Allowed values are: ''English'', ''Deutsch'', etc.',
                                              CONVERSION_LANG)
                               END,
                    DETAIL := 'Passed incorrect value for "p_culture" parameter or compiled incorrect CONVERSION_LANG constant value in function''s body.',
                    HINT := 'Check "p_culture" input parameter value, correct it if needed, and try again. Also check CONVERSION_LANG constant value.';

    WHEN invalid_text_representation THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
        v_err_message := substring(lower(v_err_message), 'integer\:\s\"(.*)\"');

        RAISE USING MESSAGE := format('Error while trying to convert "%s" value to SMALLINT data type.',
                                      v_err_message),
                    DETAIL := 'Supplied value contains illegal characters.',
                    HINT := 'Correct supplied value, remove all illegal characters.';
END;
]]></complex-attribute>
                        <category _I_D="d36e7317-065c-4097-867d-6e464f7a8a9c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="20201d92-2660-4b0c-b905-8e4d847370f8" name="parsename" function-id="16603" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="parsename" is-aggregate="f" language-name="sql" context="parsename" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="varchar" count-arguments="2" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="parsename(object_name character varying, object_piece integer)" arguments-datatypes="character varying,integer" function-arguments="object_name character varying, object_piece integer" function-identity-arguments="object_name character varying, object_piece integer">
                        <complex-attribute name="sql"><![CDATA[
/***************************************************************
EXTENSION PACK function PARSENAME(x)
***************************************************************/
SELECT CASE 
		WHEN char_length($1) < char_length(replace($1, '.', '')) + 4
			AND $2 BETWEEN 1
				AND 4
			THEN reverse(split_part(reverse($1), '.', $2))
		ELSE NULL
		END ]]></complex-attribute>
                        <category _I_D="b5b46acf-755f-4f59-a8a8-9e42b27b2208" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="089eba1a-0d98-42cc-8472-6e5b01996848" name="patindex" function-id="16604" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="patindex" is-aggregate="f" language-name="plpgsql" context="patindex" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int8" count-arguments="2" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="patindex(pattern character varying, expression character varying)" arguments-datatypes="character varying,character varying" function-arguments="pattern character varying, expression character varying" function-identity-arguments="pattern character varying, expression character varying">
                        <complex-attribute name="sql"><![CDATA[
declare 
  v_find_result character varying;
  v_pos bigint;
  v_regexp_pattern character varying;
begin  
  v_pos := null;
  if left(pattern, 1) = '%' then
    v_regexp_pattern := regexp_replace(pattern, '^%', '%#"');
  else 
    v_regexp_pattern := '#"' || pattern;
  end if;
  
  if right(pattern, 1) = '%' then
    v_regexp_pattern := regexp_replace(v_regexp_pattern, '%$', '#"%');
  else  
   v_regexp_pattern := v_regexp_pattern || '#"';
 end if;  
  v_find_result := substring(expression from v_regexp_pattern for '#');
  if v_find_result <> '' then
    v_pos := strpos(expression, v_find_result);
  end if;  
  return v_pos;
end;
]]></complex-attribute>
                        <category _I_D="b2d5d86f-73e2-4d5d-ace4-9d27906976f2" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0eebe763-0451-4060-ba70-5487cdd6808d" name="rand" function-id="16605" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="rand" is-aggregate="f" language-name="plpgsql" context="rand" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="float8" count-arguments="1" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="rand(x integer)" arguments-datatypes="integer" function-arguments="x integer" function-identity-arguments="x integer">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
/***************************************************************
EXTENSION PACK function RAND(x)
***************************************************************/
	perform setseed(x::double precision/2147483649);
	return random();
END;
]]></complex-attribute>
                        <category _I_D="8997cbd3-a28d-4ede-a4aa-fee0d134feaf" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="db705344-1340-44fd-bd38-be384b05586b" name="round3" function-id="16606" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="round3" is-aggregate="f" language-name="plpgsql" context="round3" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="numeric" count-arguments="3" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="round3(x numeric, y integer, z integer)" arguments-datatypes="numeric,integer,integer" function-arguments="x numeric, y integer, z integer" function-identity-arguments="x numeric, y integer, z integer">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
/***************************************************************
EXTENSION PACK function ROUND3(arg1, arg2, arg3)
***************************************************************/
	if z = 0 or z is null then
		return round(x,y);
	else
		return trunc(x,y);
	end if;
END;
]]></complex-attribute>
                        <category _I_D="d27f112e-d4aa-4423-8834-b8e3c170982f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f3d26bd4-2412-4a50-86f6-033a8c94e029" name="round_fractseconds" function-id="16545" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="round_fractseconds(p_fractseconds numeric)" is-aggregate="f" language-name="plpgsql" context="round_fractseconds(p_fractseconds numeric)" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" count-arguments="1" volatility="IMMUTABLE" is-window="f" overload-function-count="2" proc-language="plpgsql" function-signature="round_fractseconds(p_fractseconds numeric)" arguments-datatypes="numeric" comment="This function rounds milliseconds or microseconds in accordance with MS SQL Server conversion policy of datetime fractional second precision part." unique-suffix="(p_fractseconds numeric)" routine-number="16545" function-arguments="p_fractseconds numeric" function-identity-arguments="p_fractseconds numeric">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
   v_modpart INTEGER;
   v_decpart INTEGER;
   v_fractseconds INTEGER;
BEGIN
    v_fractseconds := floor(p_fractseconds)::INTEGER;
    v_modpart := v_fractseconds % 10;
    v_decpart := v_fractseconds - v_modpart;  

    RETURN CASE
              WHEN (v_modpart BETWEEN 0 AND 1) THEN v_decpart
              WHEN (v_modpart BETWEEN 2 AND 4) THEN v_decpart + 3
              WHEN (v_modpart BETWEEN 5 AND 8) THEN v_decpart + 7
              ELSE v_decpart + 10 -- 9
           END;
END;
]]></complex-attribute>
                        <category _I_D="0abb9228-6b62-4052-8efd-7de5168b1756" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c7ff67f3-c909-4fc8-9072-9ea1d3d4c3e8" name="round_fractseconds" function-id="16546" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="round_fractseconds(p_fractseconds text)" is-aggregate="f" language-name="plpgsql" context="round_fractseconds(p_fractseconds text)" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" count-arguments="1" volatility="IMMUTABLE" is-window="f" overload-function-count="2" proc-language="plpgsql" function-signature="round_fractseconds(p_fractseconds text)" arguments-datatypes="text" comment="This function rounds milliseconds or microseconds in accordance with MS SQL Server conversion policy of datetime fractional second precision part." unique-suffix="(p_fractseconds text)" routine-number="16546" function-arguments="p_fractseconds text" function-identity-arguments="p_fractseconds text">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    RETURN aws_sqlserver_ext.round_fractseconds(p_fractseconds::NUMERIC);
EXCEPTION
    WHEN invalid_text_representation THEN
        RAISE USING MESSAGE := format('Error while trying to convert "%s" value to NUMERIC data type.', trim(p_fractseconds)),
                    DETAIL := 'Passed argument value contains illegal characters.',
                    HINT := 'Correct passed argument value, remove all illegal characters.';


END;
]]></complex-attribute>
                        <category _I_D="4472f928-501b-4a51-ad2c-0d210d1b572b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="866a7625-7948-452a-964f-c3e16c6e2e60" name="set_service_setting" function-id="16673" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="set_service_setting" is-aggregate="f" language-name="plpgsql" context="set_service_setting" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" count-arguments="3" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="set_service_setting(p_service character varying, p_setting character varying, p_value character varying)" arguments-datatypes="character varying,character varying,character varying" function-arguments="p_service character varying, p_setting character varying, p_value character varying" function-identity-arguments="p_service character varying, p_setting character varying, p_value character varying">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
  DELETE FROM aws_sqlserver_ext_data.service_settings
   WHERE service = p_service
     AND setting = p_setting;

  INSERT INTO aws_sqlserver_ext_data.service_settings(service, setting, value)
  VALUES (p_service, p_setting, p_value);

  DELETE FROM aws_sqlserver_ext.sysmail_server;
 
  IF p_service = 'MAIL' THEN 
    PERFORM aws_sqlserver_ext.sysmail_set_arn_sp(p_value);
  END IF;
END;
]]></complex-attribute>
                        <category _I_D="9fd04972-7702-48b7-abf2-29f1ee0b968a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="875b37e3-0eae-4fd2-b26a-b8d1cf97a751" name="set_version" function-id="16607" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="set_version" is-aggregate="f" language-name="plpgsql" context="set_version" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" count-arguments="2" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="set_version(pcomponentversion character varying, pcomponentname character varying)" arguments-datatypes="character varying,character varying" function-arguments="pcomponentversion character varying, pcomponentname character varying" function-identity-arguments="pcomponentversion character varying, pcomponentname character varying">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  rowcount smallint;
BEGIN
	UPDATE aws_sqlserver_ext.versions 
	   SET componentversion = pComponentVersion
	 WHERE extpackcomponentname = pComponentName;	 
	GET DIAGNOSTICS rowcount = ROW_COUNT;
	
	IF rowcount < 1 THEN
	 INSERT INTO aws_sqlserver_ext.versions(extpackcomponentname,componentversion) 
	      VALUES (pComponentName,pComponentVersion);
	END IF;
END;
]]></complex-attribute>
                        <category _I_D="b4230812-9bd8-4291-a0e2-2add4465c371" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0f1294c6-7126-4fc6-82e1-d9bc0b9d51a3" name="sp_add_job" function-id="16609" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sp_add_job" is-aggregate="f" language-name="plpgsql" context="sp_add_job" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="record" count-arguments="17" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_add_job(par_job_name character varying, par_enabled smallint, par_description character varying, par_start_step_id integer, par_category_name character varying, par_category_id integer, par_owner_login_name character varying, par_notify_level_eventlog integer, par_notify_level_email integer, par_notify_level_netsend integer, par_notify_level_page integer, par_notify_email_operator_name character varying, par_notify_netsend_operator_name character varying, par_notify_page_operator_name character varying, par_delete_level integer, INOUT par_job_id integer, par_originating_server character varying, OUT returncode integer)" arguments-datatypes="character varying,smallint,character varying,integer,character varying,integer,character varying,integer,integer,integer,integer,character varying,character varying,character varying,integer,integer,character varying,integer" function-arguments="par_job_name character varying, par_enabled smallint DEFAULT 1, par_description character varying DEFAULT NULL::character varying, par_start_step_id integer DEFAULT 1, par_category_name character varying DEFAULT NULL::character varying, par_category_id integer DEFAULT NULL::integer, par_owner_login_name character varying DEFAULT NULL::character varying, par_notify_level_eventlog integer DEFAULT 2, par_notify_level_email integer DEFAULT 0, par_notify_level_netsend integer DEFAULT 0, par_notify_level_page integer DEFAULT 0, par_notify_email_operator_name character varying DEFAULT NULL::character varying, par_notify_netsend_operator_name character varying DEFAULT NULL::character varying, par_notify_page_operator_name character varying DEFAULT NULL::character varying, par_delete_level integer DEFAULT 0, INOUT par_job_id integer DEFAULT NULL::integer, par_originating_server character varying DEFAULT NULL::character varying, OUT returncode integer" function-identity-arguments="par_job_name character varying, par_enabled smallint, par_description character varying, par_start_step_id integer, par_category_name character varying, par_category_id integer, par_owner_login_name character varying, par_notify_level_eventlog integer, par_notify_level_email integer, par_notify_level_netsend integer, par_notify_level_page integer, par_notify_email_operator_name character varying, par_notify_netsend_operator_name character varying, par_notify_page_operator_name character varying, par_delete_level integer, INOUT par_job_id integer, par_originating_server character varying, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_retval INT DEFAULT 0;
  var_notify_email_operator_id INT DEFAULT 0;
  var_notify_email_operator_name VARCHAR(128);
  var_notify_netsend_operator_id INT DEFAULT 0;
  var_notify_page_operator_id INT DEFAULT 0;
  var_owner_sid CHAR(85) ;
  var_originating_server_id INT DEFAULT 0;
BEGIN
  /* Remove any leading/trailing spaces from parameters (except @owner_login_name) */
  SELECT UPPER(LTRIM(RTRIM(par_originating_server))) INTO par_originating_server;
  SELECT LTRIM(RTRIM(par_job_name)) INTO par_job_name;
  SELECT LTRIM(RTRIM(par_description)) INTO par_description;
  SELECT '[Uncategorized (Local)]' INTO par_category_name;
  SELECT 0 INTO par_category_id;
  SELECT LTRIM(RTRIM(par_notify_email_operator_name)) INTO par_notify_email_operator_name;
  SELECT LTRIM(RTRIM(par_notify_netsend_operator_name)) INTO par_notify_netsend_operator_name;
  SELECT LTRIM(RTRIM(par_notify_page_operator_name)) INTO par_notify_page_operator_name;
  SELECT NULL INTO var_originating_server_id; /* Turn [nullable] empty string parameters into NULLs */
  SELECT NULL INTO par_job_id;

  IF (par_originating_server = '') 
  THEN
    SELECT NULL INTO par_originating_server;
  END IF;

  IF (par_description = '') 
  THEN
    SELECT NULL INTO par_description;
  END IF;

  IF (par_category_name = '') 
  THEN
    SELECT NULL INTO par_category_name;
  END IF;

  IF (par_notify_email_operator_name = '') 
  THEN 
    SELECT NULL INTO par_notify_email_operator_name;
  END IF;

  IF (par_notify_netsend_operator_name = '') 
  THEN
    SELECT NULL INTO par_notify_netsend_operator_name;
  END IF;

  IF (par_notify_page_operator_name = '') 
  THEN 
    SELECT NULL INTO par_notify_page_operator_name;
  END IF;

  /* Check parameters */
  SELECT t.par_owner_sid
       , t.par_notify_level_email
       , t.par_notify_level_netsend
       , t.par_notify_level_page
       , t.par_category_id
       , t.par_notify_email_operator_id
       , t.par_notify_netsend_operator_id
       , t.par_notify_page_operator_id
       , t.par_originating_server
       , t.returncode
    FROM aws_sqlserver_ext.sp_verify_job(
         par_job_id /* NULL::integer */
       , par_job_name
       , par_enabled
       , par_start_step_id
       , par_category_name
       , var_owner_sid /* par_owner_sid */
       , par_notify_level_eventlog
       , par_notify_level_email
       , par_notify_level_netsend
       , par_notify_level_page
       , par_notify_email_operator_name
       , par_notify_netsend_operator_name
       , par_notify_page_operator_name
       , par_delete_level
       , par_category_id
       , var_notify_email_operator_id /* par_notify_email_operator_id */
       , var_notify_netsend_operator_id /* par_notify_netsend_operator_id */
       , var_notify_page_operator_id /* par_notify_page_operator_id */
       , par_originating_server
       ) t
    INTO var_owner_sid
       , par_notify_level_email
       , par_notify_level_netsend
       , par_notify_level_page
       , par_category_id
       , var_notify_email_operator_id
       , var_notify_netsend_operator_id
       , var_notify_page_operator_id
       , par_originating_server
       , var_retval;

  IF (var_retval <> 0)  /* Failure */
  THEN
    returncode := 1;
    RETURN;
  END IF;

  var_notify_email_operator_name := par_notify_email_operator_name;

  /* Default the description (if not supplied) */
  IF (par_description IS NULL) 
  THEN
    SELECT 'No description available.' INTO par_description;
  END IF;
  
  var_originating_server_id := 0;
  var_owner_sid := '';
    
  INSERT 
    INTO aws_sqlserver_ext.sysjobs (
         originating_server_id
       , name
       , enabled
       , description
       , start_step_id
       , category_id
       , owner_sid
       , notify_level_eventlog
       , notify_level_email
       , notify_level_netsend
       , notify_level_page
       , notify_email_operator_id
       , notify_email_operator_name
       , notify_netsend_operator_id
       , notify_page_operator_id
       , delete_level
       , version_number
    )
  VALUES (
         var_originating_server_id
       , par_job_name
       , par_enabled
       , par_description
       , par_start_step_id
       , par_category_id
       , var_owner_sid
       , par_notify_level_eventlog
       , par_notify_level_email
       , par_notify_level_netsend
       , par_notify_level_page
       , var_notify_email_operator_id
       , var_notify_email_operator_name
       , var_notify_netsend_operator_id
       , var_notify_page_operator_id
       , par_delete_level
       , 1);
  
  /* scope_identity() */
  SELECT LASTVAL() INTO par_job_id;
       
  /* Version number 1 */
  /* SELECT @retval = @@error */
  /* 0 means success */
  returncode := var_retval;
  RETURN;
    
END;
]]></complex-attribute>
                        <category _I_D="80561079-d669-4803-a287-f93d6d90b1b4" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="7ea4e94d-feb3-4541-9054-1fa0df316436" name="sp_add_jobschedule" function-id="16608" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sp_add_jobschedule" is-aggregate="f" language-name="plpgsql" context="sp_add_jobschedule" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="record" count-arguments="17" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_add_jobschedule(par_job_id integer, par_job_name character varying, par_name character varying, par_enabled smallint, par_freq_type integer, par_freq_interval integer, par_freq_subday_type integer, par_freq_subday_interval integer, par_freq_relative_interval integer, par_freq_recurrence_factor integer, par_active_start_date integer, par_active_end_date integer, par_active_start_time integer, par_active_end_time integer, INOUT par_schedule_id integer, par_automatic_post smallint, INOUT par_schedule_uid character, OUT returncode integer)" arguments-datatypes="integer,character varying,character varying,smallint,integer,integer,integer,integer,integer,integer,integer,integer,integer,integer,integer,smallint,character,integer" function-arguments="par_job_id integer DEFAULT NULL::integer, par_job_name character varying DEFAULT NULL::character varying, par_name character varying DEFAULT NULL::character varying, par_enabled smallint DEFAULT 1, par_freq_type integer DEFAULT 1, par_freq_interval integer DEFAULT 0, par_freq_subday_type integer DEFAULT 0, par_freq_subday_interval integer DEFAULT 0, par_freq_relative_interval integer DEFAULT 0, par_freq_recurrence_factor integer DEFAULT 0, par_active_start_date integer DEFAULT 20000101, par_active_end_date integer DEFAULT 99991231, par_active_start_time integer DEFAULT 0, par_active_end_time integer DEFAULT 235959, INOUT par_schedule_id integer DEFAULT NULL::integer, par_automatic_post smallint DEFAULT 1, INOUT par_schedule_uid character DEFAULT NULL::bpchar, OUT returncode integer" function-identity-arguments="par_job_id integer, par_job_name character varying, par_name character varying, par_enabled smallint, par_freq_type integer, par_freq_interval integer, par_freq_subday_type integer, par_freq_subday_interval integer, par_freq_relative_interval integer, par_freq_recurrence_factor integer, par_active_start_date integer, par_active_end_date integer, par_active_start_time integer, par_active_end_time integer, INOUT par_schedule_id integer, par_automatic_post smallint, INOUT par_schedule_uid character, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_retval INT;
  var_owner_login_name VARCHAR(128);
BEGIN

  -- Check that we can uniquely identify the job
  SELECT t.par_job_name
       , t.par_job_id
       , t.returncode
    FROM aws_sqlserver_ext.sp_verify_job_identifiers (
         '@job_name'
       , '@job_id'
       , par_job_name
       , par_job_id
       , 'TEST'::character varying
       , NULL::bpchar
       ) t
    INTO par_job_name
       , par_job_id
       , var_retval;
  
  IF (var_retval <> 0) 
  THEN /* Failure */
    returncode := 1;
    RETURN;
  END IF;  

  /* Add the schedule first */
  SELECT t.par_schedule_uid
       , t.par_schedule_id
       , t.returncode
    FROM aws_sqlserver_ext.sp_add_schedule(
         par_name
       , par_enabled
       , par_freq_type
       , par_freq_interval
       , par_freq_subday_type
       , par_freq_subday_interval
       , par_freq_relative_interval
       , par_freq_recurrence_factor
       , par_active_start_date
       , par_active_end_date
       , par_active_start_time
       , par_active_end_time
       , var_owner_login_name
       , par_schedule_uid
       , par_schedule_id
       , NULL
       ) t
    INTO par_schedule_uid
       , par_schedule_id
       , var_retval;

  IF (var_retval <> 0) THEN /* Failure */
    returncode := 1;
    RETURN;
  END IF;
    
  SELECT t.returncode
    FROM aws_sqlserver_ext.sp_attach_schedule(
         par_job_id := par_job_id
       , par_job_name := NULL
       , par_schedule_id := par_schedule_id
       , par_schedule_name := NULL
       , par_automatic_post := par_automatic_post
       ) t
    INTO var_retval;

  IF (var_retval <> 0) THEN /* Failure */
    returncode := 1;
    RETURN;
  END IF;
    
  SELECT t.returncode 
    FROM aws_sqlserver_ext.sp_aws_add_jobschedule(par_job_id, par_schedule_id) t
    INTO var_retval;  

  IF (var_retval <> 0) THEN /* Failure */
    returncode := 1;
    RETURN;
  END IF;

  /* 0 means success */
  returncode := (var_retval);
  RETURN;
END;
]]></complex-attribute>
                        <category _I_D="92a30d1a-7c2f-48b0-903b-5ab41d2760e3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="37899601-dc82-4fb5-8d2e-12cbc0907ea9" name="sp_add_jobstep" function-id="16611" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sp_add_jobstep" is-aggregate="f" language-name="plpgsql" context="sp_add_jobstep" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="record" count-arguments="23" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_add_jobstep(par_job_id integer, par_job_name character varying, par_step_id integer, par_step_name character varying, par_subsystem character varying, par_command text, par_additional_parameters text, par_cmdexec_success_code integer, par_on_success_action smallint, par_on_success_step_id integer, par_on_fail_action smallint, par_on_fail_step_id integer, par_server character varying, par_database_name character varying, par_database_user_name character varying, par_retry_attempts integer, par_retry_interval integer, par_os_run_priority integer, par_output_file_name character varying, par_flags integer, par_proxy_id integer, par_proxy_name character varying, INOUT par_step_uid character, OUT returncode integer)" arguments-datatypes="integer,character varying,integer,character varying,character varying,text,text,integer,smallint,integer,smallint,integer,character varying,character varying,character varying,integer,integer,integer,character varying,integer,integer,character varying,character,integer" function-arguments="par_job_id integer DEFAULT NULL::integer, par_job_name character varying DEFAULT NULL::character varying, par_step_id integer DEFAULT NULL::integer, par_step_name character varying DEFAULT NULL::character varying, par_subsystem character varying DEFAULT 'TSQL'::bpchar, par_command text DEFAULT NULL::text, par_additional_parameters text DEFAULT NULL::text, par_cmdexec_success_code integer DEFAULT 0, par_on_success_action smallint DEFAULT 1, par_on_success_step_id integer DEFAULT 0, par_on_fail_action smallint DEFAULT 2, par_on_fail_step_id integer DEFAULT 0, par_server character varying DEFAULT NULL::character varying, par_database_name character varying DEFAULT NULL::character varying, par_database_user_name character varying DEFAULT NULL::character varying, par_retry_attempts integer DEFAULT 0, par_retry_interval integer DEFAULT 0, par_os_run_priority integer DEFAULT 0, par_output_file_name character varying DEFAULT NULL::character varying, par_flags integer DEFAULT 0, par_proxy_id integer DEFAULT NULL::integer, par_proxy_name character varying DEFAULT NULL::character varying, INOUT par_step_uid character DEFAULT NULL::bpchar, OUT returncode integer" function-identity-arguments="par_job_id integer, par_job_name character varying, par_step_id integer, par_step_name character varying, par_subsystem character varying, par_command text, par_additional_parameters text, par_cmdexec_success_code integer, par_on_success_action smallint, par_on_success_step_id integer, par_on_fail_action smallint, par_on_fail_step_id integer, par_server character varying, par_database_name character varying, par_database_user_name character varying, par_retry_attempts integer, par_retry_interval integer, par_os_run_priority integer, par_output_file_name character varying, par_flags integer, par_proxy_id integer, par_proxy_name character varying, INOUT par_step_uid character, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_retval INT;
  var_max_step_id INT;
  var_step_id INT;
BEGIN

  SELECT t.par_job_name
       , t.par_job_id
       , t.returncode
    FROM aws_sqlserver_ext.sp_verify_job_identifiers (
         '@job_name'
       , '@job_id'
       , par_job_name
       , par_job_id
       , 'TEST'::character varying
       , NULL::bpchar
       ) t
    INTO par_job_name
       , par_job_id
       , var_retval;
  
  IF (var_retval <> 0) THEN
    returncode := 1;
    RETURN;
  END IF;  
    
  -- Default step id (if not supplied)
  IF (par_step_id IS NULL) 
  THEN
     SELECT COALESCE(MAX(step_id), 0) + 1
        INTO var_step_id
       FROM aws_sqlserver_ext.sysjobsteps
      WHERE (job_id = par_job_id);
  ELSE 
    var_step_id := par_step_id; 
  END IF;

  -- Get current maximum step id    
  SELECT COALESCE(MAX(step_id), 0)
    INTO var_max_step_id
    FROM aws_sqlserver_ext.sysjobsteps
   WHERE (job_id = par_job_id);

  /* Check parameters */
  SELECT t.returncode
    FROM aws_sqlserver_ext.sp_verify_jobstep(
         par_job_id
       , var_step_id --par_step_id
       , par_step_name
       , par_subsystem
       , par_command
       , par_server
       , par_on_success_action
       , par_on_success_step_id
       , par_on_fail_action
       , par_on_fail_step_id
       , par_os_run_priority
       , par_flags
       , par_output_file_name
       , par_proxy_id
    ) t
    INTO var_retval;

  IF (var_retval <> 0) 
  THEN /* Failure */
    returncode := 1;
    RETURN;
  END IF;
    
  /* Modify database. */
  /* Update the job's version/last-modified information */
  UPDATE aws_sqlserver_ext.sysjobs
     SET version_number = version_number + 1
       --, date_modified = GETDATE() 
   WHERE (job_id = par_job_id);
   
  /* Adjust step id's (unless the new step is being inserted at the 'end') */
  /* NOTE: We MUST do this before inserting the step. */
  IF (var_step_id <= var_max_step_id) 
  THEN
    UPDATE aws_sqlserver_ext.sysjobsteps
       SET step_id = step_id + 1
     WHERE (step_id >= var_step_id) AND (job_id = par_job_id);
     
    /* Clean up OnSuccess/OnFail references */
    UPDATE aws_sqlserver_ext.sysjobsteps
       SET on_success_step_id = on_success_step_id + 1
     WHERE (on_success_step_id >= var_step_id) AND (job_id = par_job_id);
     
    UPDATE aws_sqlserver_ext.sysjobsteps
       SET on_fail_step_id = on_fail_step_id + 1
     WHERE (on_fail_step_id >= var_step_id) AND (job_id = par_job_id);
     
    UPDATE aws_sqlserver_ext.sysjobsteps
       SET on_success_step_id = 0
         , on_success_action = 1 /* Quit With Success */
     WHERE (on_success_step_id = var_step_id) 
       AND (job_id = par_job_id);
       
    UPDATE aws_sqlserver_ext.sysjobsteps
       SET on_fail_step_id = 0
         , on_fail_action = 2 /* Quit With Failure */
     WHERE (on_fail_step_id = var_step_id) 
       AND (job_id = par_job_id);
  END IF;

  /* uuid without extensions uuid-ossp (cheat) */
  SELECT uuid_in(md5(random()::text || clock_timestamp()::text)::cstring) INTO par_step_uid;
  
  /* Insert the step */
  INSERT 
    INTO aws_sqlserver_ext.sysjobsteps (
         job_id
       , step_id
       , step_name
       , subsystem
       , command
       , flags
       , additional_parameters
       , cmdexec_success_code
       , on_success_action
       , on_success_step_id
       , on_fail_action
       , on_fail_step_id
       , server
       , database_name
       , database_user_name
       , retry_attempts
       , retry_interval
       , os_run_priority
       , output_file_name
       , last_run_outcome
       , last_run_duration
       , last_run_retries
       , last_run_date
       , last_run_time
       , proxy_id
       , step_uid
   )
  VALUES (
         par_job_id
       , var_step_id
       , par_step_name
       , par_subsystem
       , par_command
       , par_flags
       , par_additional_parameters
       , par_cmdexec_success_code
       , par_on_success_action
       , par_on_success_step_id
       , par_on_fail_action
       , par_on_fail_step_id
       , par_server
       , par_database_name
       , par_database_user_name
       , par_retry_attempts
       , par_retry_interval
       , par_os_run_priority
       , par_output_file_name
       , 0
       , 0
       , 0
       , 0
       , 0
       , par_proxy_id
       , par_step_uid
  );
  
  --PERFORM aws_sqlserver_ext.sp_jobstep_create_proc (par_step_uid);

  returncode := var_retval;
  RETURN;
END;
]]></complex-attribute>
                        <category _I_D="d15151de-6b28-4fea-92bf-6663d140ff76" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="9563270b-db58-478c-8a09-caf51e36a010" name="sp_add_schedule" function-id="16613" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sp_add_schedule" is-aggregate="f" language-name="plpgsql" context="sp_add_schedule" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="record" count-arguments="16" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_add_schedule(par_schedule_name character varying, par_enabled smallint, par_freq_type integer, par_freq_interval integer, par_freq_subday_type integer, par_freq_subday_interval integer, par_freq_relative_interval integer, par_freq_recurrence_factor integer, par_active_start_date integer, par_active_end_date integer, par_active_start_time integer, par_active_end_time integer, par_owner_login_name character varying, INOUT par_schedule_uid character, INOUT par_schedule_id integer, par_originating_server character varying, OUT returncode integer)" arguments-datatypes="character varying,smallint,integer,integer,integer,integer,integer,integer,integer,integer,integer,integer,character varying,character,integer,character varying,integer" function-arguments="par_schedule_name character varying, par_enabled smallint DEFAULT 1, par_freq_type integer DEFAULT 0, par_freq_interval integer DEFAULT 0, par_freq_subday_type integer DEFAULT 0, par_freq_subday_interval integer DEFAULT 0, par_freq_relative_interval integer DEFAULT 0, par_freq_recurrence_factor integer DEFAULT 0, par_active_start_date integer DEFAULT NULL::integer, par_active_end_date integer DEFAULT 99991231, par_active_start_time integer DEFAULT 0, par_active_end_time integer DEFAULT 235959, par_owner_login_name character varying DEFAULT NULL::character varying, INOUT par_schedule_uid character DEFAULT NULL::bpchar, INOUT par_schedule_id integer DEFAULT NULL::integer, par_originating_server character varying DEFAULT NULL::character varying, OUT returncode integer" function-identity-arguments="par_schedule_name character varying, par_enabled smallint, par_freq_type integer, par_freq_interval integer, par_freq_subday_type integer, par_freq_subday_interval integer, par_freq_relative_interval integer, par_freq_recurrence_factor integer, par_active_start_date integer, par_active_end_date integer, par_active_start_time integer, par_active_end_time integer, par_owner_login_name character varying, INOUT par_schedule_uid character, INOUT par_schedule_id integer, par_originating_server character varying, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_retval INT;
  var_owner_sid CHAR(85);
  var_orig_server_id INT;
BEGIN
  /* Remove any leading/trailing spaces from parameters */
  SELECT LTRIM(RTRIM(par_schedule_name))
       , LTRIM(RTRIM(par_owner_login_name))
       , UPPER(LTRIM(RTRIM(par_originating_server)))
       , 0
    INTO par_schedule_name
       , par_owner_login_name
       , par_originating_server
       , par_schedule_id;

  /* Check schedule (frequency and owner) parameters */
  SELECT t.par_freq_interval
       , t.par_freq_subday_type
       , t.par_freq_subday_interval
       , t.par_freq_relative_interval
       , t.par_freq_recurrence_factor
       , t.par_active_start_date
       , t.par_active_start_time
       , t.par_active_end_date
       , t.par_active_end_time
       , t.returncode
    FROM aws_sqlserver_ext.sp_verify_schedule(
         NULL::integer /* @schedule_id  -- schedule_id does not exist for the new schedule */
       , par_schedule_name /* @name */
       , par_enabled /* @enabled */
       , par_freq_type /* @freq_type */
       , par_freq_interval /* @freq_interval */
       , par_freq_subday_type /* @freq_subday_type */
       , par_freq_subday_interval /* @freq_subday_interval */
       , par_freq_relative_interval /* @freq_relative_interval */
       , par_freq_recurrence_factor /* @freq_recurrence_factor */
       , par_active_start_date /* @active_start_date */
       , par_active_start_time /* @active_start_time */
       , par_active_end_date /* @active_end_date */
       , par_active_end_time /* @active_end_time */
       , var_owner_sid
       ) t
    INTO par_freq_interval
       , par_freq_subday_type
       , par_freq_subday_interval
       , par_freq_relative_interval
       , par_freq_recurrence_factor
       , par_active_start_date
       , par_active_start_time
       , par_active_end_date
       , par_active_end_time
       , var_retval /* @owner_sid */;

  IF (var_retval <> 0) THEN /* Failure */
    returncode := 1;
        RETURN;
    END IF;

  IF (par_schedule_uid IS NULL) 
  THEN /* Assign the GUID */
    /* uuid without extensions uuid-ossp (cheat) */
    SELECT uuid_in(md5(random()::text || clock_timestamp()::text)::cstring) INTO par_schedule_uid;
  END IF;
   
  var_orig_server_id := 0;
  var_owner_sid := uuid_in(md5(random()::text || clock_timestamp()::text)::cstring);


  INSERT 
    INTO aws_sqlserver_ext.sysschedules (
         schedule_uid
       , originating_server_id
       , name
       , owner_sid
       , enabled
       , freq_type
       , freq_interval
       , freq_subday_type
       , freq_subday_interval
       , freq_relative_interval
       , freq_recurrence_factor
       , active_start_date
       , active_end_date
       , active_start_time
       , active_end_time
   )
  VALUES (
         par_schedule_uid
       , var_orig_server_id
       , par_schedule_name
       , var_owner_sid
       , par_enabled
       , par_freq_type
       , par_freq_interval
       , par_freq_subday_type
       , par_freq_subday_interval
       , par_freq_relative_interval
       , par_freq_recurrence_factor
       , par_active_start_date
       , par_active_end_date
       , par_active_start_time
       , par_active_end_time
  );

  /* ZZZ */       
  SELECT 0 /* @@ERROR, */, LASTVAL()
    INTO var_retval, par_schedule_id;
    
  /* 0 means success */    
  returncode := var_retval;
  RETURN;
END;
]]></complex-attribute>
                        <category _I_D="b6887d76-5809-4787-905d-6050a7c6d514" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5b20a2c9-4a4e-4983-8f09-97279fa12f08" name="sp_attach_schedule" function-id="16615" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sp_attach_schedule" is-aggregate="f" language-name="plpgsql" context="sp_attach_schedule" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" count-arguments="5" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_attach_schedule(par_job_id integer, par_job_name character varying, par_schedule_id integer, par_schedule_name character varying, par_automatic_post smallint, OUT returncode integer)" arguments-datatypes="integer,character varying,integer,character varying,smallint,integer" function-arguments="par_job_id integer DEFAULT NULL::integer, par_job_name character varying DEFAULT NULL::character varying, par_schedule_id integer DEFAULT NULL::integer, par_schedule_name character varying DEFAULT NULL::character varying, par_automatic_post smallint DEFAULT 1, OUT returncode integer" function-identity-arguments="par_job_id integer, par_job_name character varying, par_schedule_id integer, par_schedule_name character varying, par_automatic_post smallint, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_retval INT;
  var_sched_owner_sid CHAR(85);
  var_job_owner_sid CHAR(85);
BEGIN
  /* Check that we can uniquely identify the job */
  SELECT t.par_job_name
       , t.par_job_id
       , t.par_owner_sid
       , t.returncode
    FROM aws_sqlserver_ext.sp_verify_job_identifiers(
         '@job_name'
       , '@job_id'
       , par_job_name /* @job_name */
       , par_job_id /* @job_id */
       , 'TEST' /* @sqlagent_starting_test */
       , var_job_owner_sid) t
    INTO par_job_name
       , par_job_id
       , var_job_owner_sid
       , var_retval;

  IF (var_retval <> 0) THEN /* Failure */
    returncode := 1;
    RETURN;
  END IF;
    
  /* Check that we can uniquely identify the schedule */
  SELECT t.par_schedule_name
       , t.par_schedule_id
       , t.par_owner_sid
       --, t.par_orig_server_id
       , t.returncode
    FROM aws_sqlserver_ext.sp_verify_schedule_identifiers(
         '@schedule_name'::character varying /* @name_of_name_parameter */
       , '@schedule_id'::character varying /* @name_of_id_parameter */
       , par_schedule_name /* @schedule_name */
       , par_schedule_id /* @schedule_id */
       , var_sched_owner_sid /* @owner_sid */
       , NULL::integer /* @orig_server_id */
       , NULL::integer) t
    INTO par_schedule_name
       , par_schedule_id
       , var_sched_owner_sid
       , var_retval /* @job_id_filter */;

  IF (var_retval <> 0) THEN /* Failure */
    returncode := 1;
    RETURN;
  END IF
    
  /* If the record doesn't already exist create it */;
  IF (
    NOT EXISTS (
      SELECT 1 
        FROM aws_sqlserver_ext.sysjobschedules
       WHERE (schedule_id = par_schedule_id) 
         AND (job_id = par_job_id))) 
  THEN
    INSERT 
      INTO aws_sqlserver_ext.sysjobschedules (schedule_id, job_id)
    VALUES (par_schedule_id, par_job_id);
    
    SELECT 0 INTO var_retval; /* @@ERROR */
  END IF;


  PERFORM aws_sqlserver_ext.sp_set_next_run (par_job_id, par_schedule_id);
  
  /* 0 means success */
  returncode := var_retval;
  RETURN;
END;
]]></complex-attribute>
                        <category _I_D="cd2bd23b-58a3-4101-a920-7b744688c8d2" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="da661231-2704-42d5-8ae3-737c795f6627" name="sp_aws_add_jobschedule" function-id="16645" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sp_aws_add_jobschedule" is-aggregate="f" language-name="plpgsql" context="sp_aws_add_jobschedule" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" count-arguments="2" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_aws_add_jobschedule(par_job_id integer, par_schedule_id integer, OUT returncode integer)" arguments-datatypes="integer,integer,integer" function-arguments="par_job_id integer DEFAULT NULL::integer, par_schedule_id integer DEFAULT NULL::integer, OUT returncode integer" function-identity-arguments="par_job_id integer, par_schedule_id integer, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  proc_name_mask VARCHAR(100) DEFAULT 'aws_sqlserver_ext_data.sql_agent$job_%s_step_%s';
  var_cron_expression VARCHAR(50); 
  var_job_cmd VARCHAR(255); 
  var_schedule_name VARCHAR(255);

  var_job_name VARCHAR(128);
  var_start_step_id INTEGER;
  var_notify_level_email INTEGER;
  var_notify_email_operator_id INTEGER;
  var_notify_email_operator_name VARCHAR(128);
  notify_email_sender VARCHAR(128);
  var_delete_level INTEGER;
BEGIN

  IF (EXISTS 
    (
      SELECT 1
        FROM aws_sqlserver_ext.sysjobschedules
       WHERE schedule_id = par_schedule_id
         AND job_id = par_job_id
    )
  ) 
  THEN

    SELECT cron_expression 
      FROM aws_sqlserver_ext.sp_schedule_to_cron(par_job_id, par_schedule_id) 
      INTO var_cron_expression;
      
    SELECT name 
      FROM aws_sqlserver_ext.sysschedules
     WHERE schedule_id = par_schedule_id 
      INTO var_schedule_name;

    SELECT name
         , start_step_id
         , COALESCE(notify_level_email,0)
         , COALESCE(notify_email_operator_id,0)
         , COALESCE(notify_email_operator_name,'')
         , COALESCE(delete_level,0) 
      FROM aws_sqlserver_ext.sysjobs
     WHERE job_id = par_job_id
      INTO var_job_name
         , var_start_step_id 
         , var_notify_level_email 
         , var_notify_email_operator_id 
         , var_notify_email_operator_name 
         , var_delete_level;
  
    var_job_cmd := FORMAT(proc_name_mask, par_job_id, '1');   
    notify_email_sender := 'aws_test_email_sender@dbbest.com';
    
    PERFORM aws_sqlserver_ext.awslambda_fn
    (
      aws_sqlserver_ext.get_service_setting
      (
        'JOB',
        'LAMBDA_ARN'
      ),
      JSON_BUILD_OBJECT
      (
        'mode', 'add_job',
        'parameters', JSON_BUILD_OBJECT
        (
          'vendor', 'postgresql',
          'job_name', var_schedule_name,
          'job_frequency', var_cron_expression,
          'job_cmd', var_job_cmd,
          'notify_level_email', var_notify_level_email,
          'delete_level', var_delete_level,
          'uid', par_job_id,
          'callback', 'aws_sqlserver_ext.sp_job_log',
          'notification', JSON_BUILD_OBJECT
          (
            'notify_email_sender', notify_email_sender,
            'notify_email_recipient', var_notify_email_operator_name
          )

        )
      )
    );

    returncode := 0;

  ELSE

    returncode := 1;
    RAISE 'Job not found' USING ERRCODE := '50000';

  END IF;

END;
]]></complex-attribute>
                        <category _I_D="ed71a921-44a3-4f48-b441-3cd1f868b2fc" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="00873d38-ece7-47ca-a1b5-82c39f7a66e3" name="sp_aws_del_jobschedule" function-id="16646" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sp_aws_del_jobschedule" is-aggregate="f" language-name="plpgsql" context="sp_aws_del_jobschedule" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" count-arguments="2" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_aws_del_jobschedule(par_job_id integer, par_schedule_id integer, OUT returncode integer)" arguments-datatypes="integer,integer,integer" function-arguments="par_job_id integer DEFAULT NULL::integer, par_schedule_id integer DEFAULT NULL::integer, OUT returncode integer" function-identity-arguments="par_job_id integer, par_schedule_id integer, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_schedule_name VARCHAR(255);
BEGIN

  IF (EXISTS 
    (
        SELECT 1
          FROM aws_sqlserver_ext.sysjobschedules
        WHERE schedule_id = par_schedule_id
          AND job_id = par_job_id
    )
  )
  THEN

    SELECT name
      FROM aws_sqlserver_ext.sysschedules
     WHERE schedule_id = par_schedule_id
      INTO var_schedule_name;

    PERFORM aws_sqlserver_ext.awslambda_fn
    (
      aws_sqlserver_ext.get_service_setting
      (
        'JOB',
        'LAMBDA_ARN'
      ),
      JSON_BUILD_OBJECT
      (
        'mode', 'del_schedule',
        'parameters', JSON_BUILD_OBJECT
        (
          'schedule_name', var_schedule_name,
          'force_delete', 'TRUE'
        )
      )
    );

    returncode := 0;

  ELSE

    returncode := 1;
    RAISE 'Job not found' USING ERRCODE := '50000';

  END IF;

END;
]]></complex-attribute>
                        <category _I_D="cab90113-4504-4cb9-b2d3-1122d35115a5" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="4bc159ec-4cb2-43bf-8e71-a9e373ffdc84" name="sp_delete_job" function-id="16618" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sp_delete_job" is-aggregate="f" language-name="plpgsql" context="sp_delete_job" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" count-arguments="5" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_delete_job(par_job_id integer, par_job_name character varying, par_originating_server character varying, par_delete_history smallint, par_delete_unused_schedule smallint, OUT returncode integer)" arguments-datatypes="integer,character varying,character varying,smallint,smallint,integer" function-arguments="par_job_id integer DEFAULT NULL::integer, par_job_name character varying DEFAULT NULL::character varying, par_originating_server character varying DEFAULT NULL::character varying, par_delete_history smallint DEFAULT 1, par_delete_unused_schedule smallint DEFAULT 1, OUT returncode integer" function-identity-arguments="par_job_id integer, par_job_name character varying, par_originating_server character varying, par_delete_history smallint, par_delete_unused_schedule smallint, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_retval INT;
  var_category_id INT;
  var_job_owner_sid CHAR(85);
  var_err INT;
  var_schedule_id INT;
BEGIN
  IF ((par_job_id IS NOT NULL) OR (par_job_name IS NOT NULL)) 
  THEN
    SELECT t.par_job_name
         , t.par_job_id
         , t.par_owner_sid
         , t.returncode
      FROM aws_sqlserver_ext.sp_verify_job_identifiers(
           '@job_name'
         , '@job_id'
         , par_job_name
         , par_job_id
         , 'TEST'
         , var_job_owner_sid
         ) t
      INTO par_job_name
         , par_job_id
         , var_job_owner_sid
         , var_retval;
         
    IF (var_retval <> 0) THEN /* Failure */
      returncode := (1);
      RETURN;
    END IF;
  END IF;
  
  /* Get category to see if it is a misc. replication agent. @category_id will be */
  /* NULL if there is no @job_id. */
  
  SELECT category_id
    INTO var_category_id
    FROM aws_sqlserver_ext.sysjobs
   WHERE job_id = par_job_id;
   
  /* Do the delete (for a specific job) */
  IF (par_job_id IS NOT NULL) 
  THEN
    --CREATE TEMPORARY TABLE "#temp_schedules_to_delete" (schedule_id INT NOT NULL);
     
    -- Delete all traces of the job 
    -- BEGIN TRANSACTION 
    -- Get the schedules to delete before deleting records from sysjobschedules 



    --IF (par_delete_unused_schedule = 1) 
    --THEN
      -- ZZZ optimize 
      -- Get the list of schedules to delete 
      --INSERT INTO "#temp_schedules_to_delete"
      --SELECT DISTINCT schedule_id 
      --  FROM aws_sqlserver_ext.sysschedules
      -- WHERE schedule_id IN (SELECT schedule_id
      --                         FROM aws_sqlserver_ext.sysjobschedules
      --                         WHERE job_id = par_job_id);
      --INSERT INTO "#temp_schedules_to_delete"
      SELECT schedule_id
    	FROM aws_sqlserver_ext.sysjobschedules
       WHERE job_id = par_job_id
        INTO var_schedule_id;

    PERFORM aws_sqlserver_ext.sp_aws_del_jobschedule (par_job_id := par_job_id, par_schedule_id := var_schedule_id);  


--    END IF;


    --DELETE FROM aws_sqlserver_ext.sysschedules
    -- WHERE schedule_id IN (SELECT schedule_id FROM aws_sqlserver_ext.sysjobschedules WHERE job_id = par_job_id);
  
    DELETE FROM aws_sqlserver_ext.sysjobschedules
     WHERE job_id = par_job_id;
     
    DELETE FROM aws_sqlserver_ext.sysjobsteps
     WHERE job_id = par_job_id;
     
    DELETE FROM aws_sqlserver_ext.sysjobs
     WHERE job_id = par_job_id;
     
    SELECT 0 /* @@ERROR */ INTO var_err;
          
    /* Delete the schedule(s) if requested to and it isn't being used by other jobs */
    IF (par_delete_unused_schedule = 1) 
    THEN
      /* Now OK to delete the schedule */
      DELETE FROM aws_sqlserver_ext.sysschedules
       WHERE schedule_id = var_schedule_id; --IN (SELECT schedule_id FROM "#temp_schedules_to_delete");

      --DELETE FROM aws_sqlserver_ext.sysschedules
      -- WHERE schedule_id IN (SELECT schedule_id
      --                         FROM "#temp_schedules_to_delete" AS sdel
      --                        WHERE NOT EXISTS (SELECT *
      --                                            FROM aws_sqlserver_ext.sysjobschedules AS js
      --                                           WHERE js.schedule_id = sdel.schedule_id));
    END IF;
    
    /* Delete the job history if requested */
    IF (par_delete_history = 1)
    THEN
      DELETE FROM aws_sqlserver_ext.sysjobhistory
      WHERE job_id = par_job_id;
    END IF;

    /* All done */
    /* COMMIT TRANSACTION */
    --DROP TABLE "#temp_schedules_to_delete";
  END IF;
  
  /* 0 means success */
  returncode := 0;
  RETURN;
END;
]]></complex-attribute>
                        <category _I_D="6503e8d6-2eb1-4fc5-b96a-97b2756bdf19" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="3bfdd7be-8824-403f-a30e-474111fbe471" name="sp_delete_jobschedule" function-id="16616" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sp_delete_jobschedule" is-aggregate="f" language-name="plpgsql" context="sp_delete_jobschedule" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" count-arguments="5" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_delete_jobschedule(par_job_id integer, par_job_name character varying, par_name character varying, par_keep_schedule integer, par_automatic_post smallint, OUT returncode integer)" arguments-datatypes="integer,character varying,character varying,integer,smallint,integer" function-arguments="par_job_id integer DEFAULT NULL::integer, par_job_name character varying DEFAULT NULL::character varying, par_name character varying DEFAULT NULL::character varying, par_keep_schedule integer DEFAULT 0, par_automatic_post smallint DEFAULT 1, OUT returncode integer" function-identity-arguments="par_job_id integer, par_job_name character varying, par_name character varying, par_keep_schedule integer, par_automatic_post smallint, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_retval INT;
  var_sched_count INT;
  var_schedule_id INT;
  var_job_owner_sid CHAR(85);
BEGIN
  /* Remove any leading/trailing spaces from parameters */
  SELECT LTRIM(RTRIM(par_name)) INTO par_name;
  
  /* Check that we can uniquely identify the job */
  SELECT t.par_job_name
       , t.par_job_id
       , t.par_owner_sid
       , t.returncode
    FROM aws_sqlserver_ext.sp_verify_job_identifiers(
         '@job_name'
       , '@job_id'
       , par_job_name
       , par_job_id
       , 'TEST'
       , var_job_owner_sid
       ) t
    INTO par_job_name
       , par_job_id
       , var_job_owner_sid
       , var_retval;

  IF (var_retval <> 0) THEN /* Failure */
    returncode := 1;
    RETURN;
  END IF;
   
  IF (LOWER(UPPER(par_name)) = LOWER('ALL')) 
  THEN
    SELECT - 1 INTO var_schedule_id;
    
    /* We use this in the call to sp_sqlagent_notify */
    /* Delete the schedule(s) if it isn't being used by other jobs */
    CREATE TEMPORARY TABLE "#temp_schedules_to_delete" (schedule_id INT NOT NULL)
    /* If user requests that the schedules be removed (the legacy behavoir) */
    /* make sure it isnt being used by other jobs */;

    IF (par_keep_schedule = 0) 
    THEN
      /* Get the list of schedules to delete */
      INSERT INTO "#temp_schedules_to_delete"
      SELECT DISTINCT schedule_id
        FROM aws_sqlserver_ext.sysschedules
       WHERE (schedule_id IN (SELECT schedule_id
                                FROM aws_sqlserver_ext.sysjobschedules
                               WHERE (job_id = par_job_id)));
      /* make sure no other jobs use these schedules */
      IF (EXISTS (SELECT *
                    FROM aws_sqlserver_ext.sysjobschedules
                   WHERE (job_id <> par_job_id) 
                     AND (schedule_id IN (SELECT schedule_id
                                            FROM "#temp_schedules_to_delete")))) 
      THEN /* Failure */
        RAISE 'One or more schedules were not deleted because they are being used by at least one other job. Use "sp_detach_schedule" to remove schedules from a job.' USING ERRCODE := '50000';
        returncode := 1;
        RETURN;
      END IF;
    END IF;
    
    /* OK to delete the jobschedule */
    DELETE FROM aws_sqlserver_ext.sysjobschedules
     WHERE (job_id = par_job_id);
     
    /* OK to delete the schedule - temp_schedules_to_delete is empty if @keep_schedule <> 0 */
    DELETE FROM aws_sqlserver_ext.sysschedules
     WHERE schedule_id IN (SELECT schedule_id FROM "#temp_schedules_to_delete");
  ELSE ---- IF (LOWER(UPPER(par_name)) = LOWER('ALL')) 

    -- Need to use sp_detach_schedule to remove this ambiguous schedule name
    IF(var_sched_count > 1) /* Failure */
    THEN
      RAISE 'More than one schedule named "%" is attached to job "%". Use "sp_detach_schedule" to remove schedules from a job.', par_name, par_job_name  USING ERRCODE := '50000';
      returncode := 1;
      RETURN;
    END IF;

    --If user requests that the schedule be removed (the legacy behavoir)
    --make sure it isnt being used by another job
    IF (par_keep_schedule = 0)
    THEN
      IF(EXISTS(SELECT *
                  FROM aws_sqlserver_ext.sysjobschedules
                 WHERE (schedule_id = var_schedule_id)
                   AND (job_id <> par_job_id)))
      THEN /* Failure */
        RAISE 'Schedule "%" was not deleted because it is being used by at least one other job. Use "sp_detach_schedule" to remove schedules from a job.', par_name USING ERRCODE := '50000';
        returncode := 1;
        RETURN;
      END IF;
    END IF;

    /* Delete the job schedule link first */
    DELETE FROM aws_sqlserver_ext.sysjobschedules
     WHERE (job_id = par_job_id) 
       AND (schedule_id = var_schedule_id);
       
    /* Delete schedule if required */
    IF (par_keep_schedule = 0) 
    THEN
      /* Now delete the schedule if required */
      DELETE FROM aws_sqlserver_ext.sysschedules
       WHERE (schedule_id = var_schedule_id);
    END IF;

    SELECT t.returncode 
    FROM aws_sqlserver_ext.sp_aws_del_jobschedule(par_job_id, var_schedule_id) t
    INTO var_retval;  
	

  END IF;
  
  /* Update the job's version/last-modified information */
  UPDATE aws_sqlserver_ext.sysjobs
     SET version_number = version_number + 1
       -- , date_modified = GETDATE() /
   WHERE job_id = par_job_id;

  DROP TABLE IF EXISTS "#temp_schedules_to_delete";
 
   
  /* 0 means success */ 
  returncode := var_retval;
  RETURN;
END;
]]></complex-attribute>
                        <category _I_D="00174415-a59d-4988-86a6-e979491d8471" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a5e67f3b-6bc7-4855-b6b4-29b296d6262e" name="sp_delete_jobstep" function-id="16619" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sp_delete_jobstep" is-aggregate="f" language-name="plpgsql" context="sp_delete_jobstep" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" count-arguments="3" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_delete_jobstep(par_job_id integer, par_job_name character varying, par_step_id integer, OUT returncode integer)" arguments-datatypes="integer,character varying,integer,integer" function-arguments="par_job_id integer DEFAULT NULL::integer, par_job_name character varying DEFAULT NULL::character varying, par_step_id integer DEFAULT NULL::integer, OUT returncode integer" function-identity-arguments="par_job_id integer, par_job_name character varying, par_step_id integer, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_retval INT;
  var_max_step_id INT;
  var_valid_range VARCHAR(50);
  var_job_owner_sid CHAR(85);
BEGIN
  SELECT t.par_job_name
       , t.par_job_id
       , t.par_owner_sid
       , t.returncode
    FROM aws_sqlserver_ext.sp_verify_job_identifiers(
         '@job_name'
       , '@job_id'
       , par_job_name
       , par_job_id
       , 'TEST'
       , var_job_owner_sid
       ) t
    INTO par_job_name
       , par_job_id
       , var_job_owner_sid
       , var_retval;

  IF (var_retval <> 0) THEN /* Failure */
    returncode := 1;
    RETURN;
  END IF;
    
  /* Get current maximum step id */
  SELECT COALESCE(MAX(step_id), 0)
    INTO var_max_step_id
    FROM aws_sqlserver_ext.sysjobsteps
   WHERE (job_id = par_job_id);
    
  /* Check step id */
  IF (par_step_id < 0) OR (par_step_id > var_max_step_id) 
  THEN
    SELECT CONCAT('0 (all steps) ..', CAST (var_max_step_id AS VARCHAR(1)))
      INTO var_valid_range;
     RAISE 'The specified "%" is invalid (valid values are: %).', 'step_id', var_valid_range USING ERRCODE := '50000';
     returncode := 1;
     RETURN;
        /* Failure */
    END IF;
    
    /* BEGIN TRANSACTION */
    /* Delete either the specified step or ALL the steps (if step id is 0) */
    IF (par_step_id = 0) 
    THEN
      DELETE FROM aws_sqlserver_ext.sysjobsteps
       WHERE (job_id = par_job_id);
    ELSE
      DELETE FROM aws_sqlserver_ext.sysjobsteps
       WHERE (job_id = par_job_id) AND (step_id = par_step_id);
    END IF;

    IF (par_step_id <> 0) 
    THEN
      /* Adjust step id's */
      UPDATE aws_sqlserver_ext.sysjobsteps
         SET step_id = step_id - 1
       WHERE (step_id > par_step_id) 
         AND (job_id = par_job_id);
         
      /* Clean up OnSuccess/OnFail references */
      UPDATE aws_sqlserver_ext.sysjobsteps
         SET on_success_step_id = on_success_step_id - 1
       WHERE (on_success_step_id > par_step_id) AND (job_id = par_job_id);
       
      UPDATE aws_sqlserver_ext.sysjobsteps
         SET on_fail_step_id = on_fail_step_id - 1
       WHERE (on_fail_step_id > par_step_id) AND (job_id = par_job_id);
       
      /* Quit With Success */        
      UPDATE aws_sqlserver_ext.sysjobsteps 
         SET on_success_step_id = 0
           , on_success_action = 1 
       WHERE (on_success_step_id = par_step_id) 
         AND (job_id = par_job_id);
        
      /* Quit With Failure */
      UPDATE aws_sqlserver_ext.sysjobsteps
         SET on_fail_step_id = 0
           , on_fail_action = 2
       WHERE (on_fail_step_id = par_step_id) AND (job_id = par_job_id);
    END IF;
    
    /* Update the job's version/last-modified information */
    UPDATE aws_sqlserver_ext.sysjobs
       SET version_number = version_number + 1
         --, date_modified = GETDATE() /
     WHERE (job_id = par_job_id);
     
    /* COMMIT TRANSACTION */
    
    /* Success */
    returncode := 0;
    RETURN;
END;
]]></complex-attribute>
                        <category _I_D="00e101f8-2dc2-46eb-81bf-c53456db2234" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f8deab06-ab42-42de-93e1-c693bc26cd50" name="sp_delete_schedule" function-id="16620" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sp_delete_schedule" is-aggregate="f" language-name="plpgsql" context="sp_delete_schedule" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" count-arguments="4" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_delete_schedule(par_schedule_id integer, par_schedule_name character varying, par_force_delete smallint, par_automatic_post smallint, OUT returncode integer)" arguments-datatypes="integer,character varying,smallint,smallint,integer" function-arguments="par_schedule_id integer DEFAULT NULL::integer, par_schedule_name character varying DEFAULT NULL::character varying, par_force_delete smallint DEFAULT 0, par_automatic_post smallint DEFAULT 1, OUT returncode integer" function-identity-arguments="par_schedule_id integer, par_schedule_name character varying, par_force_delete smallint, par_automatic_post smallint, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_retval INT;
  var_job_count INT;
BEGIN
  /* check if there are jobs using this schedule */
  SELECT COUNT(*)
    INTO var_job_count
    FROM aws_sqlserver_ext.sysjobschedules
   WHERE (schedule_id = par_schedule_id);
   
  /* If we aren't force deleting the schedule make sure no jobs are using it */
  IF ((par_force_delete = 0) AND (var_job_count > 0)) 
  THEN /* Failure */
    RAISE 'The schedule was not deleted because it is being used by one or more jobs.' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;
  
  /* OK to delete the job - schedule link */
  DELETE FROM aws_sqlserver_ext.sysjobschedules
   WHERE schedule_id = par_schedule_id;
   
  /* OK to delete the schedule */
  DELETE FROM aws_sqlserver_ext.sysschedules
   WHERE schedule_id = par_schedule_id;
   
  /* 0 means success */
  returncode := var_retval;
  RETURN;
END;
]]></complex-attribute>
                        <category _I_D="74d877a8-d7a1-4339-861a-a4765ecb49e5" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="dde7c732-63cb-4e81-ae25-ba52171dc9a1" name="sp_detach_schedule" function-id="16621" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sp_detach_schedule" is-aggregate="f" language-name="plpgsql" context="sp_detach_schedule" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" count-arguments="6" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_detach_schedule(par_job_id integer, par_job_name character varying, par_schedule_id integer, par_schedule_name character varying, par_delete_unused_schedule smallint, par_automatic_post smallint, OUT returncode integer)" arguments-datatypes="integer,character varying,integer,character varying,smallint,smallint,integer" function-arguments="par_job_id integer DEFAULT NULL::integer, par_job_name character varying DEFAULT NULL::character varying, par_schedule_id integer DEFAULT NULL::integer, par_schedule_name character varying DEFAULT NULL::character varying, par_delete_unused_schedule smallint DEFAULT 0, par_automatic_post smallint DEFAULT 1, OUT returncode integer" function-identity-arguments="par_job_id integer, par_job_name character varying, par_schedule_id integer, par_schedule_name character varying, par_delete_unused_schedule smallint, par_automatic_post smallint, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_retval INT;
  var_sched_owner_sid CHAR(85);
  var_job_owner_sid CHAR(85);
BEGIN
  /* Check that we can uniquely identify the job */
  SELECT t.par_job_name
       , t.par_job_id
       , t.par_owner_sid
       , t.returncode
    FROM aws_sqlserver_ext.sp_verify_job_identifiers(
         '@job_name'
       , '@job_id'
       , par_job_name
       , par_job_id
       , 'TEST'
       , var_job_owner_sid
       ) t
    INTO par_job_name
       , par_job_id
       , var_job_owner_sid
       , var_retval;

  IF (var_retval <> 0) THEN /* Failure */
    returncode := 1;
    RETURN;
  END IF;
    
  /* Check that we can uniquely identify the schedule */
  SELECT t.par_schedule_name
       , t.par_schedule_id
       , t.par_owner_sid
       , t.par_orig_server_id
       , t.returncode
    FROM aws_sqlserver_ext.sp_verify_schedule_identifiers(
         '@schedule_name' /* @name_of_name_parameter */
       , '@schedule_id' /* @name_of_id_parameter */
       , par_schedule_name /* @schedule_name */
       , par_schedule_id /* @schedule_id */
       , var_sched_owner_sid /* @owner_sid */
       , NULL /* @orig_server_id */
       , par_job_id
       ) t
    INTO par_schedule_name
       , par_schedule_id
       , var_sched_owner_sid
       , var_retval;
       -- job_id_filter

  IF (var_retval <> 0) THEN /* Failure */
    returncode := 1;
    RETURN;
  END IF;
    
  /* If the record doesn't exist raise an error */
  IF (NOT EXISTS (
    SELECT * 
      FROM aws_sqlserver_ext.sysjobschedules
     WHERE (schedule_id = par_schedule_id) 
       AND (job_id = par_job_id))) 
  THEN /* Failure */
    RAISE 'The specified schedule name "%s" is not associated with the job "%s".', par_schedule_name, par_job_name USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;
  
  SELECT t.returncode 
    FROM aws_sqlserver_ext.sp_aws_del_jobschedule(par_job_id, par_schedule_id) t
    INTO var_retval;  

  DELETE FROM aws_sqlserver_ext.sysjobschedules
   WHERE (job_id = par_job_id) 
     AND (schedule_id = par_schedule_id);
     
  SELECT /* @@ERROR */ 0 -- ZZZ
    INTO var_retval;
    
  /* delete the schedule if requested and it isn't referenced */
  IF (var_retval = 0 AND par_delete_unused_schedule = 1) 
  THEN
    IF (NOT EXISTS (
      SELECT * 
        FROM aws_sqlserver_ext.sysjobschedules
       WHERE (schedule_id = par_schedule_id))) 
    THEN
      DELETE FROM aws_sqlserver_ext.sysschedules
       WHERE (schedule_id = par_schedule_id);
    END IF;
  END IF;
  
  /* Update the job's version/last-modified information */
  /* 
  UPDATE aws_sqlserver_ext.sysjobs
     SET version_number = version_number + 1
       -- , date_modified = GETDATE()
   WHERE (job_id = par_job_id); 
  */

  -- PERFORM aws_sqlserver_ext.sp_delete_job (par_job_id := par_job_id);  

  /* 0 means success */   
  returncode := var_retval;
  RETURN;
END;
]]></complex-attribute>
                        <category _I_D="e3658182-43d3-47e2-84f1-05c5ae7abcd3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="42bc412a-946e-4ac9-8c6d-f80b8cd84b69" name="sp_get_dbmail" function-id="16622" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sp_get_dbmail" is-aggregate="f" language-name="plpgsql" context="sp_get_dbmail" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="record" count-arguments="0" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_get_dbmail(OUT par_mail_id integer, OUT par_mail_data text)" arguments-datatypes="integer,text" function-arguments="OUT par_mail_id integer, OUT par_mail_data text" function-identity-arguments="OUT par_mail_id integer, OUT par_mail_data text">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_mailitem_id INTEGER;
  var_xml TEXT;
  var_rc INTEGER;
BEGIN

  SELECT mailitem_id
    INTO var_mailitem_id
    FROM aws_sqlserver_ext.sysmail_mailitems
   WHERE sent_status = 0
   ORDER BY mailitem_id ASC
   LIMIT 1;

  IF var_mailitem_id IS NULL THEN

    RAISE 'E-mail messages are missing.' USING ERRCODE := '50000';

    RETURN;

  END IF;

  UPDATE aws_sqlserver_ext.sysmail_mailitems
     SET sent_status = 1
   WHERE mailitem_id = var_mailitem_id;

  SELECT t.par_mail_data,
    t.returncode
  INTO var_xml, var_rc
  FROM aws_sqlserver_ext.sysmail_dbmail_json(var_mailitem_id) t; 

  IF var_rc <> 0 THEN

    RETURN;

  END IF;

  par_mail_id := var_mailitem_id;
  par_mail_data := var_xml;

END;
]]></complex-attribute>
                        <category _I_D="2d786d68-7013-483b-b540-5791b8c1094e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="4908c788-b158-4a1d-a760-0ba04c2ee700" name="sp_job_log" function-id="16672" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sp_job_log" is-aggregate="f" language-name="plpgsql" context="sp_job_log" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" count-arguments="3" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_job_log(pid integer, pstatus integer, pmessage character varying)" arguments-datatypes="integer,integer,character varying" function-arguments="pid integer, pstatus integer, pmessage character varying" function-identity-arguments="pid integer, pstatus integer, pmessage character varying">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
  PERFORM aws_sqlserver_ext.update_job (pid, pmessage);

  -- INSERT INTO ms_test.jobs_log(id, t, status, message)
  -- VALUES (pid, CURRENT_TIMESTAMP, pstatus, pmessage);
END;
]]></complex-attribute>
                        <category _I_D="5a4fcc3d-8f2b-4ef8-8463-e6cf656748ec" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8a961584-6874-402b-bce1-30075b88cfab" name="sp_schedule_to_cron" function-id="16628" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sp_schedule_to_cron" is-aggregate="f" language-name="plpgsql" context="sp_schedule_to_cron" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="varchar" count-arguments="2" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_schedule_to_cron(par_job_id integer, par_schedule_id integer, OUT cron_expression character varying)" arguments-datatypes="integer,integer,character varying" function-arguments="par_job_id integer, par_schedule_id integer, OUT cron_expression character varying" function-identity-arguments="par_job_id integer, par_schedule_id integer, OUT cron_expression character varying">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_enabled INTEGER;
  var_freq_type INTEGER;
  var_freq_interval INTEGER;
  var_freq_subday_type INTEGER;
  var_freq_subday_interval INTEGER;
  var_freq_relative_interval INTEGER;
  var_freq_recurrence_factor INTEGER;
  var_active_start_date INTEGER;
  var_active_end_date INTEGER;
  var_active_start_time INTEGER;
  var_active_end_time INTEGER;

  var_next_run_date date;
  var_next_run_time time;
  var_next_run_dt timestamp;

  var_tmp_interval varchar(50);
  var_current_dt timestamp;
  var_next_dt timestamp;
BEGIN

  SELECT enabled
       , freq_type
       , freq_interval
       , freq_subday_type
       , freq_subday_interval
       , freq_relative_interval
       , freq_recurrence_factor
       , active_start_date
       , active_end_date
       , active_start_time
       , active_end_time
    FROM aws_sqlserver_ext.sysschedules
    INTO var_enabled
       , var_freq_type
       , var_freq_interval
       , var_freq_subday_type
       , var_freq_subday_interval
       , var_freq_relative_interval
       , var_freq_recurrence_factor
       , var_active_start_date
       , var_active_end_date
       , var_active_start_time
       , var_active_end_time
   WHERE schedule_id = par_schedule_id;

  /* if enabled = 0 return */
  CASE var_freq_type
    WHEN 1 THEN
      NULL;

    WHEN 4 THEN
    BEGIN
        cron_expression :=
        CASE
          /* WHEN var_freq_subday_type = 1 THEN var_freq_subday_interval::character varying || ' At the specified time'  -- start time */
          /* WHEN var_freq_subday_type = 2 THEN var_freq_subday_interval::character varying || ' second'  -- ADD var_freq_subday_interval SECOND */
          WHEN var_freq_subday_type = 4 THEN format('cron(*/%s * * * ? *)', var_freq_subday_interval::character varying) /* ADD var_freq_subday_interval MINUTE */
          WHEN var_freq_subday_type = 8 THEN format('cron(0 */%s * * ? *)', var_freq_subday_interval::character varying) /* ADD var_freq_subday_interval HOUR */
          ELSE ''
        END;
    END;

    WHEN 8 THEN
      NULL;

    WHEN 16 THEN
      NULL;

    WHEN 32 THEN
      NULL;

    WHEN 64 THEN
      NULL;

    WHEN 128 THEN
     NULL;
     
  END CASE;

 -- return cron_expression;

END;
]]></complex-attribute>
                        <category _I_D="08270003-de5b-453c-8a2b-909ea7c5b038" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="242fc649-cf8c-4e09-891e-04f3856e366c" name="sp_send_dbmail" function-id="16623" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sp_send_dbmail" is-aggregate="f" language-name="plpgsql" context="sp_send_dbmail" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="record" count-arguments="23" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_send_dbmail(par_profile_name character varying, par_recipients text, par_copy_recipients text, par_blind_copy_recipients text, par_subject character varying, par_body text, par_body_format character varying, par_importance character varying, par_sensitivity character varying, par_file_attachments text, par_query text, par_execute_query_database character varying, par_attach_query_result_as_file smallint, par_query_attachment_filename character varying, par_query_result_header smallint, par_query_result_width integer, par_query_result_separator character varying, par_exclude_query_output smallint, par_append_query_error smallint, par_query_no_truncate smallint, par_query_result_no_padding smallint, OUT par_mailitem_id integer, par_from_address text, par_reply_to text, OUT returncode integer)" arguments-datatypes="character varying,text,text,text,character varying,text,character varying,character varying,character varying,text,text,character varying,smallint,character varying,smallint,integer,character varying,smallint,smallint,smallint,smallint,integer,text,text,integer" function-arguments="par_profile_name character varying DEFAULT NULL::character varying, par_recipients text DEFAULT NULL::text, par_copy_recipients text DEFAULT NULL::text, par_blind_copy_recipients text DEFAULT NULL::text, par_subject character varying DEFAULT NULL::character varying, par_body text DEFAULT NULL::text, par_body_format character varying DEFAULT NULL::character varying, par_importance character varying DEFAULT 'NORMAL'::character varying, par_sensitivity character varying DEFAULT 'NORMAL'::character varying, par_file_attachments text DEFAULT NULL::text, par_query text DEFAULT NULL::text, par_execute_query_database character varying DEFAULT NULL::character varying, par_attach_query_result_as_file smallint DEFAULT 0, par_query_attachment_filename character varying DEFAULT NULL::character varying, par_query_result_header smallint DEFAULT 1, par_query_result_width integer DEFAULT 256, par_query_result_separator character varying DEFAULT ' '::character varying, par_exclude_query_output smallint DEFAULT 0, par_append_query_error smallint DEFAULT 0, par_query_no_truncate smallint DEFAULT 0, par_query_result_no_padding smallint DEFAULT 0, OUT par_mailitem_id integer, par_from_address text DEFAULT NULL::text, par_reply_to text DEFAULT NULL::text, OUT returncode integer" function-identity-arguments="par_profile_name character varying, par_recipients text, par_copy_recipients text, par_blind_copy_recipients text, par_subject character varying, par_body text, par_body_format character varying, par_importance character varying, par_sensitivity character varying, par_file_attachments text, par_query text, par_execute_query_database character varying, par_attach_query_result_as_file smallint, par_query_attachment_filename character varying, par_query_result_header smallint, par_query_result_width integer, par_query_result_separator character varying, par_exclude_query_output smallint, par_append_query_error smallint, par_query_no_truncate smallint, par_query_result_no_padding smallint, OUT par_mailitem_id integer, par_from_address text, par_reply_to text, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_profile_id INTEGER;
  var_rc INTEGER DEFAULT 0;
  var_mail_data TEXT;
  var_sent_result JSON;
  var_server_name VARCHAR(255);
BEGIN

  /* Get primary account if profile name is supplied */
  SELECT t.par_profileid, t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_profile_sp
    (
      NULL::integer,
      par_profile_name,
      0::SMALLINT,
      0::SMALLINT
    ) t
    INTO var_profile_id, var_rc;

  IF var_rc <> 0 THEN

    returncode := var_rc;
    RETURN;

  END IF;

  /* Attach results must be specified */
  IF par_attach_query_result_as_file IS NULL THEN

    RAISE 'Parameter "%" must be specified. This parameter cannot be NULL.', 'attach_query_result_as_file' USING ERRCODE := '50000';
    returncode := 2;
    RETURN;

  END IF;

  /* No output must be specified */
  IF par_exclude_query_output IS NULL THEN

    RAISE 'Parameter "%" must be specified. This parameter cannot be NULL.', 'exclude_query_output' USING ERRCODE := '50000';
    returncode := 3;
    RETURN;

  END IF;

  /* No header must be specified */
  IF par_query_result_header IS NULL THEN

    RAISE 'Parameter "%" must be specified. This parameter cannot be NULL.', 'query_result_header' USING ERRCODE := '50000';
    returncode := 4;
    RETURN;

  END IF;

  /* Check if query_result_separator is specifed */
  IF par_query_result_separator IS NULL OR LENGTH(par_query_result_separator) = 0 THEN

    RAISE 'Parameter "%" must be specified. This parameter cannot be NULL.', 'query_result_separator' USING ERRCODE := '50000';
    returncode := 5;
    RETURN;

  END IF;
  
  /* Echo error must be specified */
  IF par_append_query_error IS NULL THEN

    RAISE 'Parameter "%" must be specified. This parameter cannot be NULL.', 'append_query_error' USING ERRCODE := '50000';
    returncode := 6;
    RETURN;

  END IF;
  
  /* @body_format can be TEXT (default) or HTML */
  IF par_body_format IS NULL THEN

    par_body_format := 'TEXT';

  ELSE

    par_body_format := UPPER(par_body_format);

    IF par_body_format NOT IN ('TEXT', 'HTML') THEN

      RAISE 'Parameter mailformat does not support the value "%". The mail format must be TEXT or HTML.', par_body_format USING ERRCODE := '50000';
      returncode := 13;
      RETURN;

    END IF;
  END IF;
  
  /* Importance must be specified */
  IF par_importance IS NULL THEN

    RAISE 'Parameter "%" must be specified. This parameter cannot be NULL.', 'importance' USING ERRCODE := '50000';
    returncode := 15;
    RETURN;

  END IF;

  par_importance := UPPER(par_importance);
  
  /* Importance must be one of the predefined values */
  IF par_importance NOT IN ('LOW', 'NORMAL', 'HIGH') THEN

    RAISE 'Parameter importance does not support the value "%". Mail importance must be one of LOW, NORMAL, or HIGH.', par_importance USING ERRCODE := '50000';
    returncode := 16;
    RETURN;

  END IF;
  
  /* Sensitivity must be specified */
  IF par_sensitivity IS NULL 
  THEN
    RAISE 'Parameter "%" must be specified. This parameter cannot be NULL.', 'sensitivity' USING ERRCODE := '50000';
    returncode := 17;
    RETURN;
  END IF;
  par_sensitivity := UPPER(par_sensitivity);
  
  /* Sensitivity must be one of predefined values */
  IF par_sensitivity NOT IN ('NORMAL', 'PERSONAL', 'PRIVATE', 'CONFIDENTIAL') THEN

    RAISE 'Parameter sensitivity does not support the value "%". Mail sensitivity must be one of NORMAL, PERSONAL, PRIVATE, or CONFIDENTIAL.', par_sensitivity USING ERRCODE := '50000';
    returncode := 18;
    RETURN;

  END IF;
  
  /* Message body cannot be null. Atleast one of message, subject, query, */
  /* attachments must be specified. */
  IF (par_body IS NULL AND par_query IS NULL AND par_file_attachments IS NULL AND par_subject IS NULL)
    OR
    (
      (LENGTH(par_body) IS NULL OR LENGTH(par_body) <= 0) AND
      (LENGTH(par_query) IS NULL OR LENGTH(par_query) <= 0) AND
      (LENGTH(par_file_attachments) IS NULL OR LENGTH(par_file_attachments) <= 0) AND
      (LENGTH(par_subject) IS NULL OR LENGTH(par_subject) <= 0)
    ) THEN

    RAISE 'At least one of the following parameters must be specified. "%".', 'body, query, file_attachments, subject' USING ERRCODE := '50000';
    returncode := 19;
    RETURN;

  ELSE

    IF par_subject IS NULL OR LENGTH(par_subject) <= 0 THEN

      par_subject := 'Database Message';

    END IF;

  END IF;
  
  /* Recipients cannot be empty. Atleast one of the To, Cc, Bcc must be specified */
  IF (
    (par_recipients IS NULL AND par_copy_recipients IS NULL AND par_blind_copy_recipients IS NULL) OR
    (
      (LENGTH(par_recipients) IS NULL OR LENGTH(par_recipients) <= 0) AND
      (LENGTH(par_copy_recipients) IS NULL OR LENGTH(par_copy_recipients) <= 0) AND
      (LENGTH(par_blind_copy_recipients) IS NULL OR LENGTH(par_blind_copy_recipients) <= 0)
    )
  ) THEN

    RAISE 'At least one of the following parameters must be specified. "%".', 'recipients, copy_recipients, blind_copy_recipients' USING ERRCODE := '50000';
    returncode := 20;
    RETURN;

  END IF;

  --[sysmail_OutMailAttachmentEncodingMustBeValid] CHECK [attachment_encoding] IN ['UUENCODE', 'BINHEX', 'S/MIME', 'MIME']

  SELECT t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_addressparams_sp
    (
      par_address := par_recipients
    , par_parameter_name := 'par_recipients'
    ) t
    INTO var_rc;

  IF var_rc <> 0 THEN

    returncode := var_rc;
    RETURN;

  END IF;

  SELECT t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_addressparams_sp
    (
      par_address := par_copy_recipients
    , par_parameter_name := 'par_copy_recipients'
    ) t
    INTO var_rc;

  IF var_rc <> 0 THEN

    returncode := var_rc;
    RETURN;

  END IF;

  SELECT t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_addressparams_sp
    (
      par_address => par_blind_copy_recipients
    , par_parameter_name => 'par_blind_copy_recipients'
    ) t
    INTO var_rc;

  IF var_rc <> 0 THEN

    returncode := var_rc;
    RETURN;

  END IF;

  SELECT t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_addressparams_sp
    (
      par_address := par_reply_to
    , par_parameter_name := 'par_reply_to'
    ) t
    INTO var_rc;

  IF var_rc <> 0 THEN

    returncode := var_rc;
    RETURN;

  END IF;
  
  /* If query is not specified, attach results and no header cannot be true. */
  IF (par_query IS NULL OR LENGTH(par_query) <= 0) AND par_attach_query_result_as_file = 1 THEN

    RAISE 'Parameter [attach_query_result_as_file] cannot be 1 (true) when no value is specified for parameter [query]. A query must be specified to attach the results of the query.' USING ERRCODE := '50000';
    returncode := 21;
    RETURN;

  END IF;
  
  /* BEGIN TRAN @procName */
  /* SET @tranStartedBool = 1 */
  /* Store complete mail message for history/status purposes */
  
  INSERT 
    INTO aws_sqlserver_ext.sysmail_mailitems
    (
         profile_id
       , recipients
       , copy_recipients
       , blind_copy_recipients
       , subject
       , body
       , body_format
       , importance
       , sensitivity
       , file_attachments
       , attachment_encoding
       , query
       , execute_query_database
       , attach_query_result_as_file
       , query_result_header
       , query_result_width
       , query_result_separator
       , exclude_query_output
       , append_query_error
       , send_request_date
       , from_address
       , reply_to
    )
    VALUES
    (
         var_profile_id
       , par_recipients
       , par_copy_recipients
       , par_blind_copy_recipients
       , par_subject
       , par_body
       , par_body_format
       , par_importance
       , par_sensitivity
       , par_file_attachments
       , 'MIME'
       , par_query
       , par_execute_query_database
       , par_attach_query_result_as_file
       , par_query_result_header
       , par_query_result_width
       , par_query_result_separator
       , par_exclude_query_output
       , par_append_query_error
       , now()
       , par_from_address
       , par_reply_to
    );

  SELECT 0 /* @@ERROR, */
       , LASTVAL() /* SCOPE_IDENTITY() */
    INTO var_rc
       , par_mailitem_id;

  SELECT par_mail_data, par_server_name
  FROM aws_sqlserver_ext.sysmail_dbmail_json(par_mailitem_id)
  INTO var_mail_data, var_server_name;

  var_sent_result := aws_sqlserver_ext.awslambda_fn
  (
    var_server_name,
    var_mail_data::JSON
  );

  PERFORM aws_sqlserver_ext.sp_set_dbmail
  (
    par_mailitem_id,
    1::INTEGER,
    var_sent_result::TEXT
  );
  
  /* ExitProc: */
  /* Always delete query and attactment transfer records. */
  /* Note: Query results can also be returned in the sysmail_attachments_transfer table */
  /* DELETE sysmail_attachments_transfer WHERE uid = @temp_table_uid */
  /* DELETE sysmail_query_transfer WHERE uid = @temp_table_uid */
  /* Raise an error it the query execution fails */
  /* This will only be the case when @append_query_error is set to 0 (false) */
  /* IF( (@RetErrorMsg IS NOT NULL) AND (@exclude_query_output=0) ) */
  /* BEGIN */
  /* RAISERROR('Query execution failed: %s', -1, -1, @RetErrorMsg) */
  /* END */
  
  returncode := var_rc;
  RETURN;

END;
]]></complex-attribute>
                        <category _I_D="e17af942-6fcd-4e21-9e30-53b3ac4c4a9b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="be5ded5b-8113-4870-a846-d61ff65c5a76" name="sp_sequence_get_range" function-id="16625" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sp_sequence_get_range" is-aggregate="f" language-name="plpgsql" context="sp_sequence_get_range" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="record" count-arguments="2" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_sequence_get_range(par_sequence_name text, par_range_size bigint, OUT par_range_first_value bigint, OUT par_range_last_value bigint, OUT par_range_cycle_count bigint, OUT par_sequence_increment bigint, OUT par_sequence_min_value bigint, OUT par_sequence_max_value bigint)" arguments-datatypes="text,bigint,bigint,bigint,bigint,bigint,bigint,bigint" function-arguments="par_sequence_name text, par_range_size bigint, OUT par_range_first_value bigint, OUT par_range_last_value bigint, OUT par_range_cycle_count bigint, OUT par_sequence_increment bigint, OUT par_sequence_min_value bigint, OUT par_sequence_max_value bigint" function-identity-arguments="par_sequence_name text, par_range_size bigint, OUT par_range_first_value bigint, OUT par_range_last_value bigint, OUT par_range_cycle_count bigint, OUT par_sequence_increment bigint, OUT par_sequence_min_value bigint, OUT par_sequence_max_value bigint">
                        <complex-attribute name="sql"><![CDATA[
declare 
  v_is_cycle character varying(3);
  v_current_value bigint;
begin  
  select s.minimum_value, s.maximum_value, s.increment, s.cycle_option 
    from information_schema.sequences s 
    where s.sequence_name = $1 
    into par_sequence_min_value, par_sequence_max_value, par_sequence_increment, v_is_cycle; 
    
  par_range_first_value := aws_sqlserver_ext.get_sequence_value(par_sequence_name);

  if par_range_first_value > par_sequence_min_value then 
    par_range_first_value := par_range_first_value + 1;
  end if;

  if v_is_cycle = 'YES' then 
    par_range_cycle_count := 0;
  end if;
    
  for i in 1..$2 loop
    select nextval(par_sequence_name) into v_current_value;
    if (v_is_cycle = 'YES') and (v_current_value = par_sequence_min_value) and (par_range_first_value <> v_current_value) then 
      par_range_cycle_count := par_range_cycle_count + 1;
    end if;  
  end loop;

  par_range_last_value := aws_sqlserver_ext.get_sequence_value(par_sequence_name);
end;
]]></complex-attribute>
                        <category _I_D="9ac67ae8-3773-4d34-b9ff-e3517001a079" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c1c622d0-cc34-4aa4-95aa-28cd73119928" name="sp_set_dbmail" function-id="16626" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sp_set_dbmail" is-aggregate="f" language-name="plpgsql" context="sp_set_dbmail" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" count-arguments="3" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_set_dbmail(par_mail_id integer, par_sent_status integer, par_message text)" arguments-datatypes="integer,integer,text" function-arguments="par_mail_id integer, par_sent_status integer, par_message text" function-identity-arguments="par_mail_id integer, par_sent_status integer, par_message text">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
  /* event_type
  3                           -- error
  2 AND @loggingLevelInt >= 2 -- warning with extended logging
  1 AND @loggingLevelInt >= 2 -- info with extended logging
  0 AND @loggingLevelInt >= 3 -- success with verbose logging
  */
  IF par_sent_status = 1 /* ok */ THEN

    UPDATE aws_sqlserver_ext.sysmail_mailitems
       SET sent_status = 2
         , sent_date = NOW()
     WHERE mailitem_id = par_mail_id;
     
     INSERT INTO aws_sqlserver_ext.sysmail_log (event_type, log_date, description, mailitem_id)
     VALUES (0, NOW(), par_message, par_mail_id);

  ELSE

    IF par_sent_status = 1 /* failed */ THEN

      UPDATE aws_sqlserver_ext.sysmail_mailitems
         SET sent_status = -1
           , sent_date = NOW()
       WHERE mailitem_id = par_mail_id;
       
      INSERT INTO aws_sqlserver_ext.sysmail_log (event_type, log_date, description, mailitem_id)
      VALUES (3, NOW(), par_message, par_mail_id);

    END IF;

  END IF;

END;
]]></complex-attribute>
                        <category _I_D="095f09b7-a4ef-40bb-8d43-942c8a5cce38" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8a586afb-ddbc-4f53-9a25-b73342bd2375" name="sp_set_next_run" function-id="16627" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sp_set_next_run" is-aggregate="f" language-name="plpgsql" context="sp_set_next_run" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" count-arguments="2" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_set_next_run(par_job_id integer, par_schedule_id integer)" arguments-datatypes="integer,integer" function-arguments="par_job_id integer, par_schedule_id integer" function-identity-arguments="par_job_id integer, par_schedule_id integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_enabled INTEGER;
  var_freq_type INTEGER;
  var_freq_interval INTEGER;
  var_freq_subday_type INTEGER;
  var_freq_subday_interval INTEGER;
  var_freq_relative_interval INTEGER;
  var_freq_recurrence_factor INTEGER;
  var_active_start_date INTEGER;
  var_active_end_date INTEGER;
  var_active_start_time INTEGER;
  var_active_end_time INTEGER;

  var_next_run_date date;
  var_next_run_time time;
  var_next_run_dt timestamp;

  var_tmp_interval varchar(50);
  var_current_dt timestamp;
  var_next_dt timestamp;
BEGIN

  SELECT enabled
       , freq_type
       , freq_interval
       , freq_subday_type
       , freq_subday_interval
       , freq_relative_interval
       , freq_recurrence_factor
       , active_start_date
       , active_end_date
       , active_start_time
       , active_end_time
    FROM aws_sqlserver_ext.sysschedules
    INTO var_enabled
       , var_freq_type
       , var_freq_interval
       , var_freq_subday_type
       , var_freq_subday_interval
       , var_freq_relative_interval
       , var_freq_recurrence_factor
       , var_active_start_date
       , var_active_end_date
       , var_active_start_time
       , var_active_end_time
   WHERE schedule_id = par_schedule_id;

  SELECT next_run_date
       , next_run_time
    FROM aws_sqlserver_ext.sysjobschedules
    INTO var_next_run_date
       , var_next_run_time
   WHERE schedule_id = par_schedule_id
     AND job_id = par_job_id;

  /* if enabled = 0 return */
  CASE var_freq_type
    WHEN 1 THEN
      NULL;

    WHEN 4 THEN
    BEGIN
      /* NULL start date & time or now */
      /* start date + start time or now() */
      IF (var_next_run_date IS NULL OR var_next_run_time IS NULL)
      THEN
        var_current_dt := now()::timestamp;

        UPDATE aws_sqlserver_ext.sysjobschedules
           SET next_run_date = var_current_dt::date
             , next_run_time = var_current_dt::time
         WHERE schedule_id = par_schedule_id
           AND job_id = par_job_id;
        RETURN;
      ELSE
        var_tmp_interval :=
        CASE
          /* WHEN var_freq_subday_type = 1 THEN var_freq_subday_interval::character varying || ' At the specified time'  -- start time */
          WHEN var_freq_subday_type = 2 THEN var_freq_subday_interval::character varying || ' second'  /* ADD var_freq_subday_interval SECOND */
          WHEN var_freq_subday_type = 4 THEN var_freq_subday_interval::character varying || ' minute'  /* ADD var_freq_subday_interval MINUTE */
          WHEN var_freq_subday_type = 8 THEN var_freq_subday_interval::character varying || ' hour'    /* ADD var_freq_subday_interval HOUR */
          ELSE ''
        END;

        var_next_dt := (var_next_run_date::date + var_next_run_time::time)::timestamp + var_tmp_interval::INTERVAL;
        UPDATE aws_sqlserver_ext.sysjobschedules
           SET next_run_date = var_next_dt::date
             , next_run_time = var_next_dt::time
         WHERE schedule_id = par_schedule_id
           AND job_id = par_job_id;
        RETURN;
      END IF;
    END;

    WHEN 8 THEN
      NULL;

    WHEN 16 THEN
      NULL;

    WHEN 32 THEN
      NULL;

    WHEN 64 THEN
      NULL;

    WHEN 128 THEN
     NULL;
     
  END CASE;

END;
]]></complex-attribute>
                        <category _I_D="7328ef85-2db9-43ea-b074-b75e17b84ce7" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="54d16c07-7063-4507-8d8b-3f382436665c" name="sp_update_job" function-id="16631" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sp_update_job" is-aggregate="f" language-name="plpgsql" context="sp_update_job" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" count-arguments="17" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_update_job(par_job_id integer, par_job_name character varying, par_new_name character varying, par_enabled smallint, par_description character varying, par_start_step_id integer, par_category_name character varying, par_owner_login_name character varying, par_notify_level_eventlog integer, par_notify_level_email integer, par_notify_level_netsend integer, par_notify_level_page integer, par_notify_email_operator_name character varying, par_notify_netsend_operator_name character varying, par_notify_page_operator_name character varying, par_delete_level integer, par_automatic_post smallint, OUT returncode integer)" arguments-datatypes="integer,character varying,character varying,smallint,character varying,integer,character varying,character varying,integer,integer,integer,integer,character varying,character varying,character varying,integer,smallint,integer" function-arguments="par_job_id integer DEFAULT NULL::integer, par_job_name character varying DEFAULT NULL::character varying, par_new_name character varying DEFAULT NULL::character varying, par_enabled smallint DEFAULT NULL::smallint, par_description character varying DEFAULT NULL::character varying, par_start_step_id integer DEFAULT NULL::integer, par_category_name character varying DEFAULT NULL::character varying, par_owner_login_name character varying DEFAULT NULL::character varying, par_notify_level_eventlog integer DEFAULT NULL::integer, par_notify_level_email integer DEFAULT NULL::integer, par_notify_level_netsend integer DEFAULT NULL::integer, par_notify_level_page integer DEFAULT NULL::integer, par_notify_email_operator_name character varying DEFAULT NULL::character varying, par_notify_netsend_operator_name character varying DEFAULT NULL::character varying, par_notify_page_operator_name character varying DEFAULT NULL::character varying, par_delete_level integer DEFAULT NULL::integer, par_automatic_post smallint DEFAULT 1, OUT returncode integer" function-identity-arguments="par_job_id integer, par_job_name character varying, par_new_name character varying, par_enabled smallint, par_description character varying, par_start_step_id integer, par_category_name character varying, par_owner_login_name character varying, par_notify_level_eventlog integer, par_notify_level_email integer, par_notify_level_netsend integer, par_notify_level_page integer, par_notify_email_operator_name character varying, par_notify_netsend_operator_name character varying, par_notify_page_operator_name character varying, par_delete_level integer, par_automatic_post smallint, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    var_retval INT;
    var_category_id INT;
    var_notify_email_operator_id INT;
    var_notify_netsend_operator_id INT;
    var_notify_page_operator_id INT;
    var_owner_sid CHAR(85);
    var_alert_id INT;
    var_cached_attribute_modified INT;
    var_is_sysadmin INT;
    var_current_owner VARCHAR(128);
    var_enable_only_used INT;
    var_x_new_name VARCHAR(128);
    var_x_enabled SMALLINT;
    var_x_description VARCHAR(512);
    var_x_start_step_id INT;
    var_x_category_name VARCHAR(128);
    var_x_category_id INT;
    var_x_owner_sid CHAR(85);
    var_x_notify_level_eventlog INT;
    var_x_notify_level_email INT;
    var_x_notify_level_netsend INT;
    var_x_notify_level_page INT;
    var_x_notify_email_operator_name VARCHAR(128);
    var_x_notify_netsnd_operator_name VARCHAR(128);
    var_x_notify_page_operator_name VARCHAR(128);
    var_x_delete_level INT;
    var_x_originating_server_id INT;
    var_x_master_server SMALLINT;
BEGIN
    /* Not updatable */
    /* Remove any leading/trailing spaces from parameters (except @owner_login_name) */
    SELECT
        LTRIM(RTRIM(par_job_name))
        INTO par_job_name;
    SELECT
        LTRIM(RTRIM(par_new_name))
        INTO par_new_name;
    SELECT
        LTRIM(RTRIM(par_description))
        INTO par_description;
    SELECT
        LTRIM(RTRIM(par_category_name))
        INTO par_category_name;
    SELECT
        LTRIM(RTRIM(par_notify_email_operator_name))
        INTO par_notify_email_operator_name;
    SELECT
        LTRIM(RTRIM(par_notify_netsend_operator_name))
        INTO par_notify_netsend_operator_name;
    SELECT
        LTRIM(RTRIM(par_notify_page_operator_name))
        INTO par_notify_page_operator_name
    /* Are we modifying an attribute which SQLServerAgent caches? */;

    IF ((par_new_name IS NOT NULL) OR (par_enabled IS NOT NULL) OR (par_start_step_id IS NOT NULL) OR (par_owner_login_name IS NOT NULL) OR (par_notify_level_eventlog IS NOT NULL) OR (par_notify_level_email IS NOT NULL) OR (par_notify_level_netsend IS NOT NULL) OR (par_notify_level_page IS NOT NULL) OR (par_notify_email_operator_name IS NOT NULL) OR (par_notify_netsend_operator_name IS NOT NULL) OR (par_notify_page_operator_name IS NOT NULL) OR (par_delete_level IS NOT NULL)) THEN
        SELECT
            1
            INTO var_cached_attribute_modified;
    ELSE
        SELECT
            0
            INTO var_cached_attribute_modified;
    END IF
    /* Is @enable the only parameter used beside jobname and jobid? */;

    IF ((par_enabled IS NOT NULL) AND (par_new_name IS NULL) AND (par_description IS NULL) AND (par_start_step_id IS NULL) AND (par_category_name IS NULL) AND (par_owner_login_name IS NULL) AND (par_notify_level_eventlog IS NULL) AND (par_notify_level_email IS NULL) AND (par_notify_level_netsend IS NULL) AND (par_notify_level_page IS NULL) AND (par_notify_email_operator_name IS NULL) AND (par_notify_netsend_operator_name IS NULL) AND (par_notify_page_operator_name IS NULL) AND (par_delete_level IS NULL)) THEN
        SELECT
            1
            INTO var_enable_only_used;
    ELSE
        SELECT
            0
            INTO var_enable_only_used;
    END IF;

    IF (par_new_name = '') THEN
        SELECT
            NULL
            INTO par_new_name;
    END IF
    /* Fill out the values for all non-supplied parameters from the existing values */;

    IF (par_new_name IS NULL) THEN
        SELECT
            var_x_new_name
            INTO par_new_name;
    END IF;

    IF (par_enabled IS NULL) THEN
        SELECT
            var_x_enabled
            INTO par_enabled;
    END IF;

    IF (par_description IS NULL) THEN
        SELECT
            var_x_description
            INTO par_description;
    END IF;

    IF (par_start_step_id IS NULL) THEN
        SELECT
            var_x_start_step_id
            INTO par_start_step_id;
    END IF;

    IF (par_category_name IS NULL) THEN
        SELECT
            var_x_category_name
            INTO par_category_name;
    END IF;

    IF (var_owner_sid IS NULL) THEN
        SELECT
            var_x_owner_sid
            INTO var_owner_sid;
    END IF;

    IF (par_notify_level_eventlog IS NULL) THEN
        SELECT
            var_x_notify_level_eventlog
            INTO par_notify_level_eventlog;
    END IF;

    IF (par_notify_level_email IS NULL) THEN
        SELECT
            var_x_notify_level_email
            INTO par_notify_level_email;
    END IF;

    IF (par_notify_level_netsend IS NULL) THEN
        SELECT
            var_x_notify_level_netsend
            INTO par_notify_level_netsend;
    END IF;

    IF (par_notify_level_page IS NULL) THEN
        SELECT
            var_x_notify_level_page
            INTO par_notify_level_page;
    END IF;

    IF (par_notify_email_operator_name IS NULL) THEN
        SELECT
            var_x_notify_email_operator_name
            INTO par_notify_email_operator_name;
    END IF;

    IF (par_notify_netsend_operator_name IS NULL) THEN
        SELECT
            var_x_notify_netsnd_operator_name
            INTO par_notify_netsend_operator_name;
    END IF;

    IF (par_notify_page_operator_name IS NULL) THEN
        SELECT
            var_x_notify_page_operator_name
            INTO par_notify_page_operator_name;
    END IF;

    IF (par_delete_level IS NULL) THEN
        SELECT
            var_x_delete_level
            INTO par_delete_level;
    END IF
    /* Turn [nullable] empty string parameters into NULLs */;

    IF (LOWER(par_description) = LOWER('')) THEN
        SELECT
            NULL
            INTO par_description;
    END IF;

    IF (par_category_name = '') THEN
        SELECT
            NULL
            INTO par_category_name;
    END IF;

    IF (par_notify_email_operator_name = '') THEN
        SELECT
            NULL
            INTO par_notify_email_operator_name;
    END IF;

    IF (par_notify_netsend_operator_name = '') THEN
        SELECT
            NULL
            INTO par_notify_netsend_operator_name;
    END IF;

    IF (par_notify_page_operator_name = '') THEN
        SELECT
            NULL
            INTO par_notify_page_operator_name;
    END IF
    /* Check new values */;
    SELECT
        t.par_owner_sid, t.par_notify_level_email, t.par_notify_level_netsend, t.par_notify_level_page, 
        t.par_category_id, t.par_notify_email_operator_id, t.par_notify_netsend_operator_id, t.par_notify_page_operator_id, t.par_originating_server, t.ReturnCode
        FROM aws_sqlserver_ext.sp_verify_job(par_job_id, par_new_name, par_enabled, par_start_step_id, par_category_name, var_owner_sid, par_notify_level_eventlog, par_notify_level_email, par_notify_level_netsend, par_notify_level_page, par_notify_email_operator_name, par_notify_netsend_operator_name, par_notify_page_operator_name, par_delete_level, var_category_id, var_notify_email_operator_id, var_notify_netsend_operator_id, var_notify_page_operator_id, NULL) t
        INTO var_owner_sid, par_notify_level_email, par_notify_level_netsend, par_notify_level_page, var_category_id, var_notify_email_operator_id, var_notify_netsend_operator_id, var_notify_page_operator_id, var_retval;

    IF (var_retval <> 0) THEN
        ReturnCode := (1);
        RETURN;
    END IF
    /* Failure */
    /* BEGIN TRANSACTION */
    /* If the job is being re-assigned, modify sysjobsteps.database_user_name as necessary */;

    IF (par_owner_login_name IS NOT NULL) THEN
        IF (EXISTS (SELECT
            1
            FROM aws_sqlserver_ext.sysjobsteps
            WHERE (job_id = par_job_id) AND (LOWER(subsystem) = LOWER('TSQL')))) THEN
            /* The job is being re-assigned to an non-SA */
            UPDATE aws_sqlserver_ext.sysjobsteps
            SET database_user_name = NULL
                WHERE (job_id = par_job_id) AND (LOWER(subsystem) = LOWER('TSQL'));
        END IF;
    END IF;
    UPDATE aws_sqlserver_ext.sysjobs
    SET name = par_new_name, enabled = par_enabled, description = par_description, start_step_id = par_start_step_id, category_id = var_category_id
    /* Returned from sp_verify_job */, owner_sid = var_owner_sid, notify_level_eventlog = par_notify_level_eventlog, notify_level_email = par_notify_level_email, notify_level_netsend = par_notify_level_netsend, notify_level_page = par_notify_level_page, notify_email_operator_id = var_notify_email_operator_id
    /* Returned from sp_verify_job */, notify_netsend_operator_id = var_notify_netsend_operator_id
    /* Returned from sp_verify_job */, notify_page_operator_id = var_notify_page_operator_id
    /* Returned from sp_verify_job */, delete_level = par_delete_level, version_number = version_number + 1
    /* ,  -- Update the job's version */
    /* date_modified              = GETDATE()            -- Update the job's last-modified information */
        WHERE (job_id = par_job_id);
    SELECT
        0
        INTO var_retval
    /* @@error */
    /* COMMIT TRANSACTION */;
    ReturnCode := (var_retval);
    RETURN
    /* 0 means success */;
END;
]]></complex-attribute>
                        <category _I_D="4cc9c54c-2a4a-43a1-aa40-725177bbc31d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="3cc4731e-96d7-4456-9182-9e2c44e2d5b7" name="sp_update_jobschedule" function-id="16629" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sp_update_jobschedule" is-aggregate="f" language-name="plpgsql" context="sp_update_jobschedule" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" count-arguments="16" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_update_jobschedule(par_job_id integer, par_job_name character varying, par_name character varying, par_new_name character varying, par_enabled smallint, par_freq_type integer, par_freq_interval integer, par_freq_subday_type integer, par_freq_subday_interval integer, par_freq_relative_interval integer, par_freq_recurrence_factor integer, par_active_start_date integer, par_active_end_date integer, par_active_start_time integer, par_active_end_time integer, par_automatic_post smallint, OUT returncode integer)" arguments-datatypes="integer,character varying,character varying,character varying,smallint,integer,integer,integer,integer,integer,integer,integer,integer,integer,integer,smallint,integer" function-arguments="par_job_id integer DEFAULT NULL::integer, par_job_name character varying DEFAULT NULL::character varying, par_name character varying DEFAULT NULL::character varying, par_new_name character varying DEFAULT NULL::character varying, par_enabled smallint DEFAULT NULL::smallint, par_freq_type integer DEFAULT NULL::integer, par_freq_interval integer DEFAULT NULL::integer, par_freq_subday_type integer DEFAULT NULL::integer, par_freq_subday_interval integer DEFAULT NULL::integer, par_freq_relative_interval integer DEFAULT NULL::integer, par_freq_recurrence_factor integer DEFAULT NULL::integer, par_active_start_date integer DEFAULT NULL::integer, par_active_end_date integer DEFAULT NULL::integer, par_active_start_time integer DEFAULT NULL::integer, par_active_end_time integer DEFAULT NULL::integer, par_automatic_post smallint DEFAULT 1, OUT returncode integer" function-identity-arguments="par_job_id integer, par_job_name character varying, par_name character varying, par_new_name character varying, par_enabled smallint, par_freq_type integer, par_freq_interval integer, par_freq_subday_type integer, par_freq_subday_interval integer, par_freq_relative_interval integer, par_freq_recurrence_factor integer, par_active_start_date integer, par_active_end_date integer, par_active_start_time integer, par_active_end_time integer, par_automatic_post smallint, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    var_retval INT;
    var_sched_count INT;
    var_schedule_id INT;
    var_job_owner_sid CHAR(85);
    var_enable_only_used INT;
    var_x_name VARCHAR(128);
    var_x_enabled SMALLINT;
    var_x_freq_type INT;
    var_x_freq_interval INT;
    var_x_freq_subday_type INT;
    var_x_freq_subday_interval INT;
    var_x_freq_relative_interval INT;
    var_x_freq_recurrence_factor INT;
    var_x_active_start_date INT;
    var_x_active_end_date INT;
    var_x_active_start_time INT;
    var_x_active_end_time INT;
    var_owner_sid CHAR(85);
BEGIN
    /* Remove any leading/trailing spaces from parameters */
    SELECT
        LTRIM(RTRIM(par_name))
        INTO par_name;
    SELECT
        LTRIM(RTRIM(par_new_name))
        INTO par_new_name
    /* Turn [nullable] empty string parameters into NULLs */;

    IF (par_new_name = '') THEN
        SELECT
            NULL
            INTO par_new_name;
    END IF
    /* Check that we can uniquely identify the job */;
    SELECT
        t.par_job_name, t.par_job_id, t.par_owner_sid, t.ReturnCode
        FROM aws_sqlserver_ext.sp_verify_job_identifiers('@job_name', '@job_id', par_job_name, par_job_id, 'TEST', var_job_owner_sid) t
        INTO par_job_name, par_job_id, var_job_owner_sid, var_retval;

    IF (var_retval <> 0) THEN
        ReturnCode := (1);
        RETURN;
    END IF
    /* Failure */
    /* Is @enable the only parameter used beside jobname and jobid? */;

    IF ((par_enabled IS NOT NULL) AND (par_name IS NULL) AND (par_new_name IS NULL) AND (par_freq_type IS NULL) AND (par_freq_interval IS NULL) AND (par_freq_subday_type IS NULL) AND (par_freq_subday_interval IS NULL) AND (par_freq_relative_interval IS NULL) AND (par_freq_recurrence_factor IS NULL) AND (par_active_start_date IS NULL) AND (par_active_end_date IS NULL) AND (par_active_start_time IS NULL) AND (par_active_end_time IS NULL)) THEN
        SELECT
            1
            INTO var_enable_only_used;
    ELSE
        SELECT
            0
            INTO var_enable_only_used;
    END IF;
    
    IF (par_new_name IS NULL) THEN
        SELECT
            var_x_name
            INTO par_new_name;
    END IF;

    IF (par_enabled IS NULL) THEN
        SELECT
            var_x_enabled
            INTO par_enabled;
    END IF;

    IF (par_freq_type IS NULL) THEN
        SELECT
            var_x_freq_type
            INTO par_freq_type;
    END IF;

    IF (par_freq_interval IS NULL) THEN
        SELECT
            var_x_freq_interval
            INTO par_freq_interval;
    END IF;

    IF (par_freq_subday_type IS NULL) THEN
        SELECT
            var_x_freq_subday_type
            INTO par_freq_subday_type;
    END IF;

    IF (par_freq_subday_interval IS NULL) THEN
        SELECT
            var_x_freq_subday_interval
            INTO par_freq_subday_interval;
    END IF;

    IF (par_freq_relative_interval IS NULL) THEN
        SELECT
            var_x_freq_relative_interval
            INTO par_freq_relative_interval;
    END IF;

    IF (par_freq_recurrence_factor IS NULL) THEN
        SELECT
            var_x_freq_recurrence_factor
            INTO par_freq_recurrence_factor;
    END IF;

    IF (par_active_start_date IS NULL) THEN
        SELECT
            var_x_active_start_date
            INTO par_active_start_date;
    END IF;

    IF (par_active_end_date IS NULL) THEN
        SELECT
            var_x_active_end_date
            INTO par_active_end_date;
    END IF;

    IF (par_active_start_time IS NULL) THEN
        SELECT
            var_x_active_start_time
            INTO par_active_start_time;
    END IF;

    IF (par_active_end_time IS NULL) THEN
        SELECT
            var_x_active_end_time
            INTO par_active_end_time;
    END IF
    /* Check schedule (frequency and owner) parameters */;
    SELECT
        t.par_freq_interval, t.par_freq_subday_type, t.par_freq_subday_interval, t.par_freq_relative_interval, t.par_freq_recurrence_factor, t.par_active_start_date, t.par_active_start_time, 
        t.par_active_end_date, t.par_active_end_time, t.ReturnCode
        FROM aws_sqlserver_ext.sp_verify_schedule(var_schedule_id
        /* @schedule_id */, par_new_name
        /* @name */, par_enabled
        /* @enabled */, par_freq_type
        /* @freq_type */, par_freq_interval
        /* @freq_interval */, par_freq_subday_type
        /* @freq_subday_type */, par_freq_subday_interval
        /* @freq_subday_interval */, par_freq_relative_interval
        /* @freq_relative_interval */, par_freq_recurrence_factor
        /* @freq_recurrence_factor */, par_active_start_date
        /* @active_start_date */, par_active_start_time
        /* @active_start_time */, par_active_end_date
        /* @active_end_date */, par_active_end_time
        /* @active_end_time */, var_owner_sid) t
        INTO par_freq_interval, par_freq_subday_type, par_freq_subday_interval, par_freq_relative_interval, par_freq_recurrence_factor, par_active_start_date, par_active_start_time, par_active_end_date, par_active_end_time, var_retval /* @owner_sid */;

    IF (var_retval <> 0) THEN
        ReturnCode := (1);
        RETURN;
    END IF
    /* Failure */
    /* Update the JobSchedule */;
    UPDATE aws_sqlserver_ext.sysschedules
    SET name = par_new_name, enabled = par_enabled, freq_type = par_freq_type, freq_interval = par_freq_interval, freq_subday_type = par_freq_subday_type, freq_subday_interval = par_freq_subday_interval, freq_relative_interval = par_freq_relative_interval, freq_recurrence_factor = par_freq_recurrence_factor, active_start_date = par_active_start_date, active_end_date = par_active_end_date, active_start_time = par_active_start_time, active_end_time = par_active_end_time
    /* date_modified          = GETDATE(), */, version_number = version_number + 1
        WHERE (schedule_id = var_schedule_id);
    SELECT
        0
        INTO var_retval
    /* @@error */
    /* Update the job's version/last-modified information */;
    UPDATE aws_sqlserver_ext.sysjobs
    SET version_number = version_number + 1
    /* date_modified = GETDATE() */
        WHERE (job_id = par_job_id);
    ReturnCode := (var_retval);
    RETURN
    /* 0 means success */;
END;
]]></complex-attribute>
                        <category _I_D="8cdd8078-40f4-4785-accc-7ad93628b20d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="148af3f1-fda2-47f6-b033-258a01348917" name="sp_update_jobstep" function-id="16633" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sp_update_jobstep" is-aggregate="f" language-name="plpgsql" context="sp_update_jobstep" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" count-arguments="22" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_update_jobstep(par_job_id integer, par_job_name character varying, par_step_id integer, par_step_name character varying, par_subsystem character varying, par_command text, par_additional_parameters text, par_cmdexec_success_code integer, par_on_success_action smallint, par_on_success_step_id integer, par_on_fail_action smallint, par_on_fail_step_id integer, par_server character varying, par_database_name character varying, par_database_user_name character varying, par_retry_attempts integer, par_retry_interval integer, par_os_run_priority integer, par_output_file_name character varying, par_flags integer, par_proxy_id integer, par_proxy_name character varying, OUT returncode integer)" arguments-datatypes="integer,character varying,integer,character varying,character varying,text,text,integer,smallint,integer,smallint,integer,character varying,character varying,character varying,integer,integer,integer,character varying,integer,integer,character varying,integer" function-arguments="par_job_id integer DEFAULT NULL::integer, par_job_name character varying DEFAULT NULL::character varying, par_step_id integer DEFAULT NULL::integer, par_step_name character varying DEFAULT NULL::character varying, par_subsystem character varying DEFAULT NULL::character varying, par_command text DEFAULT NULL::text, par_additional_parameters text DEFAULT NULL::text, par_cmdexec_success_code integer DEFAULT NULL::integer, par_on_success_action smallint DEFAULT NULL::smallint, par_on_success_step_id integer DEFAULT NULL::integer, par_on_fail_action smallint DEFAULT NULL::smallint, par_on_fail_step_id integer DEFAULT NULL::integer, par_server character varying DEFAULT NULL::character varying, par_database_name character varying DEFAULT NULL::character varying, par_database_user_name character varying DEFAULT NULL::character varying, par_retry_attempts integer DEFAULT NULL::integer, par_retry_interval integer DEFAULT NULL::integer, par_os_run_priority integer DEFAULT NULL::integer, par_output_file_name character varying DEFAULT NULL::character varying, par_flags integer DEFAULT NULL::integer, par_proxy_id integer DEFAULT NULL::integer, par_proxy_name character varying DEFAULT NULL::character varying, OUT returncode integer" function-identity-arguments="par_job_id integer, par_job_name character varying, par_step_id integer, par_step_name character varying, par_subsystem character varying, par_command text, par_additional_parameters text, par_cmdexec_success_code integer, par_on_success_action smallint, par_on_success_step_id integer, par_on_fail_action smallint, par_on_fail_step_id integer, par_server character varying, par_database_name character varying, par_database_user_name character varying, par_retry_attempts integer, par_retry_interval integer, par_os_run_priority integer, par_output_file_name character varying, par_flags integer, par_proxy_id integer, par_proxy_name character varying, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    var_retval INT;
    var_os_run_priority_code INT;
    var_step_id_as_char VARCHAR(10);
    var_new_step_name VARCHAR(128);
    var_x_step_name VARCHAR(128);
    var_x_subsystem VARCHAR(40);
    var_x_command TEXT;
    var_x_flags INT;
    var_x_cmdexec_success_code INT;
    var_x_on_success_action SMALLINT;
    var_x_on_success_step_id INT;
    var_x_on_fail_action SMALLINT;
    var_x_on_fail_step_id INT;
    var_x_server VARCHAR(128);
    var_x_database_name VARCHAR(128);
    var_x_database_user_name VARCHAR(128);
    var_x_retry_attempts INT;
    var_x_retry_interval INT;
    var_x_os_run_priority INT;
    var_x_output_file_name VARCHAR(200);
    var_x_proxy_id INT;
    var_x_last_run_outcome SMALLINT;
    var_x_last_run_duration INT;
    var_x_last_run_retries INT;
    var_x_last_run_date INT;
    var_x_last_run_time INT;
    var_new_proxy_id INT;
    var_subsystem_id INT;
    var_auto_proxy_name VARCHAR(128);
    var_job_owner_sid CHAR(85);
    var_step_uid CHAR(85);
BEGIN
    SELECT NULL INTO var_new_proxy_id;
    /* Remove any leading/trailing spaces from parameters */
    SELECT LTRIM(RTRIM(par_step_name)) INTO par_step_name;
    SELECT LTRIM(RTRIM(par_subsystem)) INTO par_subsystem;
    SELECT LTRIM(RTRIM(par_command)) INTO par_command;
    SELECT LTRIM(RTRIM(par_server)) INTO par_server;
    SELECT LTRIM(RTRIM(par_database_name)) INTO par_database_name;
    SELECT LTRIM(RTRIM(par_database_user_name)) INTO par_database_user_name;
    SELECT LTRIM(RTRIM(par_output_file_name)) INTO par_output_file_name;
    SELECT LTRIM(RTRIM(par_proxy_name)) INTO par_proxy_name;
    /* Make sure Dts is translated into new subsystem's name SSIS */
    /* IF (@subsystem IS NOT NULL AND UPPER(@subsystem collate SQL_Latin1_General_CP1_CS_AS) = N'DTS') */
    /* BEGIN */
    /* SET @subsystem = N'SSIS' */
    /* END */
    SELECT
        t.par_job_name, t.par_job_id, t.par_owner_sid, t.ReturnCode
        FROM aws_sqlserver_ext.sp_verify_job_identifiers('@job_name'
        /* @name_of_name_parameter */, '@job_id'
        /* @name_of_id_parameter */, par_job_name
        /* @job_name */, par_job_id
        /* @job_id */, 'TEST'
        /* @sqlagent_starting_test */, var_job_owner_sid)
        INTO par_job_name, par_job_id, var_job_owner_sid, var_retval
    /* @owner_sid */;

    IF (var_retval <> 0) THEN
        ReturnCode := (1);
        RETURN;
    END IF;
    /* Failure */
    /* Check that the step exists */

    IF (NOT EXISTS (SELECT
        *
        FROM aws_sqlserver_ext.sysjobsteps
        WHERE (job_id = par_job_id) AND (step_id = par_step_id))) THEN
        SELECT
            CAST (par_step_id AS VARCHAR(10))
            INTO var_step_id_as_char;
        RAISE 'Error %, severity %, state % was raised. Message: %. Argument: %. Argument: %', '50000', 0, 0, 'The specified %s ("%s") does not exist.', '@step_id', var_step_id_as_char USING ERRCODE := '50000';
        ReturnCode := (1);
        RETURN;
        /* Failure */
    END IF;
    /* Set the x_ (existing) variables */
    SELECT
        step_name, subsystem, command, flags, cmdexec_success_code, on_success_action, on_success_step_id, on_fail_action, on_fail_step_id, server, database_name, database_user_name, retry_attempts, retry_interval, os_run_priority, output_file_name, proxy_id, last_run_outcome, last_run_duration, last_run_retries, last_run_date, last_run_time
        INTO var_x_step_name, var_x_subsystem, var_x_command, var_x_flags, var_x_cmdexec_success_code, var_x_on_success_action, var_x_on_success_step_id, var_x_on_fail_action, var_x_on_fail_step_id, var_x_server, var_x_database_name, var_x_database_user_name, var_x_retry_attempts, var_x_retry_interval, var_x_os_run_priority, var_x_output_file_name, var_x_proxy_id, var_x_last_run_outcome, var_x_last_run_duration, var_x_last_run_retries, var_x_last_run_date, var_x_last_run_time
        FROM aws_sqlserver_ext.sysjobsteps
        WHERE (job_id = par_job_id) AND (step_id = par_step_id);

    IF ((par_step_name IS NOT NULL) AND (par_step_name <> var_x_step_name)) THEN
        SELECT
            par_step_name
            INTO var_new_step_name;
    END IF;
    /* Fill out the values for all non-supplied parameters from the existing values */

    IF (par_step_name IS NULL) THEN
        SELECT var_x_step_name INTO par_step_name;
    END IF;

    IF (par_subsystem IS NULL) THEN
        SELECT var_x_subsystem INTO par_subsystem;
    END IF;

    IF (par_command IS NULL) THEN
        SELECT var_x_command INTO par_command;
    END IF;

    IF (par_flags IS NULL) THEN
        SELECT var_x_flags INTO par_flags;
    END IF;

    IF (par_cmdexec_success_code IS NULL) THEN
        SELECT var_x_cmdexec_success_code INTO par_cmdexec_success_code;
    END IF;

    IF (par_on_success_action IS NULL) THEN
        SELECT var_x_on_success_action INTO par_on_success_action;
    END IF;

    IF (par_on_success_step_id IS NULL) THEN
        SELECT var_x_on_success_step_id INTO par_on_success_step_id;
    END IF;

    IF (par_on_fail_action IS NULL) THEN
        SELECT var_x_on_fail_action INTO par_on_fail_action;
    END IF;

    IF (par_on_fail_step_id IS NULL) THEN
        SELECT var_x_on_fail_step_id INTO par_on_fail_step_id;
    END IF;

    IF (par_server IS NULL) THEN
        SELECT var_x_server INTO par_server;
    END IF;

    IF (par_database_name IS NULL) THEN
        SELECT var_x_database_name INTO par_database_name;
    END IF;

    IF (par_database_user_name IS NULL) THEN
        SELECT var_x_database_user_name INTO par_database_user_name;
    END IF;

    IF (par_retry_attempts IS NULL) THEN
        SELECT var_x_retry_attempts INTO par_retry_attempts;
    END IF;

    IF (par_retry_interval IS NULL) THEN
        SELECT var_x_retry_interval INTO par_retry_interval;
    END IF;

    IF (par_os_run_priority IS NULL) THEN
        SELECT var_x_os_run_priority INTO par_os_run_priority;
    END IF;

    IF (par_output_file_name IS NULL) THEN
        SELECT var_x_output_file_name INTO par_output_file_name;
    END IF;

    IF (par_proxy_id IS NULL) THEN
        SELECT var_x_proxy_id INTO var_new_proxy_id;
    END IF;
    /* if an empty proxy_name is supplied the proxy is removed */

    IF par_proxy_name = '' THEN
        SELECT NULL INTO var_new_proxy_id;
    END IF;
    /* Turn [nullable] empty string parameters into NULLs */

    IF (LOWER(par_command) = LOWER('')) THEN
        SELECT NULL INTO par_command;
    END IF;

    IF (par_server = '') THEN
        SELECT NULL INTO par_server;
    END IF;

    IF (par_database_name = '') THEN
        SELECT NULL INTO par_database_name;
    END IF;

    IF (par_database_user_name = '') THEN
        SELECT NULL INTO par_database_user_name;
    END IF;

    IF (LOWER(par_output_file_name) = LOWER('')) THEN
        SELECT NULL INTO par_output_file_name;
    END IF
    /* Check new values */;
    SELECT
        t.par_database_name, t.par_database_user_name, t.ReturnCode
        FROM aws_sqlserver_ext.sp_verify_jobstep(par_job_id, par_step_id, var_new_step_name, par_subsystem, par_command, par_server, par_on_success_action, par_on_success_step_id, par_on_fail_action, par_on_fail_step_id, par_os_run_priority, par_database_name, par_database_user_name, par_flags, par_output_file_name, var_new_proxy_id) t
        INTO par_database_name, par_database_user_name, var_retval;

    IF (var_retval <> 0) THEN
        ReturnCode := (1);
        RETURN;
    END IF
    /* Failure */
    /* Update the job's version/last-modified information */;
    UPDATE aws_sqlserver_ext.sysjobs
    SET version_number = version_number + 1
    /* date_modified = GETDATE() */
        WHERE (job_id = par_job_id)
    /* Update the step */;
    UPDATE aws_sqlserver_ext.sysjobsteps
    SET step_name = par_step_name, subsystem = par_subsystem, command = par_command, flags = par_flags, additional_parameters = par_additional_parameters, cmdexec_success_code = par_cmdexec_success_code, on_success_action = par_on_success_action, on_success_step_id = par_on_success_step_id, on_fail_action = par_on_fail_action, on_fail_step_id = par_on_fail_step_id, server = par_server, database_name = par_database_name, database_user_name = par_database_user_name, retry_attempts = par_retry_attempts, retry_interval = par_retry_interval, os_run_priority = par_os_run_priority, output_file_name = par_output_file_name, last_run_outcome = var_x_last_run_outcome, last_run_duration = var_x_last_run_duration, last_run_retries = var_x_last_run_retries, last_run_date = var_x_last_run_date, last_run_time = var_x_last_run_time, proxy_id = var_new_proxy_id
        WHERE (job_id = par_job_id) AND (step_id = par_step_id);

    SELECT step_uid
    FROM aws_sqlserver_ext.sysjobsteps
    WHERE job_id = par_job_id AND step_id = par_step_id
    INTO var_step_uid;

    -- PERFORM aws_sqlserver_ext.sp_jobstep_create_proc (var_step_uid);

    ReturnCode := (0);
    RETURN
    /* Success */;
END;
]]></complex-attribute>
                        <category _I_D="74e24f65-a6d2-44d4-a54f-2432963364f7" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="9e4f1c13-081c-4d10-a503-431a31f74239" name="sp_update_schedule" function-id="16635" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sp_update_schedule" is-aggregate="f" language-name="plpgsql" context="sp_update_schedule" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" count-arguments="16" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_update_schedule(par_schedule_id integer, par_name character varying, par_new_name character varying, par_enabled smallint, par_freq_type integer, par_freq_interval integer, par_freq_subday_type integer, par_freq_subday_interval integer, par_freq_relative_interval integer, par_freq_recurrence_factor integer, par_active_start_date integer, par_active_end_date integer, par_active_start_time integer, par_active_end_time integer, par_owner_login_name character varying, par_automatic_post smallint, OUT returncode integer)" arguments-datatypes="integer,character varying,character varying,smallint,integer,integer,integer,integer,integer,integer,integer,integer,integer,integer,character varying,smallint,integer" function-arguments="par_schedule_id integer DEFAULT NULL::integer, par_name character varying DEFAULT NULL::character varying, par_new_name character varying DEFAULT NULL::character varying, par_enabled smallint DEFAULT NULL::smallint, par_freq_type integer DEFAULT NULL::integer, par_freq_interval integer DEFAULT NULL::integer, par_freq_subday_type integer DEFAULT NULL::integer, par_freq_subday_interval integer DEFAULT NULL::integer, par_freq_relative_interval integer DEFAULT NULL::integer, par_freq_recurrence_factor integer DEFAULT NULL::integer, par_active_start_date integer DEFAULT NULL::integer, par_active_end_date integer DEFAULT NULL::integer, par_active_start_time integer DEFAULT NULL::integer, par_active_end_time integer DEFAULT NULL::integer, par_owner_login_name character varying DEFAULT NULL::character varying, par_automatic_post smallint DEFAULT 1, OUT returncode integer" function-identity-arguments="par_schedule_id integer, par_name character varying, par_new_name character varying, par_enabled smallint, par_freq_type integer, par_freq_interval integer, par_freq_subday_type integer, par_freq_subday_interval integer, par_freq_relative_interval integer, par_freq_recurrence_factor integer, par_active_start_date integer, par_active_end_date integer, par_active_start_time integer, par_active_end_time integer, par_owner_login_name character varying, par_automatic_post smallint, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    var_retval INT;
    var_owner_sid CHAR(85);
    var_cur_owner_sid CHAR(85);
    var_x_name VARCHAR(128);
    var_enable_only_used INT;
    var_x_enabled SMALLINT;
    var_x_freq_type INT;
    var_x_freq_interval INT;
    var_x_freq_subday_type INT;
    var_x_freq_subday_interval INT;
    var_x_freq_relative_interval INT;
    var_x_freq_recurrence_factor INT;
    var_x_active_start_date INT;
    var_x_active_end_date INT;
    var_x_active_start_time INT;
    var_x_active_end_time INT;
    var_schedule_uid CHAR(38);
BEGIN
    /* Remove any leading/trailing spaces from parameters */
    SELECT
        LTRIM(RTRIM(par_name))
        INTO par_name;
    SELECT
        LTRIM(RTRIM(par_new_name))
        INTO par_new_name;
    SELECT
        LTRIM(RTRIM(par_owner_login_name))
        INTO par_owner_login_name
    /* Turn [nullable] empty string parameters into NULLs */;

    IF (par_new_name = '') THEN
        SELECT
            NULL
            INTO par_new_name;
    END IF
    /* Check that we can uniquely identify the schedule. This only returns a schedule that is visible to this user */;
    SELECT
        t.par_schedule_name, t.par_schedule_id, t.par_owner_sid, t.par_orig_server_id, t.ReturnCode
        FROM aws_sqlserver_ext.sp_verify_schedule_identifiers('@name'
        /* @name_of_name_parameter */, '@schedule_id'
        /* @name_of_id_parameter */, par_name
        /* @schedule_name */, par_schedule_id
        /* @schedule_id */, var_cur_owner_sid
        /* @owner_sid */, NULL
        /* @orig_server_id */, NULL) t
        INTO par_name, par_schedule_id, var_cur_owner_sid, var_retval
    /* @job_id_filter */;

    IF (var_retval <> 0) THEN
        ReturnCode := (1);
        RETURN;
    END IF
    /* Failure */
    /* Is @enable the only parameter used beside jobname and jobid? */;

    IF ((par_enabled IS NOT NULL) AND (par_new_name IS NULL) AND (par_freq_type IS NULL) AND (par_freq_interval IS NULL) AND (par_freq_subday_type IS NULL) AND (par_freq_subday_interval IS NULL) AND (par_freq_relative_interval IS NULL) AND (par_freq_recurrence_factor IS NULL) AND (par_active_start_date IS NULL) AND (par_active_end_date IS NULL) AND (par_active_start_time IS NULL) AND (par_active_end_time IS NULL) AND (par_owner_login_name IS NULL)) THEN
        SELECT
            1
            INTO var_enable_only_used;
    ELSE
        SELECT
            0
            INTO var_enable_only_used;
    END IF
    /* If the param @owner_login_name is null or doesn't get resolved by SUSER_SID() set it to the current owner of the schedule */;

    IF (var_owner_sid IS NULL) THEN
        SELECT
            var_cur_owner_sid
            INTO var_owner_sid;
    END IF
    /* Set the x_ (existing) variables */;
    SELECT
        name, enabled, freq_type, freq_interval, freq_subday_type, freq_subday_interval, freq_relative_interval, freq_recurrence_factor, active_start_date, active_end_date, active_start_time, active_end_time
        INTO var_x_name, var_x_enabled, var_x_freq_type, var_x_freq_interval, var_x_freq_subday_type, var_x_freq_subday_interval, var_x_freq_relative_interval, var_x_freq_recurrence_factor, var_x_active_start_date, var_x_active_end_date, var_x_active_start_time, var_x_active_end_time
        FROM aws_sqlserver_ext.sysschedules
        WHERE (schedule_id = par_schedule_id)
    /* Fill out the values for all non-supplied parameters from the existing values */;

    IF (par_new_name IS NULL) THEN
        SELECT
            var_x_name
            INTO par_new_name;
    END IF;

    IF (par_enabled IS NULL) THEN
        SELECT
            var_x_enabled
            INTO par_enabled;
    END IF;

    IF (par_freq_type IS NULL) THEN
        SELECT
            var_x_freq_type
            INTO par_freq_type;
    END IF;

    IF (par_freq_interval IS NULL) THEN
        SELECT
            var_x_freq_interval
            INTO par_freq_interval;
    END IF;

    IF (par_freq_subday_type IS NULL) THEN
        SELECT
            var_x_freq_subday_type
            INTO par_freq_subday_type;
    END IF;

    IF (par_freq_subday_interval IS NULL) THEN
        SELECT
            var_x_freq_subday_interval
            INTO par_freq_subday_interval;
    END IF;

    IF (par_freq_relative_interval IS NULL) THEN
        SELECT
            var_x_freq_relative_interval
            INTO par_freq_relative_interval;
    END IF;

    IF (par_freq_recurrence_factor IS NULL) THEN
        SELECT
            var_x_freq_recurrence_factor
            INTO par_freq_recurrence_factor;
    END IF;

    IF (par_active_start_date IS NULL) THEN
        SELECT
            var_x_active_start_date
            INTO par_active_start_date;
    END IF;

    IF (par_active_end_date IS NULL) THEN
        SELECT
            var_x_active_end_date
            INTO par_active_end_date;
    END IF;

    IF (par_active_start_time IS NULL) THEN
        SELECT
            var_x_active_start_time
            INTO par_active_start_time;
    END IF;

    IF (par_active_end_time IS NULL) THEN
        SELECT
            var_x_active_end_time
            INTO par_active_end_time;
    END IF
    /* Check schedule (frequency and owner) parameters */;
    SELECT
        t.par_freq_interval, t.par_freq_subday_type, t.par_freq_subday_interval, t.par_freq_relative_interval, t.par_freq_recurrence_factor, t.par_active_start_date, 
        t.par_active_start_time, t.par_active_end_date, t.par_active_end_time, t.ReturnCode
        FROM aws_sqlserver_ext.sp_verify_schedule(par_schedule_id
        /* @schedule_id */, par_new_name
        /* @name */, par_enabled
        /* @enabled */, par_freq_type
        /* @freq_type */, par_freq_interval
        /* @freq_interval */, par_freq_subday_type
        /* @freq_subday_type */, par_freq_subday_interval
        /* @freq_subday_interval */, par_freq_relative_interval
        /* @freq_relative_interval */, par_freq_recurrence_factor
        /* @freq_recurrence_factor */, par_active_start_date
        /* @active_start_date */, par_active_start_time
        /* @active_start_time */, par_active_end_date
        /* @active_end_date */, par_active_end_time
        /* @active_end_time */, var_owner_sid) t
        INTO par_freq_interval, par_freq_subday_type, par_freq_subday_interval, par_freq_relative_interval, par_freq_recurrence_factor, par_active_start_date, par_active_start_time, par_active_end_date, par_active_end_time, var_retval /* @owner_sid */;

    IF (var_retval <> 0) THEN
        ReturnCode := (1);
        RETURN;
    END IF
    /* Failure */
    /* Update the sysschedules table */;
    UPDATE aws_sqlserver_ext.sysschedules
    SET name = par_new_name, owner_sid = var_owner_sid, enabled = par_enabled, freq_type = par_freq_type, freq_interval = par_freq_interval, freq_subday_type = par_freq_subday_type, freq_subday_interval = par_freq_subday_interval, freq_relative_interval = par_freq_relative_interval, freq_recurrence_factor = par_freq_recurrence_factor, active_start_date = par_active_start_date, active_end_date = par_active_end_date, active_start_time = par_active_start_time, active_end_time = par_active_end_time
    /* date_modified          = GETDATE(), */, version_number = version_number + 1
        WHERE (schedule_id = par_schedule_id);
    SELECT
        0
        INTO var_retval;
    
    ReturnCode := (var_retval);
    RETURN
    /* 0 means success */;
END;
]]></complex-attribute>
                        <category _I_D="cc4152ca-c6ef-4217-bad2-495485a60eab" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f60beb76-f8da-4672-92de-bc71781dbef3" name="sp_verify_job" function-id="16639" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sp_verify_job" is-aggregate="f" language-name="plpgsql" context="sp_verify_job" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="record" count-arguments="19" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_verify_job(par_job_id integer, par_name character varying, par_enabled smallint, par_start_step_id integer, par_category_name character varying, INOUT par_owner_sid character, par_notify_level_eventlog integer, INOUT par_notify_level_email integer, INOUT par_notify_level_netsend integer, INOUT par_notify_level_page integer, par_notify_email_operator_name character varying, par_notify_netsend_operator_name character varying, par_notify_page_operator_name character varying, par_delete_level integer, INOUT par_category_id integer, INOUT par_notify_email_operator_id integer, INOUT par_notify_netsend_operator_id integer, INOUT par_notify_page_operator_id integer, INOUT par_originating_server character varying, OUT returncode integer)" arguments-datatypes="integer,character varying,smallint,integer,character varying,character,integer,integer,integer,integer,character varying,character varying,character varying,integer,integer,integer,integer,integer,character varying,integer" function-arguments="par_job_id integer, par_name character varying, par_enabled smallint, par_start_step_id integer, par_category_name character varying, INOUT par_owner_sid character, par_notify_level_eventlog integer, INOUT par_notify_level_email integer, INOUT par_notify_level_netsend integer, INOUT par_notify_level_page integer, par_notify_email_operator_name character varying, par_notify_netsend_operator_name character varying, par_notify_page_operator_name character varying, par_delete_level integer, INOUT par_category_id integer, INOUT par_notify_email_operator_id integer, INOUT par_notify_netsend_operator_id integer, INOUT par_notify_page_operator_id integer, INOUT par_originating_server character varying, OUT returncode integer" function-identity-arguments="par_job_id integer, par_name character varying, par_enabled smallint, par_start_step_id integer, par_category_name character varying, INOUT par_owner_sid character, par_notify_level_eventlog integer, INOUT par_notify_level_email integer, INOUT par_notify_level_netsend integer, INOUT par_notify_level_page integer, par_notify_email_operator_name character varying, par_notify_netsend_operator_name character varying, par_notify_page_operator_name character varying, par_delete_level integer, INOUT par_category_id integer, INOUT par_notify_email_operator_id integer, INOUT par_notify_netsend_operator_id integer, INOUT par_notify_page_operator_id integer, INOUT par_originating_server character varying, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_job_type INT;
  var_retval INT;
  var_current_date INT;
  var_res_valid_range VARCHAR(200);
  var_max_step_id INT;
  var_valid_range VARCHAR(50);
BEGIN
  /* Remove any leading/trailing spaces from parameters */
  SELECT LTRIM(RTRIM(par_name)) INTO par_name;
  SELECT LTRIM(RTRIM(par_category_name)) INTO par_category_name;
  SELECT UPPER(LTRIM(RTRIM(par_originating_server))) INTO par_originating_server;
    
  IF (
    EXISTS (
      SELECT * 
        FROM aws_sqlserver_ext.sysjobs AS job
       WHERE (name = par_name)
      /* AND (job_id <> ISNULL(@job_id, 0x911)))) -- When adding a new job @job_id is NULL */
    )
  ) 
  THEN /* Failure */
    RAISE 'The specified % ("%") already exists.', 'par_name', par_name USING ERRCODE := '50000';
      returncode := 1;
      RETURN;
  END IF;
    
  /* Check enabled state */
  IF (par_enabled <> 0) AND (par_enabled <> 1) THEN /* Failure */
    RAISE 'The specified "%" is invalid (valid values are: %).', 'par_enabled', '0, 1' USING ERRCODE := '50000';
      returncode := 1;
      RETURN;
  END IF;
  
  /* Check start step */

  IF (par_job_id IS NULL) THEN /* New job */
    IF (par_start_step_id <> 1) THEN /* Failure */
      RAISE 'The specified "%" is invalid (valid values are: %).', 'par_start_step_id', '1' USING ERRCODE := '50000';
        returncode := 1;
        RETURN;
    END IF;
  ELSE /* Existing job */
    /* Get current maximum step id */
    SELECT COALESCE(MAX(step_id), 0)
      INTO var_max_step_id
      FROM aws_sqlserver_ext.sysjobsteps
     WHERE (job_id = par_job_id);

    IF (par_start_step_id < 1) OR (par_start_step_id > var_max_step_id + 1) THEN /* Failure */
      SELECT '1..' || CAST (var_max_step_id + 1 AS VARCHAR(1))
        INTO var_valid_range;
      RAISE 'The specified "%" is invalid (valid values are: %).', 'par_start_step_id', var_valid_range USING ERRCODE := '50000';
      returncode := 1;
      RETURN;
    END IF;
  END IF;
  
  /* Get the category_id, handling any special-cases as appropriate */
  SELECT NULL INTO par_category_id;

  IF (par_category_name = '[DEFAULT]') /* User wants to revert to the default job category */
  THEN
    SELECT 
      CASE COALESCE(var_job_type, 1)
        WHEN 1 THEN 0 /* [Uncategorized (Local)] */
        WHEN 2 THEN 2 /* [Uncategorized (Multi-Server)] */
      END
      INTO par_category_id;
  ELSE
    SELECT 0 INTO par_category_id;
  END IF;
  
  returncode := (0); /* Success */
  RETURN;
END;
]]></complex-attribute>
                        <category _I_D="87f16fa0-a044-47bc-bfa9-8dbff6e1a851" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="20389819-ecfa-4a2f-8705-c70f97e50c5e" name="sp_verify_job_date" function-id="16637" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sp_verify_job_date" is-aggregate="f" language-name="plpgsql" context="sp_verify_job_date" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" count-arguments="2" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_verify_job_date(par_date integer, par_date_name character varying, OUT returncode integer)" arguments-datatypes="integer,character varying,integer" function-arguments="par_date integer, par_date_name character varying DEFAULT 'date'::character varying, OUT returncode integer" function-identity-arguments="par_date integer, par_date_name character varying, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
  /* Remove any leading/trailing spaces from parameters */
  SELECT LTRIM(RTRIM(par_date_name)) INTO par_date_name;
  
  /* Success */
  returncode := 0;
  RETURN;
END;
]]></complex-attribute>
                        <category _I_D="30ad9b95-f39a-4cb1-a2fb-68db1541b25d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="3d0cb645-d066-440f-af66-acc23be9e813" name="sp_verify_job_identifiers" function-id="16638" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sp_verify_job_identifiers" is-aggregate="f" language-name="plpgsql" context="sp_verify_job_identifiers" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="record" count-arguments="6" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_verify_job_identifiers(par_name_of_name_parameter character varying, par_name_of_id_parameter character varying, INOUT par_job_name character varying, INOUT par_job_id integer, par_sqlagent_starting_test character varying, INOUT par_owner_sid character, OUT returncode integer)" arguments-datatypes="character varying,character varying,character varying,integer,character varying,character,integer" function-arguments="par_name_of_name_parameter character varying, par_name_of_id_parameter character varying, INOUT par_job_name character varying, INOUT par_job_id integer, par_sqlagent_starting_test character varying DEFAULT 'TEST'::character varying, INOUT par_owner_sid character DEFAULT NULL::bpchar, OUT returncode integer" function-identity-arguments="par_name_of_name_parameter character varying, par_name_of_id_parameter character varying, INOUT par_job_name character varying, INOUT par_job_id integer, par_sqlagent_starting_test character varying, INOUT par_owner_sid character, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_retval INT;
  var_job_id_as_char VARCHAR(36);
BEGIN
  /* Remove any leading/trailing spaces from parameters */
  SELECT LTRIM(RTRIM(par_name_of_name_parameter)) INTO par_name_of_name_parameter;
  SELECT LTRIM(RTRIM(par_name_of_id_parameter)) INTO par_name_of_id_parameter;
  SELECT LTRIM(RTRIM(par_job_name)) INTO par_job_name;

  IF (par_job_name = '') 
  THEN 
    SELECT NULL INTO par_job_name;
  END IF;

  IF ((par_job_name IS NULL) AND (par_job_id IS NULL)) OR ((par_job_name IS NOT NULL) AND (par_job_id IS NOT NULL)) 
  THEN /* Failure */
    RAISE 'Supply either % or % to identify the job.', par_name_of_id_parameter, par_name_of_name_parameter USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;

  /* Check job id */
  IF (par_job_id IS NOT NULL) 
  THEN
    SELECT name
         , owner_sid
      INTO par_job_name
         , par_owner_sid
      FROM aws_sqlserver_ext.sysjobs
     WHERE (job_id = par_job_id);
 
    /* the view would take care of all the permissions issues. */
    IF (par_job_name IS NULL) 
    THEN /* Failure */
      SELECT CAST (par_job_id AS VARCHAR(36))
        INTO var_job_id_as_char;
      
      RAISE 'The specified % ("%") does not exist.', 'job_id', var_job_id_as_char USING ERRCODE := '50000';
      returncode := 1;
      RETURN;
    END IF;
  ELSE
    /* Check job name */
    IF (par_job_name IS NOT NULL) 
    THEN
      /* Check if the job name is ambiguous */
      IF (SELECT COUNT(*) FROM aws_sqlserver_ext.sysjobs WHERE name = par_job_name) > 1
      THEN /* Failure */
        RAISE 'There are two or more jobs named "%". Specify % instead of % to uniquely identify the job.', par_job_name, par_name_of_id_parameter, par_name_of_name_parameter USING ERRCODE := '50000';
        returncode := 1;
        RETURN;
      END IF;
      
      /* The name is not ambiguous, so get the corresponding job_id (if the job exists) */      
      SELECT job_id
           , owner_sid
        INTO par_job_id
           , par_owner_sid
        FROM aws_sqlserver_ext.sysjobs
       WHERE (name = par_job_name);
       
      /* the view would take care of all the permissions issues. */
      IF (par_job_id IS NULL) 
      THEN /* Failure */
        RAISE 'The specified % ("%") does not exist.', 'job_name', par_job_name USING ERRCODE := '50000';
        returncode := 1;
        RETURN;
      END IF;
    END IF;
  END IF;

  /* Success */  
  returncode := 0;
  RETURN;
END;
]]></complex-attribute>
                        <category _I_D="f9fdfeec-76a5-4edc-99c8-5d64db863a70" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a62544f3-0e1d-4ab5-8ec8-3eee7bce5d66" name="sp_verify_job_time" function-id="16641" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sp_verify_job_time" is-aggregate="f" language-name="plpgsql" context="sp_verify_job_time" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" count-arguments="2" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_verify_job_time(par_time integer, par_time_name character varying, OUT returncode integer)" arguments-datatypes="integer,character varying,integer" function-arguments="par_time integer, par_time_name character varying DEFAULT 'time'::character varying, OUT returncode integer" function-identity-arguments="par_time integer, par_time_name character varying, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_hour INT;
  var_minute INT;
  var_second INT;
BEGIN
  /* Remove any leading/trailing spaces from parameters */
  SELECT LTRIM(RTRIM(par_time_name)) INTO par_time_name;

  IF ((par_time < 0) OR (par_time > 235959)) 
  THEN
    RAISE 'The specified "%" is invalid (valid values are: %).', par_time_name, '000000..235959' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;
  
  SELECT (par_time / 10000) INTO var_hour;
  SELECT (par_time % 10000) / 100 INTO var_minute;
  SELECT (par_time % 100) INTO var_second;
   
  /* Check hour range */
  IF (var_hour > 23) THEN
    RAISE 'The "%" supplied has an invalid %.', par_time_name, 'hour' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;
  
  /* Check minute range */
  IF (var_minute > 59) THEN
    RAISE 'The "%" supplied has an invalid %.', par_time_name, 'minute' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;

  /* Check second range */
  IF (var_second > 59) THEN
     RAISE 'The "%" supplied has an invalid %.', par_time_name, 'second' USING ERRCODE := '50000';
     returncode := 1;
     RETURN;
  END IF;
  
  returncode := 0;
  RETURN;
END;
]]></complex-attribute>
                        <category _I_D="6d928240-3306-404b-99fc-0ebcdbcd7394" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="4933418f-a246-4ff2-adef-ee493fecf035" name="sp_verify_jobstep" function-id="16640" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sp_verify_jobstep" is-aggregate="f" language-name="plpgsql" context="sp_verify_jobstep" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" count-arguments="14" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_verify_jobstep(par_job_id integer, par_step_id integer, par_step_name character varying, par_subsystem character varying, par_command text, par_server character varying, par_on_success_action smallint, par_on_success_step_id integer, par_on_fail_action smallint, par_on_fail_step_id integer, par_os_run_priority integer, par_flags integer, par_output_file_name character varying, par_proxy_id integer, OUT returncode integer)" arguments-datatypes="integer,integer,character varying,character varying,text,character varying,smallint,integer,smallint,integer,integer,integer,character varying,integer,integer" function-arguments="par_job_id integer, par_step_id integer, par_step_name character varying, par_subsystem character varying, par_command text, par_server character varying, par_on_success_action smallint, par_on_success_step_id integer, par_on_fail_action smallint, par_on_fail_step_id integer, par_os_run_priority integer, par_flags integer, par_output_file_name character varying, par_proxy_id integer, OUT returncode integer" function-identity-arguments="par_job_id integer, par_step_id integer, par_step_name character varying, par_subsystem character varying, par_command text, par_server character varying, par_on_success_action smallint, par_on_success_step_id integer, par_on_fail_action smallint, par_on_fail_step_id integer, par_os_run_priority integer, par_flags integer, par_output_file_name character varying, par_proxy_id integer, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_max_step_id INT;
  var_retval INT;
  var_valid_values VARCHAR(50);
  var_database_name_temp VARCHAR(258);
  var_database_user_name_temp VARCHAR(256);
  var_temp_command TEXT;
  var_iPos INT;
  var_create_count INT;
  var_destroy_count INT;
  var_is_olap_subsystem SMALLINT;
  var_owner_sid CHAR(85);
  var_owner_name VARCHAR(128);
BEGIN
  /* Remove any leading/trailing spaces from parameters */
  SELECT LTRIM(RTRIM(par_subsystem)) INTO par_subsystem;
  SELECT LTRIM(RTRIM(par_server)) INTO par_server;
  SELECT LTRIM(RTRIM(par_output_file_name)) INTO par_output_file_name;
  
  /* Get current maximum step id */
  SELECT COALESCE(MAX(step_id), 0)
    INTO var_max_step_id
    FROM aws_sqlserver_ext.sysjobsteps
   WHERE (job_id = par_job_id);
   
  /* Check step id */
  IF (par_step_id < 1) OR (par_step_id > var_max_step_id + 1)  /* Failure */
  THEN
    SELECT '1..' || CAST (var_max_step_id + 1 AS VARCHAR(1)) INTO var_valid_values;
      RAISE 'The specified "%" is invalid (valid values are: %).', '@step_id', var_valid_values USING ERRCODE := '50000';
      returncode := 1;
      RETURN;
  END IF;
  
  /* Check step name */
  IF (
    EXISTS (
      SELECT *
        FROM aws_sqlserver_ext.sysjobsteps
       WHERE (job_id = par_job_id) AND (step_name = par_step_name)
    )
  ) 
  THEN /* Failure */
    RAISE 'The specified % ("%") already exists.', 'step_name', par_step_name USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;
  
  /* Check on-success action/step */
  IF (par_on_success_action <> 1) /* Quit Qith Success */
    AND (par_on_success_action <> 2) /* Quit Qith Failure */
    AND (par_on_success_action <> 3) /* Goto Next Step */
    AND (par_on_success_action <> 4) /* Goto Step */
  THEN /* Failure */
    RAISE 'The specified "%" is invalid (valid values are: %).', 'on_success_action', '1, 2, 3, 4' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;

  IF (par_on_success_action = 4) AND ((par_on_success_step_id < 1) OR (par_on_success_step_id = par_step_id)) 
  THEN /* Failure */
    RAISE 'The specified "%" is invalid (valid values are greater than 0 but excluding %ld).', 'on_success_step', par_step_id USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;
  
  /* Check on-fail action/step */
  IF (par_on_fail_action <> 1) /* Quit With Success */
    AND (par_on_fail_action <> 2) /* Quit With Failure */
    AND (par_on_fail_action <> 3) /* Goto Next Step */
    AND (par_on_fail_action <> 4) /* Goto Step */
  THEN /* Failure */
    RAISE 'The specified "%" is invalid (valid values are: %).', 'on_failure_action', '1, 2, 3, 4' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;

  IF (par_on_fail_action = 4) AND ((par_on_fail_step_id < 1) OR (par_on_fail_step_id = par_step_id)) 
  THEN /* Failure */
    RAISE 'The specified "%" is invalid (valid values are greater than 0 but excluding %).', 'on_failure_step', par_step_id USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;
  
  /* Warn the user about forward references */
  IF ((par_on_success_action = 4) AND (par_on_success_step_id > var_max_step_id)) 
  THEN
    RAISE 'Warning: Non-existent step referenced by %.', 'on_success_step_id' USING ERRCODE := '50000';
  END IF;

  IF ((par_on_fail_action = 4) AND (par_on_fail_step_id > var_max_step_id)) 
  THEN
    RAISE 'Warning: Non-existent step referenced by %.', '@on_fail_step_id' USING ERRCODE := '50000';
  END IF;
  
  /* Check run priority: must be a valid value to pass to SetThreadPriority: */
  /* [-15 = IDLE, -1 = BELOW_NORMAL, 0 = NORMAL, 1 = ABOVE_NORMAL, 15 = TIME_CRITICAL] */
  IF (par_os_run_priority NOT IN (- 15, - 1, 0, 1, 15)) 
  THEN /* Failure */
    RAISE 'The specified "%" is invalid (valid values are: %).', '@os_run_priority', '-15, -1, 0, 1, 15' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;
  
  /* Check flags */
  IF ((par_flags < 0) OR (par_flags > 114)) THEN /* Failure */
    RAISE 'The specified "%" is invalid (valid values are: %).', '@flags', '0..114' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;

  IF (LOWER(UPPER(par_subsystem)) <> LOWER('TSQL')) THEN /* Failure */
    RAISE 'The specified "%" is invalid (valid values are: %).', '@subsystem', 'TSQL' USING ERRCODE := '50000';
    returncode := (1);
    RETURN;
  END IF;
  
  /* Success */
  returncode := 0;
  RETURN;
END;
]]></complex-attribute>
                        <category _I_D="0cecfa2f-0718-45f9-8435-89de5f6fdf18" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="dffd7d64-dc29-49a1-a072-0a88407a4ae2" name="sp_verify_schedule" function-id="16643" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sp_verify_schedule" is-aggregate="f" language-name="plpgsql" context="sp_verify_schedule" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="record" count-arguments="14" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_verify_schedule(par_schedule_id integer, par_name character varying, par_enabled smallint, par_freq_type integer, INOUT par_freq_interval integer, INOUT par_freq_subday_type integer, INOUT par_freq_subday_interval integer, INOUT par_freq_relative_interval integer, INOUT par_freq_recurrence_factor integer, INOUT par_active_start_date integer, INOUT par_active_start_time integer, INOUT par_active_end_date integer, INOUT par_active_end_time integer, par_owner_sid character, OUT returncode integer)" arguments-datatypes="integer,character varying,smallint,integer,integer,integer,integer,integer,integer,integer,integer,integer,integer,character,integer" function-arguments="par_schedule_id integer, par_name character varying, par_enabled smallint, par_freq_type integer, INOUT par_freq_interval integer, INOUT par_freq_subday_type integer, INOUT par_freq_subday_interval integer, INOUT par_freq_relative_interval integer, INOUT par_freq_recurrence_factor integer, INOUT par_active_start_date integer, INOUT par_active_start_time integer, INOUT par_active_end_date integer, INOUT par_active_end_time integer, par_owner_sid character, OUT returncode integer" function-identity-arguments="par_schedule_id integer, par_name character varying, par_enabled smallint, par_freq_type integer, INOUT par_freq_interval integer, INOUT par_freq_subday_type integer, INOUT par_freq_subday_interval integer, INOUT par_freq_relative_interval integer, INOUT par_freq_recurrence_factor integer, INOUT par_active_start_date integer, INOUT par_active_start_time integer, INOUT par_active_end_date integer, INOUT par_active_end_time integer, par_owner_sid character, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_return_code INT;
  var_isAdmin INT;
BEGIN
  /* Remove any leading/trailing spaces from parameters */
  SELECT LTRIM(RTRIM(par_name)) INTO par_name;
  
  /* Make sure that NULL input/output parameters - if NULL - are initialized to 0 */
  SELECT COALESCE(par_freq_interval, 0) INTO par_freq_interval;
  SELECT COALESCE(par_freq_subday_type, 0) INTO par_freq_subday_type;
  SELECT COALESCE(par_freq_subday_interval, 0) INTO par_freq_subday_interval;
  SELECT COALESCE(par_freq_relative_interval, 0) INTO par_freq_relative_interval;
  SELECT COALESCE(par_freq_recurrence_factor, 0) INTO par_freq_recurrence_factor;
  SELECT COALESCE(par_active_start_date, 0) INTO par_active_start_date;
  SELECT COALESCE(par_active_start_time, 0) INTO par_active_start_time;
  SELECT COALESCE(par_active_end_date, 0) INTO par_active_end_date;
  SELECT COALESCE(par_active_end_time, 0) INTO par_active_end_time;
  
  /* Verify name (we disallow schedules called 'ALL' since this has special meaning in sp_delete_jobschedules) */
  SELECT 0 INTO var_isAdmin;

  IF (
    EXISTS (
      SELECT * 
        FROM aws_sqlserver_ext.sysschedules
       WHERE (name = par_name)
    )
  ) 
  THEN /* Failure */
    RAISE 'The specified % ("%") already exists.', 'par_name', par_name USING ERRCODE := '50000';
      returncode := 1;
      RETURN;
  END IF;

  IF (UPPER(par_name) = 'ALL') 
  THEN /* Failure */
    RAISE 'The specified "%" is invalid.', 'name' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;
  
  /* Verify enabled state */
  IF (par_enabled <> 0) AND (par_enabled <> 1) 
  THEN /* Failure */
    RAISE 'The specified "%" is invalid (valid values are: %).', '@enabled', '0, 1' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;
  
  /* Verify frequency type */
  IF (par_freq_type = 2) /* OnDemand is no longer supported */
  THEN /* Failure */
    RAISE 'Frequency Type 0x2 (OnDemand) is no longer supported.' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;

  IF (par_freq_type NOT IN (1, 4, 8, 16, 32, 64, 128)) 
  THEN /* Failure */
    RAISE 'The specified "%" is invalid (valid values are: %).', 'freq_type', '1, 4, 8, 16, 32, 64, 128' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;

  /* Verify frequency sub-day type */
  IF (par_freq_subday_type <> 0) AND (par_freq_subday_type NOT IN (1, 2, 4, 8)) 
  THEN /* Failure */
    RAISE 'The specified "%" is invalid (valid values are: %).', 'freq_subday_type', '1, 2, 4, 8' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;
  
  /* Default active start/end date/times (if not supplied, or supplied as NULLs or 0) */
  IF (par_active_start_date = 0) 
  THEN
    SELECT date_part('year', NOW()::TIMESTAMP) * 10000 + date_part('month', NOW()::TIMESTAMP) * 100 + date_part('day', NOW()::TIMESTAMP)
      INTO par_active_start_date;
  END IF;
  
  /* This is an ISO format: "yyyymmdd" */
  IF (par_active_end_date = 0) 
  THEN
    /* December 31st 9999 */
    SELECT 99991231 INTO par_active_end_date;
  END IF;
    
  IF (par_active_start_time = 0) 
  THEN 
    /* 12:00:00 am */
    SELECT 000000 INTO par_active_start_time;
  END IF;

  IF (par_active_end_time = 0) 
  THEN
    /* 11:59:59 pm */
    SELECT 235959 INTO par_active_end_time;
  END IF;
    
  /* Verify active start/end dates */
  IF (par_active_end_date = 0) 
  THEN
    SELECT 99991231 INTO par_active_end_date;
  END IF;

  SELECT t.returncode
    FROM aws_sqlserver_ext.sp_verify_job_date(par_active_end_date, 'active_end_date') t
    INTO var_return_code;

  IF (var_return_code <> 0) 
  THEN /* Failure */
    returncode := 1;
    RETURN;
  END IF;
  
  SELECT t.returncode
    FROM aws_sqlserver_ext.sp_verify_job_date(par_active_start_date, '@active_start_date') t
    INTO var_return_code;

  IF (var_return_code <> 0) 
  THEN /* Failure */
    returncode := 1;
    RETURN;
  END IF;

  IF (par_active_end_date < par_active_start_date) 
  THEN /* Failure */
    RAISE '% cannot be before %.', 'active_end_date', 'active_start_date' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;
  
  SELECT t.returncode
    FROM aws_sqlserver_ext.sp_verify_job_time(par_active_end_time, '@active_end_time') t
    INTO var_return_code;

  IF (var_return_code <> 0) 
  THEN /* Failure */
    returncode := 1;
    RETURN;
  END IF;
  
  SELECT t.returncode
    FROM aws_sqlserver_ext.sp_verify_job_time(par_active_start_time, '@active_start_time') t
    INTO var_return_code;

  IF (var_return_code <> 0) 
  THEN /* Failure */
    returncode := 1;
    RETURN;
  END IF;
    
  IF (par_active_start_time = par_active_end_time AND (par_freq_subday_type IN (2, 4, 8))) 
  THEN /* Failure */
    RAISE 'The specified "%" is invalid (valid values are: %).', 'active_end_time', 'before or after active_start_time' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;

  IF ((par_freq_type = 1) /* FREQTYPE_ONETIME */
    OR (par_freq_type = 64) /* FREQTYPE_AUTOSTART */
    OR (par_freq_type = 128)) /* FREQTYPE_ONIDLE */
  THEN /* Set standard defaults for non-required parameters */
    SELECT 0 INTO par_freq_interval;
    SELECT 0 INTO par_freq_subday_type;
    SELECT 0 INTO par_freq_subday_interval;
    SELECT 0 INTO par_freq_relative_interval;
    SELECT 0 INTO par_freq_recurrence_factor;
    /* Success */
    returncode := 0;
    RETURN;
  END IF;

  IF (par_freq_subday_type = 0) /* FREQSUBTYPE_ONCE */ 
  THEN
    SELECT 1 INTO par_freq_subday_type;
  END IF;

  IF ((par_freq_subday_type <> 1) /* FREQSUBTYPE_ONCE */
    AND (par_freq_subday_type <> 2) /* FREQSUBTYPE_SECOND */
    AND (par_freq_subday_type <> 4) /* FREQSUBTYPE_MINUTE */
    AND (par_freq_subday_type <> 8)) /* FREQSUBTYPE_HOUR */
  THEN /* Failure */
    RAISE 'The schedule for this job is invalid (reason: The specified @freq_subday_type is invalid (valid values are: 0x1, 0x2, 0x4, 0x8).).' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;

  IF ((par_freq_subday_type <> 1) AND (par_freq_subday_interval < 1)) /* FREQSUBTYPE_ONCE and less than 1 interval */
    OR ((par_freq_subday_type = 2) AND (par_freq_subday_interval < 10)) /* FREQSUBTYPE_SECOND and less than 10 seconds (see MIN_SCHEDULE_GRANULARITY in SqlAgent source code) */
  THEN /* Failure */
    RAISE 'The schedule for this job is invalid (reason: The specified @freq_subday_interval is invalid).' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;

  IF (par_freq_type = 4) /* FREQTYPE_DAILY */
  THEN
    SELECT 0 INTO par_freq_recurrence_factor;
    
    IF (par_freq_interval < 1) THEN /* Failure */
      RAISE 'The schedule for this job is invalid (reason: @freq_interval must be at least 1 for a daily job.).' USING ERRCODE := '50000';
      returncode := 1;
      RETURN;
    END IF;
  END IF;

  IF (par_freq_type = 8) /* FREQTYPE_WEEKLY */
  THEN
    IF (par_freq_interval < 1) OR (par_freq_interval > 127) /* (2^7)-1 [freq_interval is a bitmap (Sun=1..Sat=64)] */
    THEN /* Failure */
      RAISE 'The schedule for this job is invalid (reason: @freq_interval must be a valid day of the week bitmask [Sunday = 1 .. Saturday = 64] for a weekly job.).' USING ERRCODE := '50000';
      returncode := 1;
      RETURN;
    END IF;
  END IF;

  IF (par_freq_type = 16) /* FREQTYPE_MONTHLY */
  THEN
    IF (par_freq_interval < 1) OR (par_freq_interval > 31) 
    THEN /* Failure */
      RAISE 'The schedule for this job is invalid (reason: @freq_interval must be between 1 and 31 for a monthly job.).' USING ERRCODE := '50000';
      returncode := 1;
      RETURN;
    END IF;
  END IF;

  IF (par_freq_type = 32) /* FREQTYPE_MONTHLYRELATIVE */
  THEN
    IF (par_freq_relative_interval <> 1) /* RELINT_1ST */
      AND (par_freq_relative_interval <> 2) /* RELINT_2ND */
      AND (par_freq_relative_interval <> 4) /* RELINT_3RD */
      AND (par_freq_relative_interval <> 8) /* RELINT_4TH */
      AND (par_freq_relative_interval <> 16) /* RELINT_LAST */
    THEN /* Failure */
      RAISE 'The schedule for this job is invalid (reason: @freq_relative_interval must be one of 1st (0x1), 2nd (0x2), 3rd [0x4], 4th (0x8) or Last (0x10).).' USING ERRCODE := '50000';
      returncode := 1;
      RETURN;
    END IF;
  END IF;

  IF (par_freq_type = 32) /* FREQTYPE_MONTHLYRELATIVE */
  THEN
    IF (par_freq_interval <> 1) /* RELATIVE_SUN */
      AND (par_freq_interval <> 2) /* RELATIVE_MON */
      AND (par_freq_interval <> 3) /* RELATIVE_TUE */
      AND (par_freq_interval <> 4) /* RELATIVE_WED */
      AND (par_freq_interval <> 5) /* RELATIVE_THU */
      AND (par_freq_interval <> 6) /* RELATIVE_FRI */
      AND (par_freq_interval <> 7) /* RELATIVE_SAT */
      AND (par_freq_interval <> 8) /* RELATIVE_DAY */
      AND (par_freq_interval <> 9) /* RELATIVE_WEEKDAY */
      AND (par_freq_interval <> 10) /* RELATIVE_WEEKENDDAY */
    THEN /* Failure */
      RAISE 'The schedule for this job is invalid (reason: @freq_interval must be between 1 and 10 (1 = Sunday .. 7 = Saturday, 8 = Day, 9 = Weekday, 10 = Weekend-day) for a monthly-relative job.).' USING ERRCODE := '50000';
      returncode := 1;
      RETURN;
    END IF;
  END IF;

  IF ((par_freq_type = 8) /* FREQTYPE_WEEKLY */
    OR (par_freq_type = 16) /* FREQTYPE_MONTHLY */
    OR (par_freq_type = 32)) /* FREQTYPE_MONTHLYRELATIVE */
    AND (par_freq_recurrence_factor < 1) 
  THEN /* Failure */
    RAISE 'The schedule for this job is invalid (reason: @freq_recurrence_factor must be at least 1.).' USING ERRCODE := '50000';
      returncode := 1;
      RETURN;
  END IF;
  /* Success */
  returncode := 0;
  RETURN;
END;
]]></complex-attribute>
                        <category _I_D="ce1f2a27-136d-460d-901b-5faa4ab2176d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="6940e6e9-083d-45b4-a96a-bcb181dcad8f" name="sp_verify_schedule_identifiers" function-id="16642" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sp_verify_schedule_identifiers" is-aggregate="f" language-name="plpgsql" context="sp_verify_schedule_identifiers" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="record" count-arguments="7" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_verify_schedule_identifiers(par_name_of_name_parameter character varying, par_name_of_id_parameter character varying, INOUT par_schedule_name character varying, INOUT par_schedule_id integer, INOUT par_owner_sid character, INOUT par_orig_server_id integer, par_job_id_filter integer, OUT returncode integer)" arguments-datatypes="character varying,character varying,character varying,integer,character,integer,integer,integer" function-arguments="par_name_of_name_parameter character varying, par_name_of_id_parameter character varying, INOUT par_schedule_name character varying, INOUT par_schedule_id integer, INOUT par_owner_sid character, INOUT par_orig_server_id integer, par_job_id_filter integer DEFAULT NULL::integer, OUT returncode integer" function-identity-arguments="par_name_of_name_parameter character varying, par_name_of_id_parameter character varying, INOUT par_schedule_name character varying, INOUT par_schedule_id integer, INOUT par_owner_sid character, INOUT par_orig_server_id integer, par_job_id_filter integer, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_retval INT;
  var_schedule_id_as_char VARCHAR(36);
  var_sch_name_count INT;
BEGIN
  /* Remove any leading/trailing spaces from parameters */
  SELECT LTRIM(RTRIM(par_name_of_name_parameter)) INTO par_name_of_name_parameter;
  SELECT LTRIM(RTRIM(par_name_of_id_parameter)) INTO par_name_of_id_parameter;
  SELECT LTRIM(RTRIM(par_schedule_name)) INTO par_schedule_name;
  SELECT 0 INTO var_sch_name_count;

  IF (par_schedule_name = '') 
  THEN
    SELECT NULL INTO par_schedule_name;
  END IF;

  IF ((par_schedule_name IS NULL) AND (par_schedule_id IS NULL)) OR ((par_schedule_name IS NOT NULL) AND (par_schedule_id IS NOT NULL)) 
  THEN /* Failure */
    RAISE 'Supply either % or % to identify the schedule.', par_name_of_id_parameter, par_name_of_name_parameter USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;

  /* Check schedule id */
  IF (par_schedule_id IS NOT NULL) 
  THEN
    /* Look at all schedules */
    SELECT name
         , owner_sid
         , originating_server_id
      INTO par_schedule_name
         , par_owner_sid
         , par_orig_server_id
      FROM aws_sqlserver_ext.sysschedules
     WHERE (schedule_id = par_schedule_id);

    IF (par_schedule_name IS NULL) 
    THEN /* Failure */
      SELECT CAST (par_schedule_id AS VARCHAR(36))
        INTO var_schedule_id_as_char;
        
      RAISE 'The specified % ("%") does not exist.', 'schedule_id', var_schedule_id_as_char USING ERRCODE := '50000';
      returncode := 1;
      RETURN;
    END IF;
  ELSE 
    IF (par_schedule_name IS NOT NULL)
    THEN
      /* Check if the schedule name is ambiguous */
      IF (SELECT COUNT(*) FROM aws_sqlserver_ext.sysschedules WHERE name = par_schedule_name) > 1 
      THEN /* Failure */
        RAISE 'There are two or more sysschedules named "%". Specify % instead of % to uniquely identify the sysschedules.', par_job_name, par_name_of_id_parameter, par_name_of_name_parameter USING ERRCODE := '50000';
        returncode := 1;
        RETURN;
      END IF;
    
      /* The name is not ambiguous, so get the corresponding job_id (if the job exists) */
      SELECT schedule_id
           , owner_sid
        INTO par_schedule_id, par_owner_sid
        FROM aws_sqlserver_ext.sysschedules
       WHERE (name = par_schedule_name);
     
      /* the view would take care of all the permissions issues. */
      IF (par_schedule_id IS NULL) 
      THEN /* Failure */
        RAISE 'The specified % ("%") does not exist.', 'par_schedule_name', par_schedule_name USING ERRCODE := '50000';
        returncode := 1;
        RETURN;
      END IF;
    END IF;
  END IF;
  
  /* Success */
  returncode := 0;
  RETURN;
END;
]]></complex-attribute>
                        <category _I_D="177ec60b-ae72-4e21-8417-5bef880f2c65" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8829f356-1ddd-41a4-af72-08df354212aa" name="sp_xml_preparedocument" function-id="16871" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sp_xml_preparedocument" is-aggregate="f" language-name="plpgsql" context="sp_xml_preparedocument" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int8" count-arguments="1" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_xml_preparedocument(xmldocument text, OUT dochandle bigint)" arguments-datatypes="text,bigint" function-arguments="xmldocument text, OUT dochandle bigint" function-identity-arguments="xmldocument text, OUT dochandle bigint">
                        <complex-attribute name="sql"><![CDATA[
DECLARE                       
   XmlDocument$data XML;
BEGIN
     /*Create temporary structure for xmldocument saving*/
     CREATE TEMPORARY SEQUENCE IF NOT EXISTS aws_sqlserver_ext$seq_openmxl_id MINVALUE 1 MAXVALUE 9223372036854775807 START WITH 1 INCREMENT BY 1 CACHE 5;
     
     CREATE TEMPORARY TABLE IF NOT EXISTS aws_sqlserver_ext$openxml
          (DocID BigInt NOT NULL DEFAULT NEXTVAL('aws_sqlserver_ext$seq_openmxl_id'),
           XmlData XML not NULL,
           CONSTRAINT pk_aws_sqlserver_ext$doc_id PRIMARY KEY(DocID)
          ) ON COMMIT PRESERVE ROWS;

     IF xml_is_well_formed(XmlDocument) THEN
       XmlDocument$data := XmlDocument::XML;      
     ELSE
       RAISE EXCEPTION '%','The XML parse error occurred';
     END IF;
     
     INSERT INTO aws_sqlserver_ext$openxml(XmlData)
          VALUES (XmlDocument$data)
       RETURNING DocID INTO DocHandle;	
END;
]]></complex-attribute>
                        <category _I_D="ef06da18-63ff-4fc2-959c-8c636fd6d615" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="30964a12-80ac-40c9-90b7-fa3c69bc94e0" name="sp_xml_removedocument" function-id="16872" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sp_xml_removedocument" is-aggregate="f" language-name="plpgsql" context="sp_xml_removedocument" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" count-arguments="1" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_xml_removedocument(dochandle bigint)" arguments-datatypes="bigint" function-arguments="dochandle bigint" function-identity-arguments="dochandle bigint">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  lt_error_text TEXT := 'Could not find prepared statement with handle '||CASE 
                                                                            WHEN DocHandle IS NULL THEN 'null'
                                                                              ELSE DocHandle::TEXT
                                                                           END;
BEGIN
	DELETE FROM aws_sqlserver_ext$openxml t
	 WHERE t.DocID = DocHandle;
	
	IF NOT FOUND THEN
	     RAISE EXCEPTION '%', lt_error_text;  
	END IF;

	EXCEPTION
	  WHEN SQLSTATE '42P01' THEN 
	      RAISE EXCEPTION '%',lt_error_text;
END;
]]></complex-attribute>
                        <category _I_D="c9f3b0e7-4094-4604-920f-7dd9d77aa1dc" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="be70ce24-4b8f-4b22-82f7-f495f0accdf0" name="strpos3" function-id="16647" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="strpos3" is-aggregate="f" language-name="plpgsql" context="strpos3" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" count-arguments="3" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="strpos3(p_str text, p_substr text, p_loc integer)" arguments-datatypes="text,text,integer" function-arguments="p_str text, p_substr text, p_loc integer" function-identity-arguments="p_str text, p_substr text, p_loc integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
	v_loc int := case when p_loc > 0 then p_loc else 1 end;
	v_cnt int := length(p_str) - v_loc + 1;
BEGIN
/***************************************************************
EXTENSION PACK function STRPOS3(x)
***************************************************************/
	if v_cnt > 0 then
		return case when 0!= strpos(substr(p_str, v_loc, v_cnt), p_substr)
		            then strpos(substr(p_str, v_loc, v_cnt), p_substr) + v_loc - 1
			          else strpos(substr(p_str, v_loc, v_cnt), p_substr)
		       end;
	else
		return 0;
	end if;
END;
]]></complex-attribute>
                        <category _I_D="355ec7bf-4bc8-497a-935c-f76b83e46cdc" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f6690c33-28dd-47de-85ec-f82e309d4291" name="sysmail_add_account_sp" function-id="16648" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sysmail_add_account_sp" is-aggregate="f" language-name="plpgsql" context="sysmail_add_account_sp" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="record" count-arguments="12" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_add_account_sp(par_account_name character varying, par_email_address character varying, par_display_name character varying, par_replyto_address character varying, par_description character varying, par_mailserver_name character varying, par_mailserver_type character varying, par_port integer, par_username character varying, par_password character varying, par_use_default_credentials smallint, par_enable_ssl smallint, OUT par_account_id integer, OUT returncode integer)" arguments-datatypes="character varying,character varying,character varying,character varying,character varying,character varying,character varying,integer,character varying,character varying,smallint,smallint,integer,integer" function-arguments="par_account_name character varying, par_email_address character varying, par_display_name character varying DEFAULT NULL::character varying, par_replyto_address character varying DEFAULT NULL::character varying, par_description character varying DEFAULT NULL::character varying, par_mailserver_name character varying DEFAULT NULL::character varying, par_mailserver_type character varying DEFAULT 'SMTP'::character varying, par_port integer DEFAULT 25, par_username character varying DEFAULT NULL::character varying, par_password character varying DEFAULT NULL::character varying, par_use_default_credentials smallint DEFAULT 0, par_enable_ssl smallint DEFAULT 0, OUT par_account_id integer, OUT returncode integer" function-identity-arguments="par_account_name character varying, par_email_address character varying, par_display_name character varying, par_replyto_address character varying, par_description character varying, par_mailserver_name character varying, par_mailserver_type character varying, par_port integer, par_username character varying, par_password character varying, par_use_default_credentials smallint, par_enable_ssl smallint, OUT par_account_id integer, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_rc INTEGER;
BEGIN

  SELECT t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_addressparams_sp
    (
      par_address => par_replyto_address,
      par_parameter_name => '@replyto_address'
    ) t
    INTO var_rc;

  IF var_rc <> 0 THEN

    returncode := var_rc;
    RETURN;

  END IF;

  IF par_mailserver_name IS NULL THEN /* Failure */

    RAISE '% is not a valid mailserver_name', par_mailserver_name USING ERRCODE := '50000';
    returncode := 1;
    RETURN;

  END IF;

  IF par_mailserver_type IS NULL THEN /* Failure */

    RAISE '% is not a valid mailserver_type', par_mailserver_type USING ERRCODE := '50000';
    returncode := 1;
    RETURN;

  END IF;

  INSERT 
    INTO aws_sqlserver_ext.sysmail_account
    (
      name
    , description
    , email_address
    , display_name
    , replyto_address       
    )
  VALUES
  (
    par_account_name
  , par_description
  , par_email_address
  , par_display_name
  , par_replyto_address
  );
  
  SELECT account_id
    INTO par_account_id
    FROM aws_sqlserver_ext.sysmail_account
   WHERE name = par_account_name;

  returncode := 0;
  RETURN;
END;
]]></complex-attribute>
                        <category _I_D="1dc4a5f8-e618-4415-a00c-c5187b60e529" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="441bedc9-65f8-4265-9789-f3cda3e90c42" name="sysmail_add_profile_sp" function-id="16650" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sysmail_add_profile_sp" is-aggregate="f" language-name="plpgsql" context="sysmail_add_profile_sp" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="record" count-arguments="2" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_add_profile_sp(par_profile_name character varying, par_description character varying, OUT par_profile_id integer, OUT returncode integer)" arguments-datatypes="character varying,character varying,integer,integer" function-arguments="par_profile_name character varying, par_description character varying DEFAULT NULL::character varying, OUT par_profile_id integer, OUT returncode integer" function-identity-arguments="par_profile_name character varying, par_description character varying, OUT par_profile_id integer, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
  /* insert new profile record, rely on primary key constraint to error out */
  INSERT INTO aws_sqlserver_ext.sysmail_profile (name, description)
  VALUES (par_profile_name, par_description);

  /* fetch back profile_id */
  SELECT profile_id
    INTO par_profile_id
    FROM aws_sqlserver_ext.sysmail_profile
   WHERE name = par_profile_name;
   
  returncode := 0;
  RETURN;

END;
]]></complex-attribute>
                        <category _I_D="1eb20f7a-fcbb-4177-89ee-0d358e72e773" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0f93d6d0-73c9-45c4-a92f-86ebef7d63ac" name="sysmail_add_profileaccount_sp" function-id="16649" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sysmail_add_profileaccount_sp" is-aggregate="f" language-name="plpgsql" context="sysmail_add_profileaccount_sp" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" count-arguments="5" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_add_profileaccount_sp(par_profile_id integer, par_profile_name character varying, par_account_id integer, par_account_name character varying, par_sequence_number integer, OUT returncode integer)" arguments-datatypes="integer,character varying,integer,character varying,integer,integer" function-arguments="par_profile_id integer DEFAULT NULL::integer, par_profile_name character varying DEFAULT NULL::character varying, par_account_id integer DEFAULT NULL::integer, par_account_name character varying DEFAULT NULL::character varying, par_sequence_number integer DEFAULT NULL::integer, OUT returncode integer" function-identity-arguments="par_profile_id integer, par_profile_name character varying, par_account_id integer, par_account_name character varying, par_sequence_number integer, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_rc INTEGER;
  var_profileid INTEGER;
  var_accountid INTEGER;
BEGIN

  SELECT t.par_profileid, t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_profile_sp
    (
      par_profile_id,
      par_profile_name,
      0::SMALLINT,
      0::SMALLINT
    ) t
    INTO var_profileid, var_rc;

  IF var_rc <> 0 THEN

    returncode := 1;
    RETURN;

  END IF;

  SELECT t.par_accountid, t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_account_sp
    (
      par_account_id,
      par_account_name,
      0::SMALLINT,
      0::SMALLINT
    ) t
    INTO var_accountid, var_rc;

  IF var_rc <> 0 THEN

    returncode := 2;
    RETURN;

  END IF;

  /* insert new account record, rely on primary key constraint to error out */
  INSERT INTO aws_sqlserver_ext.sysmail_profileaccount (profile_id, account_id, sequence_number)
  VALUES (var_profileid, var_accountid, par_sequence_number);
  
  returncode := 0;
  RETURN;

END;
]]></complex-attribute>
                        <category _I_D="fb50ff3a-8929-4c8f-b790-b2fc625b87d8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c2d58097-cf96-4151-badf-5e1df7595941" name="sysmail_dbmail_json" function-id="16651" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sysmail_dbmail_json" is-aggregate="f" language-name="plpgsql" context="sysmail_dbmail_json" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="record" count-arguments="1" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_dbmail_json(par_mail_id integer, OUT par_mail_data text, OUT par_server_name character varying, OUT returncode integer)" arguments-datatypes="integer,text,character varying,integer" function-arguments="par_mail_id integer, OUT par_mail_data text, OUT par_server_name character varying, OUT returncode integer" function-identity-arguments="par_mail_id integer, OUT par_mail_data text, OUT par_server_name character varying, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_r VARCHAR(2);
  var_t1 VARCHAR(2) DEFAULT '';
  var_t2 VARCHAR(4) DEFAULT '';
  var_t3 VARCHAR(6) DEFAULT '';
  var_t4 VARCHAR(8) DEFAULT '';
  var_xml TEXT DEFAULT '';
  var_source VARCHAR(255);
  var_profile_id INTEGER;
  var_recipients TEXT;
  var_copy_recipients TEXT;
  var_blind_copy_recipients TEXT;
  var_subject VARCHAR(255);
  var_body_format VARCHAR(20);
  var_body TEXT;
  var_from_address TEXT;
  var_reply_to TEXT;
  var_importance VARCHAR(6);
  var_sensitivity VARCHAR(12);
  var_mailitem_id INTEGER;
BEGIN

  SELECT mailitem_id
       , profile_id
       , recipients
       , copy_recipients
       , blind_copy_recipients
       , subject
       , UPPER(body_format)
       , body
       , importance
       , sensitivity
        /* @file_attachments = file_attachments, */
        /* @attachment_encoding = attachment_encoding, */
        /* @query = query, */
        /* @execute_query_database = execute_query_database, */
        /* @attach_query_result_as_file = attach_query_result_as_file, */
        /* @query_result_header = query_result_header, */
        /* @query_result_width = query_result_width, */
        /* @query_result_separator = query_result_separator, */
        /* @exclude_query_output = exclude_query_output, */
        /* @append_query_error = append_query_error, */
        , from_address
        , reply_to
    INTO var_mailitem_id
       , var_profile_id
       , var_recipients
       , var_copy_recipients
       , var_blind_copy_recipients
       , var_subject
       , var_body_format
       , var_body
       , var_importance
       , var_sensitivity
       , var_from_address
       , var_reply_to
    FROM aws_sqlserver_ext.sysmail_mailitems
   WHERE mailitem_id = par_mail_id
   ORDER BY mailitem_id ASC NULLS FIRST
   LIMIT 1;

  IF var_mailitem_id IS NULL THEN

    RAISE 'E-mail messages are missing.' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;

  END IF;

  SELECT CASE
           WHEN LENGTH(a.display_name) = 0 THEN a.email_address
           ELSE CONCAT(a.display_name, ' <', a.email_address, '>')
         END
    INTO var_source
    FROM aws_sqlserver_ext.sysmail_profile AS p
   INNER JOIN aws_sqlserver_ext.sysmail_profileaccount AS pa
      ON pa.profile_id = p.profile_id
   INNER JOIN aws_sqlserver_ext.sysmail_account AS a
      ON a.account_id = pa.account_id
   WHERE p.profile_id = var_profile_id
   LIMIT 1;

  SELECT servername
    INTO par_server_name
    FROM aws_sqlserver_ext.sysmail_server
   WHERE account_id = 0
     AND servertype = 'AWSLAMBDA'
   LIMIT 1;

  IF par_server_name IS NULL THEN

    RAISE 'ARN are missing.' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;

  END IF;

  var_xml := CONCAT(var_xml, '{', var_r);
  var_xml := CONCAT(var_xml, var_t1, '"service": "ses",', var_r);
  var_xml := CONCAT(var_xml, var_t1, '"args": {', var_r);
  /* set source */
  var_xml := CONCAT(var_xml, var_t2, '"source": "', var_source, '",', var_r);
  /* recipients */
  var_xml := CONCAT(var_xml, var_t2, '"recipients": [', var_r);
  var_xml := CONCAT(var_xml, var_t3, '"', var_recipients, '"', var_r);     /* !!!!!!!!!! */
  /* SET @xml = CONCAT(@xml, @t3, '"address": "sample <sample@sample.info>",', @r);    !!!!!!!!!! */
  /* SET @xml = CONCAT(@xml, @t3, '"address": "sample@sample.info"', @r);    !!!!!!!!!! */
  var_xml := CONCAT(var_xml, var_t2, '],', var_r);
  
  /* copy_recipients */
  var_xml := CONCAT(var_xml, var_t2, '"copyrecipients": [', var_r);

  IF var_copy_recipients IS NOT NULL AND LENGTH(var_copy_recipients) > 0 THEN

    var_xml := CONCAT(var_xml, var_t3, '"', var_copy_recipients, '",', var_r);         /* !!!!!!!!!! */
    /* SET @xml = CONCAT(@xml, @t3, '"address": "sample <sample@sample.info>",', @r);    !!!!!!!!!! */
    /* SET @xml = CONCAT(@xml, @t3, '"address": "sample@sample.info"', @r);    !!!!!!!!!! */

  END IF;

  var_xml := CONCAT(var_xml, var_t2, '],', var_r);

  /* blind_copy_recipients */
  var_xml := CONCAT(var_xml, var_t2, '"blindcopyrecipients": [', var_r);

  IF var_blind_copy_recipients IS NOT NULL AND LENGTH(var_blind_copy_recipients) > 0 THEN

    var_xml := CONCAT(var_xml, var_t3, '"', var_blind_copy_recipients, '",', var_r);         /* !!!!!!!!!! */
    /* SET @xml = CONCAT(@xml, @t3, '"address": "sample <sample@sample.info>",', @r);   -- !!!!!!!!!! */
    /* SET @xml = CONCAT(@xml, @t3, '"address": "sample@sample.info"', @r);   -- !!!!!!!!!! */

  END IF;

  var_xml := CONCAT(var_xml, var_t2, '],', var_r);

  var_xml := CONCAT(var_xml, var_t2, '"importance": "', var_importance, '",', var_r);
  var_xml := CONCAT(var_xml, var_t2, '"sensitivity": "', var_sensitivity, '",', var_r);
  var_xml := CONCAT(var_xml, var_t2, '"subject": "', var_subject, '",', var_r);
  var_xml := CONCAT(var_xml, var_t2, '"format": "', var_body_format, '",', var_r);
  var_xml := CONCAT(var_xml, var_t2, '"body": {', var_r);
  var_xml := CONCAT(var_xml, var_t3, '"data": "', var_body, '"', var_r);
  var_xml := CONCAT(var_xml, var_t2, '}', var_r);
  var_xml := CONCAT(var_xml, var_t1, '}', var_r);
  var_xml := CONCAT(var_xml, '}');
  
  par_mail_data := var_xml;

END;
]]></complex-attribute>
                        <category _I_D="17343b90-b198-488d-8988-7c9c86c8a48b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="30201d9c-a0c7-49b1-80c6-a2f7b382c02f" name="sysmail_dbmail_xml" function-id="16652" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sysmail_dbmail_xml" is-aggregate="f" language-name="plpgsql" context="sysmail_dbmail_xml" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="record" count-arguments="1" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_dbmail_xml(par_mail_id integer, OUT par_mail_data text, OUT returncode integer)" arguments-datatypes="integer,text,integer" function-arguments="par_mail_id integer, OUT par_mail_data text, OUT returncode integer" function-identity-arguments="par_mail_id integer, OUT par_mail_data text, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_r VARCHAR(2); /* DEFAULT aws_sqlserver_ext.CHAR(10) || aws_sqlserver_ext.CHAR(13);*/
  var_t1 VARCHAR(2) DEFAULT ''; --'  ';
  var_t2 VARCHAR(4) DEFAULT ''; --'    ';
  var_t3 VARCHAR(6) DEFAULT ''; --'      ';
  var_t4 VARCHAR(8) DEFAULT ''; --'        ';
  var_xml TEXT DEFAULT '';
  var_source VARCHAR(255);
  var_profile_id INT;
  var_recipients TEXT;
  var_copy_recipients TEXT;
  var_blind_copy_recipients TEXT;
  var_subject VARCHAR(255);
  var_body_format VARCHAR(20);
  var_body TEXT;
  var_from_address TEXT;
  var_reply_to TEXT;
  var_importance VARCHAR(6);
  var_sensitivity VARCHAR(12);
  var_mailitem_id INTEGER;
BEGIN

  SELECT mailitem_id
       , profile_id
       , recipients
       , copy_recipients
       , blind_copy_recipients
       , subject
       , UPPER(body_format)
       , body
       , importance
       , sensitivity
        /* @file_attachments = file_attachments, */
        /* @attachment_encoding = attachment_encoding, */
        /* @query = query, */
        /* @execute_query_database = execute_query_database, */
        /* @attach_query_result_as_file = attach_query_result_as_file, */
        /* @query_result_header = query_result_header, */
        /* @query_result_width = query_result_width, */
        /* @query_result_separator = query_result_separator, */
        /* @exclude_query_output = exclude_query_output, */
        /* @append_query_error = append_query_error, */, from_address, reply_to
    INTO var_mailitem_id
       , var_profile_id
       , var_recipients
       , var_copy_recipients
       , var_blind_copy_recipients
       , var_subject
       , var_body_format
       , var_body
       , var_importance
       , var_sensitivity
       , var_from_address
       , var_reply_to
    FROM aws_sqlserver_ext.sysmail_mailitems
   WHERE mailitem_id = par_mail_id /* sent_status = 0 */
   ORDER BY mailitem_id ASC NULLS FIRST
   LIMIT 1;

  IF var_mailitem_id IS NULL THEN

    RAISE 'E-mail messages are missing.' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;

  END IF;

  SELECT CASE
           WHEN LENGTH(a.display_name) = 0 THEN a.email_address
           ELSE CONCAT(a.display_name, ' <', a.email_address, '>')
         END
    INTO var_source
    FROM aws_sqlserver_ext.sysmail_profile AS p
   INNER JOIN aws_sqlserver_ext.sysmail_profileaccount AS pa
      ON pa.profile_id = p.profile_id
   INNER JOIN aws_sqlserver_ext.sysmail_account AS a
      ON a.account_id = pa.account_id
   WHERE p.profile_id = var_profile_id
   LIMIT 1;
   
  var_xml := CONCAT(var_xml, '<mail>', var_r);
  /* set source */
  var_xml := CONCAT(var_xml, var_t1, '<source>', var_source, '</source>', var_r);
  /* set destination */
  var_xml := CONCAT(var_xml, var_t1, '<destination>', var_r);
  var_xml := CONCAT(var_xml, var_t2, '<to_addresses>', var_r);
  var_xml := CONCAT(var_xml, var_t3, '<address>', var_recipients, '</address>', var_r);
  /* SET @xml = CONCAT(@xml, @t3, '<address>', @destination2, '</address>', @r); */
  var_xml := CONCAT(var_xml, var_t2, '</to_addresses>', var_r);
  var_xml := CONCAT(var_xml, var_t1, '</destination>', var_r);
  /* set message */
  var_xml := CONCAT(var_xml, var_t1, '<message>', var_r);
  var_xml := CONCAT(var_xml, var_t2, '<subject>', var_r);
  var_xml := CONCAT(var_xml, var_t3, '<data>', var_subject, '</data>', var_r);
  var_xml := CONCAT(var_xml, var_t3, '<charset>UTF-8</charset>', var_r);
  var_xml := CONCAT(var_xml, var_t2, '</subject>', var_r);
  var_xml := CONCAT(var_xml, var_t2, '<body>', var_r);

  IF LOWER(var_body_format) = LOWER('TEXT') THEN

    var_xml := CONCAT(var_xml, var_t3, '<text>', var_r);
    var_xml := CONCAT(var_xml, var_t4, '<data>', var_body, '</data>', var_r);
    var_xml := CONCAT(var_xml, var_t4, '<charset>UTF-8</charset>', var_r);
    var_xml := CONCAT(var_xml, var_t3, '</text>', var_r);
  /* 'HTML' */

  ELSE

    var_xml := CONCAT(var_xml, var_t3, '<html>', var_r);
    var_xml := CONCAT(var_xml, var_t4, '<data>', var_body, '</data>', var_r);
    var_xml := CONCAT(var_xml, var_t4, '<charset>UTF-8</charset>', var_r);
    var_xml := CONCAT(var_xml, var_t3, '</html>', var_r);

  END IF;

  var_xml := CONCAT(var_xml, var_t2, '</body>', var_r);
  var_xml := CONCAT(var_xml, var_t1, '</message>', var_r);
  /* reply to */
  var_xml := CONCAT(var_xml, var_t1, '<reply_to_addresses>', var_r);
  var_xml := CONCAT(var_xml, var_t2, '<address>', var_source, '</address>', var_r);
  /* SET @xml = CONCAT(@xml, @t2, '<address>',@reply_to_addresses2,'</address>', @r); */
  var_xml := CONCAT(var_xml, var_t1, '</reply_to_addresses>', var_r);
  var_xml := CONCAT(var_xml, '</mail>');
  
  par_mail_data := var_xml;

END;
]]></complex-attribute>
                        <category _I_D="a5c14444-6397-42cc-9bb5-4f35918cb3ae" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="37e955d1-3338-46d6-868e-c4d8e8735322" name="sysmail_delete_account_sp" function-id="16653" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sysmail_delete_account_sp" is-aggregate="f" language-name="plpgsql" context="sysmail_delete_account_sp" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" count-arguments="2" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_delete_account_sp(par_account_id integer, par_account_name character varying, OUT returncode integer)" arguments-datatypes="integer,character varying,integer" function-arguments="par_account_id integer DEFAULT NULL::integer, par_account_name character varying DEFAULT NULL::character varying, OUT returncode integer" function-identity-arguments="par_account_id integer, par_account_name character varying, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_rc INTEGER;
  var_accountid INTEGER;
  var_credential_name CHARACTER VARYING(128);
BEGIN

  SELECT t.par_accountid, t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_account_sp
  (
    par_account_id,
    par_account_name,
    0::SMALLINT,
    0::SMALLINT
  ) t
    INTO var_accountid, var_rc;

  IF var_rc <> 0 THEN

    returncode := 1;
    RETURN;

  END IF;
  
  DELETE 
    FROM aws_sqlserver_ext.sysmail_account
   WHERE account_id = var_accountid;
   
  returncode := 0;
  RETURN;

END;
]]></complex-attribute>
                        <category _I_D="c928b3b5-0322-485c-9ca4-f7e0acdc5d12" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="199dd3bd-4bb8-479f-94bd-e4cb7ba6659f" name="sysmail_delete_mailitems_sp" function-id="16654" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sysmail_delete_mailitems_sp" is-aggregate="f" language-name="plpgsql" context="sysmail_delete_mailitems_sp" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" count-arguments="2" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_delete_mailitems_sp(par_sent_before timestamp without time zone, par_sent_status character varying, OUT returncode integer)" arguments-datatypes="timestamp without time zone,character varying,integer" function-arguments="par_sent_before timestamp without time zone DEFAULT NULL::timestamp without time zone, par_sent_status character varying DEFAULT NULL::character varying, OUT returncode integer" function-identity-arguments="par_sent_before timestamp without time zone, par_sent_status character varying, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  vsentstatus TEXT;
BEGIN

  vsentstatus := TRIM(par_sent_status);

  IF vsentstatus = '' THEN

    vsentstatus := NULL;

  END IF;

  IF vsentstatus IS NOT NULL AND LOWER(vsentstatus) NOT IN ('unsent', 'sent', 'failed', 'retrying') THEN /* Failure */

    RAISE 'The specified "%" is invalid (valid values are: %).', 'sent_status', 'unsent, sent, failed, retrying' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;

  END IF;

  IF par_sent_before IS NULL AND vsentstatus IS NULL THEN /* Failure */

    RAISE 'Either % or % parameter needs to be supplied', 'sent_before', 'sent_status' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;

  END IF;
  
  DELETE 
    FROM aws_sqlserver_ext.sysmail_mailitems
   WHERE (par_sent_before IS NULL OR send_request_date < par_sent_before) 
     AND (vsentstatus IS NULL OR sent_status = vsentstatus);

END;
]]></complex-attribute>
                        <category _I_D="1f9c0e90-3056-41cf-be53-26b1039f6b2a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="98bca013-2839-4934-8452-aadf0fa2f49c" name="sysmail_delete_profile_sp" function-id="16656" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sysmail_delete_profile_sp" is-aggregate="f" language-name="plpgsql" context="sysmail_delete_profile_sp" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" count-arguments="3" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_delete_profile_sp(par_profile_id integer, par_profile_name character varying, par_force_delete smallint, OUT returncode integer)" arguments-datatypes="integer,character varying,smallint,integer" function-arguments="par_profile_id integer DEFAULT NULL::integer, par_profile_name character varying DEFAULT NULL::character varying, par_force_delete smallint DEFAULT 1, OUT returncode integer" function-identity-arguments="par_profile_id integer, par_profile_name character varying, par_force_delete smallint, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_rc INTEGER;
  var_profileid INTEGER;
BEGIN
  SELECT t.par_profileid, t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_profile_sp
  (
    par_profile_id,
    par_profile_name,
    0::SMALLINT,
    0::SMALLINT
  ) t
    INTO var_profileid, var_rc;

  IF var_rc <> 0 THEN

    returncode := 1;
    RETURN;

  END IF;

  IF (
    EXISTS 
    (
      SELECT 1 
        FROM aws_sqlserver_ext.sysmail_mailitems m
       WHERE m.profile_id = var_profileid
         AND m.sent_status IN (0,3)
    )
    AND par_force_delete <> 1
  ) 
  THEN

    IF par_profile_name IS NULL THEN

      SELECT name INTO par_profile_name
        FROM aws_sqlserver_ext.sysmail_profile
       WHERE profile_id = var_profileid;

    END IF;
    
    RAISE 'Deleting profile %s failed because there are some unsent emails associated with this profile, use force_delete option to force the deletion of the profile.', par_profile_name USING ERRCODE := '50000';
    
    returncode := 1;
    RETURN;

  END IF;
  
  UPDATE aws_sqlserver_ext.sysmail_mailitems
     SET sent_status = 2
       , sent_date = NOW()
   WHERE profile_id = var_profileid 
     AND sent_status <> 1;
   
  DELETE FROM aws_sqlserver_ext.sysmail_profile
   WHERE profile_id = var_profileid;
   
  returncode := 0;
  RETURN;

END;
]]></complex-attribute>
                        <category _I_D="fa666d41-bee2-4186-841e-248d7f50ea65" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f02d0550-c378-4850-8c5d-08974c03d295" name="sysmail_delete_profileaccount_sp" function-id="16655" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sysmail_delete_profileaccount_sp" is-aggregate="f" language-name="plpgsql" context="sysmail_delete_profileaccount_sp" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" count-arguments="4" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_delete_profileaccount_sp(par_profile_id integer, par_profile_name character varying, par_account_id integer, par_account_name character varying, OUT returncode integer)" arguments-datatypes="integer,character varying,integer,character varying,integer" function-arguments="par_profile_id integer DEFAULT NULL::integer, par_profile_name character varying DEFAULT NULL::character varying, par_account_id integer DEFAULT NULL::integer, par_account_name character varying DEFAULT NULL::character varying, OUT returncode integer" function-identity-arguments="par_profile_id integer, par_profile_name character varying, par_account_id integer, par_account_name character varying, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_rc INTEGER;
  var_profileid INTEGER;
  var_accountid INTEGER;
BEGIN

  SELECT t.par_profileid, t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_profile_sp
  (
    par_profile_id,
    par_profile_name,
    1::SMALLINT,
    0::SMALLINT
  ) t
    INTO var_profileid, var_rc;

  IF var_rc <> 0 THEN

    returncode := 1;
    RETURN;

  END IF;

  SELECT t.par_accountid, t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_account_sp
    (
      par_account_id,
      par_account_name,
      1::SMALLINT,
      0::SMALLINT
    ) t
    INTO var_accountid, var_rc;

  IF var_rc <> 0 THEN

    returncode := 2;
    RETURN;

  END IF;

  IF var_profileid IS NOT NULL AND var_accountid IS NOT NULL /* both parameters supplied for deletion */ THEN

    DELETE 
      FROM aws_sqlserver_ext.sysmail_profileaccount
     WHERE profile_id = var_profileid 
       AND account_id = var_accountid;

  ELSE

    IF var_profileid IS NOT NULL /* profile id is supplied */ THEN

      DELETE 
        FROM aws_sqlserver_ext.sysmail_profileaccount
       WHERE profile_id = var_profileid;

    ELSE

      IF var_accountid IS NOT NULL /* account id is supplied */ THEN

        DELETE 
          FROM aws_sqlserver_ext.sysmail_profileaccount
         WHERE account_id = var_accountid;

      ELSE /* no parameters are supplied for deletion */

        RAISE 'Either % or % parameter needs to be supplied', 'profile', 'account' USING ERRCODE := '50000';
        returncode := 3;
        RETURN;

      END IF;

    END IF;

  END IF;
  
  returncode := 0;
  RETURN;

END;
]]></complex-attribute>
                        <category _I_D="8a1b03bd-42b6-4877-a00f-2f7b6820a5b3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="536fd3de-0085-46e2-8a21-c3b233d2d6ed" name="sysmail_help_account_sp" function-id="16657" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sysmail_help_account_sp" is-aggregate="f" language-name="plpgsql" context="sysmail_help_account_sp" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" count-arguments="2" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_help_account_sp(par_account_id integer, par_account_name character varying, OUT returncode integer)" arguments-datatypes="integer,character varying,integer" function-arguments="par_account_id integer DEFAULT NULL::integer, par_account_name character varying DEFAULT NULL::character varying, OUT returncode integer" function-identity-arguments="par_account_id integer, par_account_name character varying, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_rc INTEGER;
  var_accountid INTEGER;
  curs1 REFCURSOR;

  var_c_account_id INTEGER;
  var_c_name VARCHAR(128);
  var_c_description VARCHAR(256);
  var_c_email_address VARCHAR(128);
  var_c_display_name VARCHAR(128);
  var_c_replyto_address VARCHAR(128);

  var_c_servertype VARCHAR(128);-- NOT NULL
  var_c_servername VARCHAR(128);-- NOT NULL
BEGIN

  SELECT t.par_accountid, t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_account_sp
    (
      par_account_id,
      par_account_name,
      1::SMALLINT,
      0::SMALLINT
    ) t
    INTO var_accountid, var_rc;

  IF var_rc <> 0 THEN

    returncode := 1;
    RETURN;

  END IF;
  
  IF var_accountid IS NOT NULL THEN

    OPEN curs1 FOR EXECUTE 
      'SELECT a.account_id, a.name, a.description, a.email_address, a.display_name, a.replyto_address
            , s.servertype, s.servername          
         FROM aws_sqlserver_ext.sysmail_account AS a 
         JOIN aws_sqlserver_ext.sysmail_server AS s
           ON s.account_id = a.account_id
        WHERE a.account_id = $1' USING var_accountid;

  ELSE

    OPEN curs1 FOR EXECUTE 
      'SELECT a.account_id, a.name, a.description, a.email_address, a.display_name, a.replyto_address
            , s.servertype, s.servername          
         FROM aws_sqlserver_ext.sysmail_account AS a 
         JOIN aws_sqlserver_ext.sysmail_server AS s
           ON s.account_id = a.account_id';

  END IF;

  LOOP

    FETCH curs1 INTO var_c_account_id, var_c_name, var_c_description, var_c_email_address, var_c_display_name, var_c_replyto_address, var_c_servertype, var_c_servername;         
    EXIT WHEN NOT FOUND;
    RAISE NOTICE '%', '|--------------------------------------------------------------------------------------------|';
    RAISE NOTICE '%', '| ' || RPAD('ID                  :' || var_c_account_id::character varying, 90) || ' |';
    RAISE NOTICE '%', '| ' || RPAD('Account Name        :' || var_c_name, 90) || ' | ';
    RAISE NOTICE '%', '| ' || RPAD('Account Description :' || COALESCE(var_c_description,' '), 90) || ' | ';
    RAISE NOTICE '%', '| ' || RPAD('E-mail Address      :' || var_c_email_address, 90) || ' | ';
    RAISE NOTICE '%', '| ' || RPAD('Display Name        :' || COALESCE(var_c_display_name,' '), 90) || ' | ';
    RAISE NOTICE '%', '| ' || RPAD('Reply-to Address    :' || COALESCE(var_c_replyto_address,' '), 90) || ' | ';
    RAISE NOTICE '%', '| ' || RPAD('Server Type         :' || COALESCE(var_c_servertype,' '), 90) || ' | ';
    RAISE NOTICE '%', '| ' || RPAD('Server Name         :' || COALESCE(var_c_servername,' '), 90) || ' | ';
    RAISE NOTICE '%', '|--------------------------------------------------------------------------------------------|';

  END LOOP;          
    
  returncode := 0;
  RETURN;

END;
]]></complex-attribute>
                        <category _I_D="4d7de47d-8f68-4c71-8990-5116730e2800" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e33e5a3f-5c11-46ee-aec0-1fcbf1d5cf82" name="sysmail_help_profile_sp" function-id="16659" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sysmail_help_profile_sp" is-aggregate="f" language-name="plpgsql" context="sysmail_help_profile_sp" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" count-arguments="2" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_help_profile_sp(par_profile_id integer, par_profile_name character varying, OUT returncode integer)" arguments-datatypes="integer,character varying,integer" function-arguments="par_profile_id integer DEFAULT NULL::integer, par_profile_name character varying DEFAULT NULL::character varying, OUT returncode integer" function-identity-arguments="par_profile_id integer, par_profile_name character varying, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_rc INTEGER;
  var_profileid INTEGER;
  curs1 REFCURSOR;

  var_c_profile_id INTEGER;
  var_c_name CHARACTER VARYING(128);
  var_c_description CHARACTER VARYING;
BEGIN

  SELECT t.par_profileid, t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_profile_sp
    (
      par_profile_id,
      par_profile_name,
      1::SMALLINT,
      0::SMALLINT
    ) t
    INTO var_profileid, var_rc;

  IF var_rc <> 0 THEN

    returncode := 1;
    RETURN;

  END IF;

  RAISE NOTICE '%', '|-------|--------------------------------|----------------------------------------------------| ';    
  RAISE NOTICE '%', '|  ID   |        Profile Name            |                Profile Description                 | ';
  RAISE NOTICE '%', '|-------|--------------------------------|----------------------------------------------------| ';    
  
  IF var_profileid IS NOT NULL THEN

    OPEN curs1 FOR EXECUTE 'SELECT profile_id, name, description FROM aws_sqlserver_ext.sysmail_profile WHERE profile_id = $1' USING var_profileid;

    LOOP

      FETCH curs1 INTO var_c_profile_id, var_c_name, var_c_description;         
      EXIT WHEN NOT FOUND;
      RAISE NOTICE '%', '| ' || LPAD(var_c_profile_id::TEXT, 5) || ' | ' || LPAD(var_c_name, 30) || ' | ' || LPAD(COALESCE(var_c_description,' '), 50) || ' | ';

    END LOOP;

  ELSE

    OPEN curs1 FOR EXECUTE 'SELECT profile_id, name, description FROM aws_sqlserver_ext.sysmail_profile';

    LOOP

      FETCH curs1 INTO var_c_profile_id, var_c_name, var_c_description;
      EXIT WHEN NOT FOUND;
      RAISE NOTICE '%', '| ' || LPAD(var_c_profile_id::TEXT, 5) || ' | ' || LPAD(var_c_name, 30) || ' | ' || LPAD(COALESCE(var_c_description,' '), 50) || ' | ';

    END LOOP;

  END IF;
    
  returncode := 0;
  RETURN;

END;
]]></complex-attribute>
                        <category _I_D="d7454659-7d2e-4585-afe3-d81dec0e3d73" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="584f5257-fa60-44e9-b9fd-307867b48bad" name="sysmail_help_profileaccount_sp" function-id="16658" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sysmail_help_profileaccount_sp" is-aggregate="f" language-name="plpgsql" context="sysmail_help_profileaccount_sp" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" count-arguments="4" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_help_profileaccount_sp(par_profile_id integer, par_profile_name character varying, par_account_id integer, par_account_name character varying, OUT returncode integer)" arguments-datatypes="integer,character varying,integer,character varying,integer" function-arguments="par_profile_id integer DEFAULT NULL::integer, par_profile_name character varying DEFAULT NULL::character varying, par_account_id integer DEFAULT NULL::integer, par_account_name character varying DEFAULT NULL::character varying, OUT returncode integer" function-identity-arguments="par_profile_id integer, par_profile_name character varying, par_account_id integer, par_account_name character varying, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_rc INTEGER;
  var_profileid INTEGER;
  var_accountid INTEGER;
  curs1 refcursor;
  
  var_c_account_id INTEGER;        -- NOT NULL
  var_c_account_name VARCHAR(128); -- NOT NULL
  var_c_profile_id INTEGER;        -- NOT NULL
  var_c_profile_name VARCHAR(128); -- NOT NULL
  var_c_sequence_number INTEGER;   -- NULL  
BEGIN

  SELECT t.par_profileid, t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_profile_sp(par_profile_id, par_profile_name, 1::smallint, 0::smallint) t
    INTO var_profileid, var_rc;

  IF var_rc <> 0 THEN

    returncode := 1;
    RETURN;

  END IF;

  SELECT t.par_accountid, t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_account_sp(par_account_id, par_account_name, 1::smallint, 0::smallint) t
    INTO var_accountid, var_rc;

  IF var_rc <> 0 THEN

    returncode := 2;
    RETURN;

  END IF;

  RAISE NOTICE '%', '|--------|----------------------|-------|----------------------|------------|';
  RAISE NOTICE '%', '| Acc ID |     Account Name     | Pr ID |     Profile Name     |   Seq #    |';
  RAISE NOTICE '%', '|--------|----------------------|-------|----------------------|------------|';


  IF var_profileid IS NOT NULL AND var_accountid IS NOT NULL THEN

    OPEN curs1 FOR EXECUTE 
      'SELECT a.account_id, a.name AS account_name
            , p.profile_id, p.name AS profile_name
            , pa.sequence_number
         FROM aws_sqlserver_ext.sysmail_profileaccount AS pa
         JOIN aws_sqlserver_ext.sysmail_profile AS p ON p.profile_id = pa.profile_id
         JOIN aws_sqlserver_ext.sysmail_account AS a ON a.account_id = pa.account_id
        WHERE pa.profile_id = $1
          AND pa.account_id = $2' USING var_profileid, var_accountid;

  ELSE

    IF var_profileid IS NOT NULL THEN

      OPEN curs1 FOR EXECUTE 
        'SELECT a.account_id, a.name AS account_name
              , p.profile_id, p.name AS profile_name
              , pa.sequence_number
           FROM aws_sqlserver_ext.sysmail_profileaccount AS pa
           JOIN aws_sqlserver_ext.sysmail_profile AS p ON p.profile_id = pa.profile_id
           JOIN aws_sqlserver_ext.sysmail_account AS a ON a.account_id = pa.account_id
          WHERE pa.profile_id = $1' USING var_profileid;

    ELSE

      IF var_accountid IS NOT NULL THEN

        OPEN curs1 FOR EXECUTE 
          'SELECT a.account_id, a.name AS account_name
                , p.profile_id, p.name AS profile_name
                , pa.sequence_number
             FROM aws_sqlserver_ext.sysmail_profileaccount AS pa
             JOIN aws_sqlserver_ext.sysmail_profile AS p ON p.profile_id = pa.profile_id
             JOIN aws_sqlserver_ext.sysmail_account AS a ON a.account_id = pa.account_id
            WHERE pa.account_id = $1' USING var_accountid;

      ELSE

        OPEN curs1 FOR EXECUTE 
          'SELECT a.account_id, a.name AS account_name
                , p.profile_id, p.name AS profile_name
                , pa.sequence_number
             FROM aws_sqlserver_ext.sysmail_profileaccount AS pa
             JOIN aws_sqlserver_ext.sysmail_profile AS p ON p.profile_id = pa.profile_id
             JOIN aws_sqlserver_ext.sysmail_account AS a ON a.account_id = pa.account_id';

      END IF;

    END IF;

  END IF;
  
  LOOP

    FETCH curs1 INTO var_c_account_id, var_c_account_name, var_c_profile_id, var_c_profile_name, var_c_sequence_number;
    EXIT WHEN NOT FOUND;
    RAISE NOTICE '%', '| '
      || LPAD(var_c_account_id::character varying, 6) || ' | '
      || LPAD(var_c_account_name, 20) || ' | '
      || LPAD(var_c_profile_id::character varying, 5) || ' | '
      || LPAD(var_c_profile_name, 20) || ' | '
      || LPAD(COALESCE(var_c_sequence_number::character varying,' '), 10) || ' | ';

  END LOOP;          

  returncode := 0;
  RETURN;

END;
]]></complex-attribute>
                        <category _I_D="f2affc87-c014-4adb-8cac-2c7add7aafe9" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c981e8a5-d322-4c46-bbb0-841a78d5a761" name="sysmail_set_arn_sp" function-id="16660" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sysmail_set_arn_sp" is-aggregate="f" language-name="plpgsql" context="sysmail_set_arn_sp" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" count-arguments="1" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_set_arn_sp(par_mailserver_name character varying, OUT returncode integer)" arguments-datatypes="character varying,integer" function-arguments="par_mailserver_name character varying DEFAULT NULL::character varying, OUT returncode integer" function-identity-arguments="par_mailserver_name character varying, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

  IF par_mailserver_name IS NULL THEN /* Failure */

    RAISE '% is not a valid mailserver_name', par_mailserver_name USING ERRCODE := '50000';
    returncode := 1;
    RETURN;

  END IF;

  DELETE FROM aws_sqlserver_ext.sysmail_server;

  INSERT INTO aws_sqlserver_ext.sysmail_server
  (
    account_id
  , servertype
  , servername
  ) 
  VALUES
  (
    0
  , 'AWSLAMBDA'
  , par_mailserver_name
  );

  returncode := 0;
  RETURN;

END;
]]></complex-attribute>
                        <category _I_D="72912d0b-63bb-43b7-a191-b02a5dad4ed0" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="17792b90-c99b-4eb9-a30c-0a82e4a94cbd" name="sysmail_update_account_sp" function-id="16661" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sysmail_update_account_sp" is-aggregate="f" language-name="plpgsql" context="sysmail_update_account_sp" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" count-arguments="15" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_update_account_sp(par_account_id integer, par_account_name character varying, par_email_address character varying, par_display_name character varying, par_replyto_address character varying, par_description character varying, par_mailserver_name character varying, par_mailserver_type character varying, par_port integer, par_username character varying, par_password character varying, par_use_default_credentials smallint, par_enable_ssl smallint, par_timeout integer, par_no_credential_change smallint, OUT returncode integer)" arguments-datatypes="integer,character varying,character varying,character varying,character varying,character varying,character varying,character varying,integer,character varying,character varying,smallint,smallint,integer,smallint,integer" function-arguments="par_account_id integer DEFAULT NULL::integer, par_account_name character varying DEFAULT NULL::character varying, par_email_address character varying DEFAULT NULL::character varying, par_display_name character varying DEFAULT NULL::character varying, par_replyto_address character varying DEFAULT NULL::character varying, par_description character varying DEFAULT NULL::character varying, par_mailserver_name character varying DEFAULT NULL::character varying, par_mailserver_type character varying DEFAULT NULL::character varying, par_port integer DEFAULT NULL::integer, par_username character varying DEFAULT NULL::character varying, par_password character varying DEFAULT NULL::character varying, par_use_default_credentials smallint DEFAULT NULL::smallint, par_enable_ssl smallint DEFAULT NULL::smallint, par_timeout integer DEFAULT NULL::integer, par_no_credential_change smallint DEFAULT NULL::smallint, OUT returncode integer" function-identity-arguments="par_account_id integer, par_account_name character varying, par_email_address character varying, par_display_name character varying, par_replyto_address character varying, par_description character varying, par_mailserver_name character varying, par_mailserver_type character varying, par_port integer, par_username character varying, par_password character varying, par_use_default_credentials smallint, par_enable_ssl smallint, par_timeout integer, par_no_credential_change smallint, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_rc INTEGER;
  var_accountid INTEGER;
BEGIN

  SELECT t.par_accountid, t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_account_sp
    (
      par_account_id,
      par_account_name,
      0::SMALLINT,
      1::SMALLINT
    ) t
    INTO var_accountid, var_rc;

  IF var_rc <> 0 THEN

    returncode := 1;
    RETURN;

  END IF;

  IF par_email_address IS NULL THEN

    SELECT email_address
      INTO par_email_address
      FROM aws_sqlserver_ext.sysmail_account
     WHERE account_id = var_accountid;

  END IF;

  IF par_display_name IS NULL THEN

    SELECT display_name
      INTO par_display_name
      FROM aws_sqlserver_ext.sysmail_account
     WHERE account_id = var_accountid;

  END IF;

  IF par_replyto_address IS NULL THEN

    SELECT replyto_address
      INTO par_replyto_address
      FROM aws_sqlserver_ext.sysmail_account
     WHERE account_id = var_accountid;

  END IF;

  IF par_description IS NULL THEN

    SELECT description
      INTO par_description
      FROM aws_sqlserver_ext.sysmail_account
     WHERE account_id = var_accountid;

  END IF;
  
  /* update account table */
  IF par_account_name IS NOT NULL THEN

    IF par_email_address IS NOT NULL THEN

      UPDATE aws_sqlserver_ext.sysmail_account
         SET name = par_account_name
           , description = par_description
           , email_address = par_email_address
           , display_name = par_display_name
           , replyto_address = par_replyto_address
       WHERE account_id = var_accountid;

    ELSE

      UPDATE aws_sqlserver_ext.sysmail_account
         SET name = par_account_name
           , description = par_description
           , display_name = par_display_name
           , replyto_address = par_replyto_address
       WHERE account_id = var_accountid;

    END IF;

  ELSE

    IF par_email_address IS NOT NULL THEN

      UPDATE aws_sqlserver_ext.sysmail_account
         SET description = par_description
           , email_address = par_email_address
           , display_name = par_display_name
           , replyto_address = par_replyto_address
       WHERE account_id = var_accountid;

    ELSE

      UPDATE aws_sqlserver_ext.sysmail_account
         SET description = par_description
           , display_name = par_display_name
           , replyto_address = par_replyto_address
       WHERE account_id = var_accountid;

    END IF;

  END IF;

  returncode := 0;
  RETURN;

END;
]]></complex-attribute>
                        <category _I_D="8ca98722-61c1-449e-9a97-e254691d2d81" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f97a3865-a325-4e0e-ae12-574227d9f7f7" name="sysmail_update_profile_sp" function-id="16663" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sysmail_update_profile_sp" is-aggregate="f" language-name="plpgsql" context="sysmail_update_profile_sp" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" count-arguments="3" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_update_profile_sp(par_profile_id integer, par_profile_name character varying, par_description character varying, OUT returncode integer)" arguments-datatypes="integer,character varying,character varying,integer" function-arguments="par_profile_id integer DEFAULT NULL::integer, par_profile_name character varying DEFAULT NULL::character varying, par_description character varying DEFAULT NULL::character varying, OUT returncode integer" function-identity-arguments="par_profile_id integer, par_profile_name character varying, par_description character varying, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_rc INTEGER;
  var_profileid INTEGER;
BEGIN

  SELECT t.par_profileid, t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_profile_sp
    (
      par_profile_id,
      par_profile_name,
      0::SMALLINT,
      1::SMALLINT
    ) t
    INTO var_profileid, var_rc;

  IF var_rc <> 0 THEN

    returncode := 1;
    RETURN;

  END IF;

  IF par_profile_name IS NOT NULL AND par_description IS NOT NULL THEN

    UPDATE aws_sqlserver_ext.sysmail_profile
       SET name = par_profile_name
         , description = par_description
     WHERE profile_id = var_profileid;

  ELSE

    IF par_profile_name IS NOT NULL THEN

      UPDATE aws_sqlserver_ext.sysmail_profile
         SET name = par_profile_name
       WHERE profile_id = var_profileid;

    ELSE

      IF par_description IS NOT NULL THEN

        UPDATE aws_sqlserver_ext.sysmail_profile
           SET description = par_description
         WHERE profile_id = var_profileid;

      ELSE

        RAISE 'Either par_profile_name or par_description parameter needs to be specified for update' USING ERRCODE := '50000';
        returncode := 1;
        RETURN;

      END IF;

    END IF;

  END IF;
  
  returncode := 0;
  RETURN;

END;
]]></complex-attribute>
                        <category _I_D="fde11d21-9311-42ff-b1bd-06c7dfab6988" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="032d9fbd-cffe-4159-9597-a5e46f984fdd" name="sysmail_update_profileaccount_sp" function-id="16662" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sysmail_update_profileaccount_sp" is-aggregate="f" language-name="plpgsql" context="sysmail_update_profileaccount_sp" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" count-arguments="5" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_update_profileaccount_sp(par_profile_id integer, par_profile_name character varying, par_account_id integer, par_account_name character varying, par_sequence_number integer, OUT returncode integer)" arguments-datatypes="integer,character varying,integer,character varying,integer,integer" function-arguments="par_profile_id integer DEFAULT NULL::integer, par_profile_name character varying DEFAULT NULL::character varying, par_account_id integer DEFAULT NULL::integer, par_account_name character varying DEFAULT NULL::character varying, par_sequence_number integer DEFAULT NULL::integer, OUT returncode integer" function-identity-arguments="par_profile_id integer, par_profile_name character varying, par_account_id integer, par_account_name character varying, par_sequence_number integer, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_rc INTEGER;
  var_profileid INTEGER;
  var_accountid INTEGER;
BEGIN

  SELECT t.par_profileid, t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_profile_sp
    (
      par_profile_id,
      par_profile_name,
      0::SMALLINT,
      0::SMALLINT
    ) t
    INTO var_profileid, var_rc;

  IF var_rc <> 0 THEN

    returncode := 1;
    RETURN;

  END IF;

  SELECT t.par_accountid, t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_account_sp
    (
      par_account_id,
      par_account_name,
      0::SMALLINT,
      0::SMALLINT
    ) t
    INTO var_accountid, var_rc;

  IF var_rc <> 0 THEN

    returncode := 2;
    RETURN;

  END IF;

  IF par_sequence_number IS NULL THEN

    RAISE 'Account sequence number must be supplied for update' USING ERRCODE := '50000';
    returncode := 3;
    RETURN;

  END IF;
  
  UPDATE aws_sqlserver_ext.sysmail_profileaccount
     SET sequence_number = par_sequence_number
   WHERE profile_id = var_profileid 
     AND account_id = var_accountid;
     
  returncode := 0;
  RETURN;

END;
]]></complex-attribute>
                        <category _I_D="36018a71-08fd-4a59-a025-725fb28fd128" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="03efea77-956e-47c5-8e67-673817068c20" name="sysmail_verify_account_sp" function-id="16664" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sysmail_verify_account_sp" is-aggregate="f" language-name="plpgsql" context="sysmail_verify_account_sp" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="record" count-arguments="4" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_verify_account_sp(par_account_id integer, par_account_name character varying, par_allow_both_nulls smallint, par_allow_id_name_mismatch smallint, OUT par_accountid integer, OUT returncode integer)" arguments-datatypes="integer,character varying,smallint,smallint,integer,integer" function-arguments="par_account_id integer, par_account_name character varying, par_allow_both_nulls smallint, par_allow_id_name_mismatch smallint, OUT par_accountid integer, OUT returncode integer" function-identity-arguments="par_account_id integer, par_account_name character varying, par_allow_both_nulls smallint, par_allow_id_name_mismatch smallint, OUT par_accountid integer, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

  /* at least one parameter must be supplied */
  IF par_allow_both_nulls = 0 THEN

    IF par_account_id IS NULL AND par_account_name IS NULL THEN

      RAISE 'Both % parameters (id and name) cannot be NULL', 'account' USING ERRCODE := '50000';
      returncode := 1;
      RETURN;

    END IF;

  END IF;

  /* use both parameters */
  IF (par_allow_id_name_mismatch = 0) AND (par_account_id IS NOT NULL AND par_account_name IS NOT NULL) THEN

    SELECT account_id
      INTO par_accountid
      FROM aws_sqlserver_ext.sysmail_account
     WHERE account_id = par_account_id
     AND name = par_account_name;

    IF par_accountid IS NULL /* id and name do not match */ THEN

      RAISE 'Both % parameters (id and name) do not point to the same object', 'account' USING ERRCODE := '50000';
      returncode := 2;
      RETURN;

    END IF;

  ELSE

    IF par_account_id IS NOT NULL /* use id */ THEN

      SELECT account_id
        INTO par_accountid
        FROM aws_sqlserver_ext.sysmail_account
       WHERE account_id = par_account_id;
    
      IF par_accountid IS NULL /* id is invalid */ THEN

        RAISE '% id is not valid', 'account' USING ERRCODE := '50000';
        returncode := 3;
        RETURN;

      END IF;

    ELSE

      IF par_account_name IS NOT NULL /* use name */ THEN

        SELECT account_id
          INTO par_accountid
          FROM aws_sqlserver_ext.sysmail_account
         WHERE name = par_account_name;

        IF par_accountid IS NULL /* name is invalid */ THEN

          RAISE '% name is not valid', 'account' USING ERRCODE := '50000';
          returncode := 4;
          RETURN;

        END IF;

      END IF;

    END IF;

  END IF;

  /* SUCCESS */  
  returncode := 0;
  RETURN;

END;
]]></complex-attribute>
                        <category _I_D="fd09e2de-9a78-4f6e-8cb2-069e0e613597" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="4a54e98f-7b1e-45e2-ad42-72118c83c8c4" name="sysmail_verify_addressparams_sp" function-id="16665" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sysmail_verify_addressparams_sp" is-aggregate="f" language-name="plpgsql" context="sysmail_verify_addressparams_sp" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" count-arguments="2" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_verify_addressparams_sp(par_address text, par_parameter_name character varying, OUT returncode integer)" arguments-datatypes="text,character varying,integer" function-arguments="par_address text, par_parameter_name character varying, OUT returncode integer" function-identity-arguments="par_address text, par_parameter_name character varying, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_commaIndex INTEGER;
BEGIN

  IF par_address IS NOT NULL AND LOWER(par_address) != LOWER('') THEN

    var_commaIndex := STRPOS(par_address, ',');

    IF var_commaIndex > 0 THEN

      RAISE 'The specified "%" cannot use commas (,) to separate addresses: "%". To continue, use semicolons (;) to separate addresses.', par_parameter_name, par_address USING ERRCODE := '50000';
      returncode := 1;
      RETURN;

    END IF;

  END IF;
  
  returncode := 0;
  RETURN;

END;
]]></complex-attribute>
                        <category _I_D="87487369-f3ad-406a-a2b6-2ca1ec71370a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a051626d-dcd6-4a3c-9cf0-1ac99425422c" name="sysmail_verify_profile_sp" function-id="16666" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="sysmail_verify_profile_sp" is-aggregate="f" language-name="plpgsql" context="sysmail_verify_profile_sp" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="record" count-arguments="4" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_verify_profile_sp(par_profile_id integer, par_profile_name character varying, par_allow_both_nulls smallint, par_allow_id_name_mismatch smallint, OUT par_profileid integer, OUT returncode integer)" arguments-datatypes="integer,character varying,smallint,smallint,integer,integer" function-arguments="par_profile_id integer, par_profile_name character varying, par_allow_both_nulls smallint, par_allow_id_name_mismatch smallint, OUT par_profileid integer, OUT returncode integer" function-identity-arguments="par_profile_id integer, par_profile_name character varying, par_allow_both_nulls smallint, par_allow_id_name_mismatch smallint, OUT par_profileid integer, OUT returncode integer">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

  IF par_allow_both_nulls = 0
  THEN /* at least one parameter must be supplied */

    IF par_profile_id IS NULL AND par_profile_name IS NULL THEN

      RAISE 'Both % parameters (id and name) cannot be NULL', 'profile' USING ERRCODE := '50000';
      returncode := 1;
      RETURN;

    END IF;

  END IF;

  /* use both parameters */
  IF (par_allow_id_name_mismatch = 0) AND (par_profile_id IS NOT NULL AND par_profile_name IS NOT NULL) THEN

    SELECT profile_id
      INTO par_profileid
      FROM aws_sqlserver_ext.sysmail_profile
     WHERE profile_id = par_profile_id
     AND name = par_profile_name;

    IF (par_profileid IS NULL) /* id and name do not match */
    THEN

      RAISE 'Both % parameters (id and name) do not point to the same object', 'profile' USING ERRCODE := '50000';
      returncode := 2;
      RETURN;

    END IF;

  ELSE 

    IF par_profile_id IS NOT NULL /* use id */ THEN

      SELECT profile_id
        INTO par_profileid
        FROM aws_sqlserver_ext.sysmail_profile
       WHERE profile_id = par_profile_id;

      IF par_profileid IS NULL /* id is invalid */ THEN

        RAISE '% id is not valid', 'profile' USING ERRCODE := '50000';
        returncode := 3;
        RETURN;

      END IF;

    ELSE

      IF par_profile_name IS NOT NULL /* use name */ THEN

        SELECT profile_id
          INTO par_profileid
          FROM aws_sqlserver_ext.sysmail_profile
         WHERE name = par_profile_name;

        IF par_profileid IS NULL /* name is invalid */ THEN

          RAISE '% name is not valid', 'profile' USING ERRCODE := '50000';
          returncode := 4;
          RETURN;

        END IF;

      END IF;

    END IF;

  END IF;
  
  returncode := 0;
  RETURN;

END;
]]></complex-attribute>
                        <category _I_D="61b57ab3-126d-4453-87b5-50bb429ce840" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0a28a949-1702-4bb1-abff-0bebdfe0aeed" name="timefromparts" function-id="16561" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="timefromparts(p_hour numeric, p_minute numeric, p_seconds numeric, p_fractions numeric, p_precision numeric)" is-aggregate="f" language-name="plpgsql" context="timefromparts(p_hour numeric, p_minute numeric, p_seconds numeric, p_fractions numeric, p_precision numeric)" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="time" count-arguments="5" volatility="VOLATILE" is-window="f" overload-function-count="2" proc-language="plpgsql" function-signature="timefromparts(p_hour numeric, p_minute numeric, p_seconds numeric, p_fractions numeric, p_precision numeric)" arguments-datatypes="numeric,numeric,numeric,numeric,numeric" comment="This function returns a fully initialized TIME value, constructed from separate time parts." unique-suffix="(p_hour numeric, p_minute numeric, p_seconds numeric, p_fractions numeric, p_precision numeric)" routine-number="16561" function-arguments="p_hour numeric, p_minute numeric, p_seconds numeric, p_fractions numeric, p_precision numeric" function-identity-arguments="p_hour numeric, p_minute numeric, p_seconds numeric, p_fractions numeric, p_precision numeric">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_fractions VARCHAR;
    v_precision SMALLINT;
    v_err_message VARCHAR;
    v_calc_seconds NUMERIC;
BEGIN
    v_fractions := floor(p_fractions)::INTEGER::VARCHAR;
    v_precision := p_precision::SMALLINT;

    IF (scale(p_precision) > 0) THEN
        RAISE most_specific_type_mismatch;
    ELSIF ((p_hour NOT BETWEEN 0 AND 23) OR
           (p_minute NOT BETWEEN 0 AND 59) OR
           (p_seconds NOT BETWEEN 0 AND 59) OR
           (p_fractions NOT BETWEEN 0 AND 9999999) OR
           (p_fractions != 0 AND char_length(v_fractions) > p_precision))
    THEN
        RAISE invalid_datetime_format;
    ELSIF (v_precision NOT BETWEEN 0 AND 7) THEN
        RAISE numeric_value_out_of_range;
    END IF;

    v_calc_seconds := format('%s.%s',
                             floor(p_seconds)::SMALLINT,
                             substring(rpad(lpad(v_fractions, v_precision, '0'), 7, '0'), 1, 6))::NUMERIC;

    RETURN make_time(floor(p_hour)::SMALLINT,
                     floor(p_minute)::SMALLINT,
                     v_calc_seconds);
EXCEPTION
    WHEN most_specific_type_mismatch THEN
        RAISE USING MESSAGE := 'Scale argument is not valid. Valid expressions for data type DATETIME2 scale argument are integer constants and integer constant expressions.',
                    DETAIL := 'Use of incorrect "precision" parameter value during conversion process.',
                    HINT := 'Change "precision" parameter to the proper value and try again.';

    WHEN invalid_parameter_value THEN
        RAISE USING MESSAGE := format('Specified scale %s is invalid.', v_precision),
                    DETAIL := 'Use of incorrect "precision" parameter value during conversion process.',
                    HINT := 'Change "precision" parameter to the proper value and try again.';

    WHEN invalid_datetime_format THEN
        RAISE USING MESSAGE := 'Cannot construct data type time, some of the arguments have values which are not valid.',
                    DETAIL := 'Possible use of incorrect value of time part (which lies outside of valid range).',
                    HINT := 'Check each input argument belongs to the valid range and try again.';

    WHEN numeric_value_out_of_range THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
        v_err_message := upper(split_part(v_err_message, ' ', 1));

        RAISE USING MESSAGE := format('Error while trying to cast to %s data type.', v_err_message),
                    DETAIL := format('Source value is out of %s data type range.', v_err_message),
                    HINT := format('Correct the source value you are trying to cast to %s data type and try again.',
                                   v_err_message);
END;
]]></complex-attribute>
                        <category _I_D="80a15f27-90c4-4a85-99f8-bf2d63beaf33" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="444a1bbf-9ca0-486d-a547-70e38c1bb248" name="timefromparts" function-id="16562" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="timefromparts(p_hour text, p_minute text, p_seconds text, p_fractions text, p_precision text)" is-aggregate="f" language-name="plpgsql" context="timefromparts(p_hour text, p_minute text, p_seconds text, p_fractions text, p_precision text)" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="time" count-arguments="5" volatility="VOLATILE" is-window="f" overload-function-count="2" proc-language="plpgsql" function-signature="timefromparts(p_hour text, p_minute text, p_seconds text, p_fractions text, p_precision text)" arguments-datatypes="text,text,text,text,text" comment="This function returns a fully initialized TIME value, constructed from separate time parts." unique-suffix="(p_hour text, p_minute text, p_seconds text, p_fractions text, p_precision text)" routine-number="16562" function-arguments="p_hour text, p_minute text, p_seconds text, p_fractions text, p_precision text" function-identity-arguments="p_hour text, p_minute text, p_seconds text, p_fractions text, p_precision text">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_err_message VARCHAR;
BEGIN
    RETURN aws_sqlserver_ext.timefromparts(p_hour::NUMERIC, p_minute::NUMERIC,
                                           p_seconds::NUMERIC, p_fractions::NUMERIC,
                                           p_precision::NUMERIC);
EXCEPTION
    WHEN invalid_text_representation THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
        v_err_message := substring(lower(v_err_message), 'numeric\:\s\"(.*)\"');

        RAISE USING MESSAGE := format('Error while trying to convert "%s" value to NUMERIC data type.', v_err_message),
                    DETAIL := 'Supplied string value contains illegal characters.',
                    HINT := 'Correct supplied value, remove all illegal characters and try again.';
END;
]]></complex-attribute>
                        <category _I_D="7d510e71-1344-49c8-9a73-b6644fdd3a68" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="72976843-9585-4046-af1e-46734b2772f8" name="tomsbit" function-id="16668" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="tomsbit(in_str character varying)" is-aggregate="f" language-name="plpgsql" context="tomsbit(in_str character varying)" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int2" count-arguments="1" volatility="VOLATILE" is-window="f" overload-function-count="2" proc-language="plpgsql" function-signature="tomsbit(in_str character varying)" arguments-datatypes="character varying" unique-suffix="(in_str character varying)" routine-number="16668" function-arguments="in_str character varying" function-identity-arguments="in_str character varying">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
  CASE
    WHEN LOWER(in_str) = 'true' OR in_str = '1' THEN RETURN 1;
    WHEN LOWER(in_str) = 'false' OR in_str = '0' THEN RETURN 0;
    ELSE RETURN 0;
  END CASE;
END;
]]></complex-attribute>
                        <category _I_D="1ee34cdb-b3ad-4e6e-9620-eca5f6280f4f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="fe05d5ab-5a9c-49c4-bcad-37363cd92b1c" name="tomsbit" function-id="16667" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="tomsbit(in_str numeric)" is-aggregate="f" language-name="plpgsql" context="tomsbit(in_str numeric)" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int2" count-arguments="1" volatility="VOLATILE" is-window="f" overload-function-count="2" proc-language="plpgsql" function-signature="tomsbit(in_str numeric)" arguments-datatypes="numeric" unique-suffix="(in_str numeric)" routine-number="16667" function-arguments="in_str numeric" function-identity-arguments="in_str numeric">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
  CASE
    WHEN in_str < 0 OR in_str > 0 THEN RETURN 1;
    ELSE RETURN 0;
  END CASE;
END;
]]></complex-attribute>
                        <category _I_D="118684d8-91cf-4cd4-b5e3-8f48d539c204" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e10dffe4-b106-4c0f-864f-f3ca80d66866" name="try_conv_date_to_string" function-id="16579" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="try_conv_date_to_string" is-aggregate="f" language-name="plpgsql" context="try_conv_date_to_string" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="text" count-arguments="3" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="try_conv_date_to_string(p_datatype text, p_dateval date, p_style numeric)" arguments-datatypes="text,date,numeric" comment="This function converts the DATE value into a character string, according to specified style (conversion mask). &amp;#x000a;If the conversion not successful, the function returns NULL." function-arguments="p_datatype text, p_dateval date, p_style numeric DEFAULT 20" function-identity-arguments="p_datatype text, p_dateval date, p_style numeric">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    RETURN aws_sqlserver_ext.conv_date_to_string(p_datatype,
                                                 p_dateval,
                                                 p_style);
EXCEPTION
    WHEN OTHERS THEN
        RETURN NULL;
END;
]]></complex-attribute>
                        <category _I_D="b328670a-55e5-46d8-b208-d9e3cbc6b62d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="dc79048c-a09c-4037-95b9-9b66fb11bcf0" name="try_conv_datetime_to_string" function-id="16580" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="try_conv_datetime_to_string" is-aggregate="f" language-name="plpgsql" context="try_conv_datetime_to_string" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="text" count-arguments="4" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="try_conv_datetime_to_string(p_datatype text, p_src_datatype text, p_datetimeval timestamp without time zone, p_style numeric)" arguments-datatypes="text,text,timestamp without time zone,numeric" comment="This function converts the DATETIME value into a character string, according to specified style (conversion mask). &amp;#x000a;If the conversion not successful, the function returns NULL." function-arguments="p_datatype text, p_src_datatype text, p_datetimeval timestamp without time zone, p_style numeric DEFAULT '-1'::integer" function-identity-arguments="p_datatype text, p_src_datatype text, p_datetimeval timestamp without time zone, p_style numeric">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    RETURN aws_sqlserver_ext.conv_datetime_to_string(p_datatype,
                                                     p_src_datatype,
                                                     p_datetimeval,
                                                     p_style);
EXCEPTION
    WHEN OTHERS THEN
        RETURN NULL;
END;
]]></complex-attribute>
                        <category _I_D="1cd001ff-ef30-4d79-86ba-a6a15710de2f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d4c63409-82e6-4e1d-9411-557b807fa627" name="try_conv_string_to_date" function-id="16582" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="try_conv_string_to_date" is-aggregate="f" language-name="plpgsql" context="try_conv_string_to_date" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="date" count-arguments="2" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="try_conv_string_to_date(p_datestring text, p_style numeric)" arguments-datatypes="text,numeric" comment="This function parses the TEXT string and converts it into a DATE value, according to specified style (conversion mask). &amp;#x000a;If the conversion not successful, the function returns NULL." function-arguments="p_datestring text, p_style numeric DEFAULT 0" function-identity-arguments="p_datestring text, p_style numeric">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    RETURN aws_sqlserver_ext.conv_string_to_date(p_datestring,
                                                 p_style);
EXCEPTION
    WHEN OTHERS THEN
        RETURN NULL;
END;
]]></complex-attribute>
                        <category _I_D="27abf40b-0256-47a5-b533-3edbf190dfce" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f95501fb-10e1-4fb8-b9ad-2c5f44a5103b" name="try_conv_string_to_datetime" function-id="16583" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="try_conv_string_to_datetime" is-aggregate="f" language-name="plpgsql" context="try_conv_string_to_datetime" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="timestamp" count-arguments="3" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="try_conv_string_to_datetime(p_datatype text, p_datetimestring text, p_style numeric)" arguments-datatypes="text,text,numeric" comment="This function parses the TEXT string and converts it into a DATETIME value, according to specified style (conversion mask). &amp;#x000a;If the conversion not successfull, the function returns NULL." function-arguments="p_datatype text, p_datetimestring text, p_style numeric DEFAULT 0" function-identity-arguments="p_datatype text, p_datetimestring text, p_style numeric">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    RETURN aws_sqlserver_ext.conv_string_to_datetime(p_datatype,
                                                     p_datetimestring ,
                                                     p_style);
EXCEPTION
    WHEN OTHERS THEN
        RETURN NULL;
END;
]]></complex-attribute>
                        <category _I_D="7959a1b4-277b-4c77-92f5-6af2542ab76c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f6868b20-644c-418e-bebe-df454268dbe0" name="try_conv_string_to_time" function-id="16584" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="try_conv_string_to_time" is-aggregate="f" language-name="plpgsql" context="try_conv_string_to_time" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="time" count-arguments="3" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="try_conv_string_to_time(p_datatype text, p_timestring text, p_style numeric)" arguments-datatypes="text,text,numeric" comment="This function parses the TEXT string and converts it into a TIME value, according to specified style (conversion mask). &amp;#x000a;If the conversion not successfull, the function returns NULL." function-arguments="p_datatype text, p_timestring text, p_style numeric DEFAULT 0" function-identity-arguments="p_datatype text, p_timestring text, p_style numeric">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    RETURN aws_sqlserver_ext.conv_string_to_time(p_datatype,
                                                 p_timestring,
                                                 p_style);
EXCEPTION
    WHEN OTHERS THEN
        RETURN NULL;
END;
]]></complex-attribute>
                        <category _I_D="ef151fbb-911a-4392-aef2-bce2aabb9d49" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="810ea56a-b7ef-483a-ae6d-175deaf54c01" name="try_conv_time_to_string" function-id="16581" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="try_conv_time_to_string" is-aggregate="f" language-name="plpgsql" context="try_conv_time_to_string" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="text" count-arguments="4" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="try_conv_time_to_string(p_datatype text, p_src_datatype text, p_timeval time without time zone, p_style numeric)" arguments-datatypes="text,text,time without time zone,numeric" comment="This function converts the TIME value into a character string, according to specified style (conversion mask). &amp;#x000a;If the conversion not successful, the function returns NULL." function-arguments="p_datatype text, p_src_datatype text, p_timeval time without time zone, p_style numeric DEFAULT 25" function-identity-arguments="p_datatype text, p_src_datatype text, p_timeval time without time zone, p_style numeric">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    RETURN aws_sqlserver_ext.conv_time_to_string(p_datatype,
                                                 p_src_datatype,
                                                 p_timeval,
                                                 p_style);
EXCEPTION
    WHEN OTHERS THEN
        RETURN NULL;
END;
]]></complex-attribute>
                        <category _I_D="f9b93c53-31d3-4b88-b420-4591f71b1161" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="92451208-4c0b-4ab4-89d8-a592243df11a" name="try_parse_to_date" function-id="16591" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="try_parse_to_date" is-aggregate="f" language-name="plpgsql" context="try_parse_to_date" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="date" count-arguments="2" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="try_parse_to_date(p_datestring text, p_culture text)" arguments-datatypes="text,text" comment="This function parses the TEXT string and translate it into a DATE value, according to specified culture (conversion mask). &amp;#x000a;If the conversion not successful, the function returns NULL." function-arguments="p_datestring text, p_culture text DEFAULT NULL::text" function-identity-arguments="p_datestring text, p_culture text">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    RETURN aws_sqlserver_ext.parse_to_date(p_datestring,
                                           p_culture);
EXCEPTION
    WHEN OTHERS THEN
        RETURN NULL;
END;
]]></complex-attribute>
                        <category _I_D="dd6c9d03-c37f-4a72-9f00-23f937fcf0ea" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="64c5bb8f-8b6a-4616-a5cf-4cef656c77a5" name="try_parse_to_datetime" function-id="16592" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="try_parse_to_datetime" is-aggregate="f" language-name="plpgsql" context="try_parse_to_datetime" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="timestamp" count-arguments="3" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="try_parse_to_datetime(p_datatype text, p_datetimestring text, p_culture text)" arguments-datatypes="text,text,text" comment="This function parses the TEXT string and translate it into a DATETIME value, according to specified culture (conversion mask). &amp;#x000a;If the conversion not successful, the function returns NULL." function-arguments="p_datatype text, p_datetimestring text, p_culture text DEFAULT ''::text" function-identity-arguments="p_datatype text, p_datetimestring text, p_culture text">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    RETURN aws_sqlserver_ext.try_parse_to_datetime(p_datatype,
                                                   p_datestring,
                                                   p_culture);
EXCEPTION
    WHEN OTHERS THEN
        RETURN NULL;
END;
]]></complex-attribute>
                        <category _I_D="920d1816-9fdf-4379-bbd4-bc84b28fca77" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="bc009262-a965-4c86-8d1e-cbba866cef90" name="try_parse_to_time" function-id="16593" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="try_parse_to_time" is-aggregate="f" language-name="plpgsql" context="try_parse_to_time" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="timestamp" count-arguments="3" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="try_parse_to_time(p_datatype text, p_srctimestring text, p_culture text)" arguments-datatypes="text,text,text" comment="This function parses the TEXT string and translate it into a TIME value, according to specified culture (conversion mask). &amp;#x000a;If the conversion not successful, the function returns NULL." function-arguments="p_datatype text, p_srctimestring text, p_culture text DEFAULT ''::text" function-identity-arguments="p_datatype text, p_srctimestring text, p_culture text">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    RETURN aws_sqlserver_ext.parse_to_time(p_datatype,
                                           p_srctimestring,
                                           p_culture);
EXCEPTION
    WHEN OTHERS THEN
        RETURN NULL;
END;
]]></complex-attribute>
                        <category _I_D="f837e6e7-db57-4679-b05e-3c0d5b998438" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="505923d4-3617-4d6f-a9db-15afde0fb25c" name="update_job" function-id="16669" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="update_job" is-aggregate="f" language-name="plpgsql" context="update_job" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" count-arguments="2" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="update_job(p_job integer, p_error_message character varying)" arguments-datatypes="integer,character varying" function-arguments="p_job integer, p_error_message character varying" function-identity-arguments="p_job integer, p_error_message character varying">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_enabled smallint;
  var_freq_type integer;
  var_freq_interval integer;
  var_freq_subday_type integer;
  var_freq_subday_interval integer;
  var_freq_relative_interval integer;
  var_freq_recurrence_factor integer;
  var_tmp_interval varchar(50);
  var_job_id integer;
  var_schedule_id integer;
  var_job_step_id integer;
  var_step_id integer;
  var_step_name VARCHAR(128);
BEGIN
  /*
  var_job_step_id := p_job;

  SELECT jst.job_id, jsc.schedule_id, jst.step_name, jst.step_id 
    FROM aws_sqlserver_ext.sysjobsteps jst
   INNER JOIN aws_sqlserver_ext.sysjobschedules jsc
      ON jsc.job_id = jst.job_id
    INTO var_job_id, var_schedule_id, var_step_name, var_step_id  
   WHERE jst.job_step_id = var_job_step_id;
  */
  INSERT 
    INTO aws_sqlserver_ext.sysjobhistory (
         job_id
       , step_id
       , step_name
       , sql_message_id
       , sql_severity
       , message
       , run_status
       , run_date
       , run_time
       , run_duration
       , operator_id_emailed
       , operator_id_netsent
       , operator_id_paged
       , retries_attempted
       , server)
  VALUES (
         p_job
       , 0 -- var_step_id
       , ''--var_step_name
       , 0
       , 0
       , p_error_message
       , 0
       , now()::date
       , now()::time
       , 0
       , 0
       , 0
       , 0
       , 0
       , ''::character varying);
  
  -- PERFORM aws_sqlserver_ext.sp_set_next_run (var_job_id, var_schedule_id);

END;
]]></complex-attribute>
                        <category _I_D="a6b80c10-87b6-4da7-b2c1-d228aaeaab8a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ca50c89c-fdf3-4c2e-9ca9-83f8ed49518a" name="waitfor_delay" function-id="16874" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="waitfor_delay(time_to_pass text)" is-aggregate="f" language-name="sql" context="waitfor_delay(time_to_pass text)" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" count-arguments="1" volatility="VOLATILE" is-window="f" overload-function-count="2" proc-language="sql" function-signature="waitfor_delay(time_to_pass text)" arguments-datatypes="text" unique-suffix="(time_to_pass text)" routine-number="16874" function-arguments="time_to_pass text" function-identity-arguments="time_to_pass text">
                        <complex-attribute name="sql"><![CDATA[
  SELECT pg_sleep(EXTRACT(HOUR FROM $1::time)*60*60 +
                  EXTRACT(MINUTE FROM $1::time)*60 +
                  TRUNC(EXTRACT(SECOND FROM $1::time)) +
                  aws_sqlserver_ext.round_fractseconds(
                                                        (
                                                          EXTRACT(MILLISECONDS FROM $1::time)
                                                          - TRUNC(EXTRACT(SECOND FROM $1::time)) * 1000
                                                        )::numeric
                                                      )/1000::numeric);
]]></complex-attribute>
                        <category _I_D="10ecde53-95ae-442f-8daf-e707f12ba6be" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="af46f359-d6a6-48fb-8f32-862e33a28126" name="waitfor_delay" function-id="16873" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="0" unique-function-name="waitfor_delay(time_to_pass timestamp without time zone)" is-aggregate="f" language-name="sql" context="waitfor_delay(time_to_pass timestamp without time zone)" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" count-arguments="1" volatility="VOLATILE" is-window="f" overload-function-count="2" proc-language="sql" function-signature="waitfor_delay(time_to_pass timestamp without time zone)" arguments-datatypes="timestamp without time zone" unique-suffix="(time_to_pass timestamp without time zone)" routine-number="16873" function-arguments="time_to_pass timestamp without time zone" function-identity-arguments="time_to_pass timestamp without time zone">
                        <complex-attribute name="sql"><![CDATA[
  SELECT pg_sleep(EXTRACT(HOUR FROM $1::time)*60*60 +
                  EXTRACT(MINUTE FROM $1::time)*60 +
                  TRUNC(EXTRACT(SECOND FROM $1::time)) +
                  aws_sqlserver_ext.round_fractseconds(
                                                        (
                                                          EXTRACT(MILLISECONDS FROM $1::time)
                                                          - TRUNC(EXTRACT(SECOND FROM $1::time)) * 1000
                                                        )::numeric
                                                      )/1000::numeric);
]]></complex-attribute>
                        <category _I_D="c342cb79-5fe9-499c-8714-dba1017ecc14" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                </category>
                <category _I_D="8e20667f-0bdf-4ca5-bc1a-a107f15ddbb2" name="Trigger functions" order-num="9" objects-loading="extended" subcategories-loading="none" child-type="function">
                    <function _I_D="ffdd1942-96e5-4b71-b5c7-4fa415ca93d4" name="set_up_rows" function-id="16676" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="1" unique-function-name="set_up_rows" is-aggregate="f" language-name="plpgsql" context="set_up_rows" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="trigger" count-arguments="0" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="set_up_rows()">
                        <complex-attribute name="sql"><![CDATA[
DECLARE 
  TabInserted VARCHAR(100);
  TabDeleted VARCHAR(100);
BEGIN
  TabInserted := 'inserted_' || TG_TABLE_NAME;
  TabDeleted := 'deleted_' || TG_TABLE_NAME;
  EXECUTE 'DROP TABLE IF EXISTS ' || TabInserted;
  EXECUTE 'DROP TABLE IF EXISTS ' || TabDeleted;  
  EXECUTE 'CREATE TEMPORARY TABLE ' || TabInserted || ' ON COMMIT DROP AS TABLE ' || TG_TABLE_SCHEMA || '.' || TG_TABLE_NAME || ' WITH NO DATA';
  EXECUTE 'CREATE TEMPORARY TABLE ' || TabDeleted || ' ON COMMIT DROP AS TABLE ' || TG_TABLE_SCHEMA || '.' || TG_TABLE_NAME || ' WITH NO DATA';
  -- EXECUTE 'CREATE TEMPORARY TABLE IF NOT EXISTS ' || TabInserted || ' ON COMMIT DROP AS TABLE ' || TG_TABLE_SCHEMA || '.' || TG_TABLE_NAME || ' WITH NO DATA';
  -- EXECUTE 'CREATE TEMPORARY TABLE IF NOT EXISTS ' || TabDeleted || ' ON COMMIT DROP AS TABLE ' || TG_TABLE_SCHEMA || '.' || TG_TABLE_NAME || ' WITH NO DATA'; 
  -- EXECUTE 'TRUNCATE TABLE ' || TabInserted;
  -- EXECUTE 'TRUNCATE TABLE ' || TabDeleted; 
  RETURN NULL;
END;
]]></complex-attribute>
                        <category _I_D="b9909160-c029-41e0-a0a0-abd8c34b8f5b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8c38a85f-edfa-44d6-8d98-509033b80bd5" name="sp_jobstep_create_proc" function-id="16678" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="1" unique-function-name="sp_jobstep_create_proc" is-aggregate="f" language-name="plpgsql" context="sp_jobstep_create_proc" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="trigger" count-arguments="0" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_jobstep_create_proc()">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  retval INT;
  proc_name_mask VARCHAR(100);
  proc_name VARCHAR(100);
  proc_body_mask VARCHAR(200);
  command_text TEXT;
  proc_body TEXT;
  
BEGIN
  proc_name_mask := 'sql_agent$job_%s_step_%s';
  proc_body_mask := 'create or replace function aws_sqlserver_ext_data.%s() returns void as $$ begin %s end $$ language plpgsql;';

  SELECT format(proc_name_mask, job_id, step_id) 
       , command  
    FROM aws_sqlserver_ext.sysjobsteps 
   WHERE step_uid = NEW.step_uid
    INTO proc_name, command_text; 

  proc_body := format(proc_body_mask, proc_name, command_text);
  EXECUTE proc_body;
  
  RETURN NEW;
END;
]]></complex-attribute>
                        <category _I_D="5a60bbd7-7d4f-4c18-a6c9-6267e7c60e0c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="566349e4-cf68-4fa0-b5cf-94ec5d213f91" name="sp_jobstep_drop_proc" function-id="16679" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="1" unique-function-name="sp_jobstep_drop_proc" is-aggregate="f" language-name="plpgsql" context="sp_jobstep_drop_proc" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="trigger" count-arguments="0" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_jobstep_drop_proc()">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  retval INT;
  proc_name_mask VARCHAR(100);
  proc_name VARCHAR(100);
  drop_mask VARCHAR(200);
  drop_cmd TEXT;
BEGIN
  proc_name_mask := 'sql_agent$job_%s_step_%s';
  drop_mask := 'drop function aws_sqlserver_ext_data.%s();';

  SELECT format(proc_name_mask, job_id, step_id) 
    FROM aws_sqlserver_ext.sysjobsteps 
   WHERE step_uid = OLD.step_uid
    INTO proc_name; 

  drop_cmd := format(drop_mask, proc_name);
  EXECUTE drop_cmd;
  
  RETURN OLD;
END;
]]></complex-attribute>
                        <category _I_D="bb007704-8679-4335-9afe-461d065e0c10" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c88d86ef-45ee-4618-8acb-5d17da9cc53f" name="stash_row_deltas" function-id="16677" schema-id="16397" function-type="RET_SCALAR" is-trigger-function="1" unique-function-name="stash_row_deltas" is-aggregate="f" language-name="plpgsql" context="stash_row_deltas" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="trigger" count-arguments="0" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="stash_row_deltas()">
                        <complex-attribute name="sql"><![CDATA[
DECLARE 
  TabInserted VARCHAR(100);
  TabDeleted VARCHAR(100);
BEGIN
  TabInserted := 'inserted_' || TG_TABLE_NAME;
  TabDeleted := 'deleted_' || TG_TABLE_NAME;

  IF TG_OP = 'INSERT' THEN
	EXECUTE 'INSERT INTO ' || TabInserted || ' SELECT * FROM (SELECT $1.*) AS t' USING NEW;
    RETURN NEW;
  ELSIF TG_OP = 'UPDATE' THEN
	EXECUTE 'INSERT INTO ' || TabInserted || ' SELECT * FROM (SELECT $1.*) AS t' USING NEW;  
    EXECUTE 'INSERT INTO ' || TabDeleted || ' SELECT * FROM (SELECT $1.*) AS t' USING OLD;  	
    RETURN NEW;	
  ELSE 
	EXECUTE 'INSERT INTO ' || TabDeleted || ' SELECT * FROM (SELECT $1.*) AS t' USING OLD;  
    RETURN OLD;	      
  END IF;
END;
]]></complex-attribute>
                        <category _I_D="574e3b8e-fe67-4b5c-86d8-862f038ed564" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                </category>
                <category _I_D="4c1ea572-4266-4bb9-a945-c027f02357d0" name="Procedures" order-num="10" objects-loading="empty" subcategories-loading="full" child-type="procedure"/>
                <category _I_D="65dc00c3-8e9d-4c25-9ba4-e99153f2e3dc" name="Sequences" order-num="11" objects-loading="extended" subcategories-loading="full" child-type="sequence">
                    <sequence _I_D="8529f967-dede-4b3e-9e15-c4799cd326c0" name="sysjobhistory_seq" data-type="bigint" start-value="1" minimum-value="1" maximum-value="9223372036854775807" increment="1" cycle-option="NO" cache-size="1" owner="postgres" context="sysjobhistory_seq" subcategories-loading="full" object-loading="extended" cache-value="1"/>
                    <sequence _I_D="c03c3552-656f-4b99-900f-207415dd04f4" name="sysjobs_seq" data-type="bigint" start-value="1" minimum-value="1" maximum-value="9223372036854775807" increment="1" cycle-option="NO" cache-size="1" owner="postgres" context="sysjobs_seq" subcategories-loading="full" object-loading="extended" cache-value="1"/>
                    <sequence _I_D="8b531de4-ed21-49e4-8a38-23eb8580501f" name="sysjobsteps_seq" data-type="bigint" start-value="1" minimum-value="1" maximum-value="9223372036854775807" increment="1" cycle-option="NO" cache-size="1" owner="postgres" context="sysjobsteps_seq" subcategories-loading="full" object-loading="extended" cache-value="1"/>
                    <sequence _I_D="59f17e32-c13e-47b1-b38e-14c4a1688916" name="sysmail_account_seq" data-type="bigint" start-value="1" minimum-value="1" maximum-value="9223372036854775807" increment="1" cycle-option="NO" cache-size="1" owner="postgres" context="sysmail_account_seq" subcategories-loading="full" object-loading="extended" cache-value="1"/>
                    <sequence _I_D="bdcec640-6665-477b-b808-5bd020e0c45f" name="sysmail_attachments_seq" data-type="bigint" start-value="1" minimum-value="1" maximum-value="9223372036854775807" increment="1" cycle-option="NO" cache-size="1" owner="postgres" context="sysmail_attachments_seq" subcategories-loading="full" object-loading="extended" cache-value="1"/>
                    <sequence _I_D="1000708c-8e0b-45b0-bbe0-79fe3d24f66f" name="sysmail_log_seq" data-type="bigint" start-value="1" minimum-value="1" maximum-value="9223372036854775807" increment="1" cycle-option="NO" cache-size="1" owner="postgres" context="sysmail_log_seq" subcategories-loading="full" object-loading="extended" cache-value="1"/>
                    <sequence _I_D="a95691cd-5b6a-43d1-9735-1916ae25b249" name="sysmail_mailitems_seq" data-type="bigint" start-value="1" minimum-value="1" maximum-value="9223372036854775807" increment="1" cycle-option="NO" cache-size="1" owner="postgres" context="sysmail_mailitems_seq" subcategories-loading="full" object-loading="extended" cache-value="1"/>
                    <sequence _I_D="6488ada4-7712-41bb-bb70-b99154ec826a" name="sysmail_profile_seq" data-type="bigint" start-value="1" minimum-value="1" maximum-value="9223372036854775807" increment="1" cycle-option="NO" cache-size="1" owner="postgres" context="sysmail_profile_seq" subcategories-loading="full" object-loading="extended" cache-value="1"/>
                    <sequence _I_D="37611f74-c1fa-45e6-8a41-9454365e4937" name="sysschedules_seq" data-type="bigint" start-value="1" minimum-value="1" maximum-value="9223372036854775807" increment="1" cycle-option="NO" cache-size="1" owner="postgres" context="sysschedules_seq" subcategories-loading="full" object-loading="extended" cache-value="1"/>
                </category>
                <category _I_D="c1c4d08f-f2c1-4868-b6a9-b863c5176187" name="User defined types" order-num="12" objects-loading="empty" subcategories-loading="full" child-type="type"/>
                <category _I_D="9261a5bf-9f8f-4ad9-8976-3420587a8d14" name="Domains" order-num="13" objects-loading="empty" subcategories-loading="full" child-type="domain"/>
                <category _I_D="5ba29971-0751-45aa-bdff-2be7958be04c" name="Materialized Views" order-num="14" objects-loading="empty" subcategories-loading="full" child-type="materialized-view"/>
                <category _I_D="ffd775d5-19f1-4701-80c7-2a056531bd13" name="Aggregates" order-num="15" objects-loading="empty" subcategories-loading="full" child-type="aggregate"/>
            </schema>
            <schema _I_D="b4d42030-7c75-4fac-9130-d9965aa896f0" name="information_schema" is-empty="N" context="information_schema" subcategories-loading="none" object-loading="extended" schema-owner="postgres" is-system="Y">
                <category _I_D="cda5a2f9-365e-424e-9458-05f222e829a4" name="Tables" order-num="0" objects-loading="none" subcategories-loading="none" child-type="table"/>
                <category _I_D="e8908735-81a9-40cd-95aa-54a66f40b655" name="Foreign tables" order-num="1" objects-loading="none" subcategories-loading="none" child-type="foreigntable"/>
                <category _I_D="e775ab37-96b0-418b-882c-f8afcd8dca2c" name="Views" order-num="2" objects-loading="none" subcategories-loading="none" child-type="view"/>
                <category _I_D="7a5ef3c4-05fa-44ae-b08a-b73b1049a95f" name="Collations" order-num="3" objects-loading="none" subcategories-loading="none" child-type="collation"/>
                <category _I_D="68a1f46d-1143-4d2b-b133-343ff5293e0c" name="Operators" order-num="4" objects-loading="none" subcategories-loading="none" child-type="operator"/>
                <category _I_D="d17f3198-64f5-428e-a30d-54ae451ac012" name="Rules" order-num="5" objects-loading="none" subcategories-loading="none" child-type="rule"/>
                <category _I_D="c68439fc-89c4-4f1a-8fed-bcef3b840a91" name="FTS Configurations" order-num="6" objects-loading="none" subcategories-loading="none" child-type="ftsconfiguration"/>
                <category _I_D="1760a558-01be-439a-bb04-174dc31429fc" name="FTS Dictionaries" order-num="7" objects-loading="none" subcategories-loading="none" child-type="ftsdictionary"/>
                <category _I_D="4e36ffc0-10a7-4b12-9d33-a2c2a4607414" name="Functions" order-num="8" objects-loading="none" subcategories-loading="none" child-type="function"/>
                <category _I_D="9ea87760-b3c6-4e3e-a4d8-9cf80b4dfbfe" name="Trigger functions" order-num="9" objects-loading="none" subcategories-loading="none" child-type="function"/>
                <category _I_D="09f29932-e829-479a-a5c1-723828abcf64" name="Procedures" order-num="10" objects-loading="none" subcategories-loading="none" child-type="procedure"/>
                <category _I_D="2a957d65-e7f1-4b84-bb50-7109e9db735a" name="Sequences" order-num="11" objects-loading="none" subcategories-loading="none" child-type="sequence"/>
                <category _I_D="5c923de2-a83d-423c-a13e-084e46020b77" name="User defined types" order-num="12" objects-loading="none" subcategories-loading="none" child-type="type"/>
                <category _I_D="328d18b0-39bf-47b9-8377-b1725a4e2546" name="Domains" order-num="13" objects-loading="none" subcategories-loading="none" child-type="domain"/>
                <category _I_D="21104d27-cf3b-40b2-a637-6af6a77e5ed2" name="Materialized Views" order-num="14" objects-loading="none" subcategories-loading="none" child-type="materialized-view"/>
                <category _I_D="f63a8f8f-4aef-497b-b26f-88d7d64af187" name="Aggregates" order-num="15" objects-loading="none" subcategories-loading="none" child-type="aggregate"/>
            </schema>
            <schema _I_D="d17e897e-cb50-4623-bc9a-a7a3346cb048" name="pg_catalog" is-empty="N" context="pg_catalog" subcategories-loading="none" object-loading="extended" schema-owner="postgres" is-system="Y">
                <category _I_D="50a94cbb-a592-42bf-bb92-f8c8c6d94484" name="Tables" order-num="0" objects-loading="none" subcategories-loading="none" child-type="table"/>
                <category _I_D="6ec607fc-427e-49fa-a78a-eb48a9b06b6f" name="Foreign tables" order-num="1" objects-loading="none" subcategories-loading="none" child-type="foreigntable"/>
                <category _I_D="454c92ec-e8ef-43e5-851e-c92d794a7d59" name="Views" order-num="2" objects-loading="none" subcategories-loading="none" child-type="view"/>
                <category _I_D="8473ddd4-6b48-42ee-ba5b-4dc72e2442ea" name="Collations" order-num="3" objects-loading="none" subcategories-loading="none" child-type="collation"/>
                <category _I_D="05ffa805-1cd4-4e80-ab97-9b60e5662e48" name="Operators" order-num="4" objects-loading="none" subcategories-loading="none" child-type="operator"/>
                <category _I_D="6753c75c-e9d4-44ee-a206-115dcb9369eb" name="Rules" order-num="5" objects-loading="none" subcategories-loading="none" child-type="rule"/>
                <category _I_D="b9e957b9-6d3e-4246-9362-7fba99dfed52" name="FTS Configurations" order-num="6" objects-loading="none" subcategories-loading="none" child-type="ftsconfiguration"/>
                <category _I_D="1dbc81f4-c131-4df1-b6ce-d47d4544cceb" name="FTS Dictionaries" order-num="7" objects-loading="none" subcategories-loading="none" child-type="ftsdictionary"/>
                <category _I_D="a8b8890c-dfec-45d6-9cc4-1949516a226d" name="Functions" order-num="8" objects-loading="none" subcategories-loading="none" child-type="function"/>
                <category _I_D="4eaf69ee-644f-4246-8f25-fb95445aacba" name="Trigger functions" order-num="9" objects-loading="none" subcategories-loading="none" child-type="function"/>
                <category _I_D="2a2bbe95-2b3e-4260-8a73-ae114b5cd4aa" name="Procedures" order-num="10" objects-loading="none" subcategories-loading="none" child-type="procedure"/>
                <category _I_D="b224bc3b-3a1f-4af5-a4e6-a5d9aab9e169" name="Sequences" order-num="11" objects-loading="none" subcategories-loading="none" child-type="sequence"/>
                <category _I_D="efd1541d-e326-449a-ad0b-9b5abcb0464f" name="User defined types" order-num="12" objects-loading="none" subcategories-loading="none" child-type="type"/>
                <category _I_D="0df3848d-2089-4940-a090-ed3425893383" name="Domains" order-num="13" objects-loading="none" subcategories-loading="none" child-type="domain"/>
                <category _I_D="3ef95753-86f6-4f95-98b7-73b0d797b89b" name="Materialized Views" order-num="14" objects-loading="none" subcategories-loading="none" child-type="materialized-view"/>
                <category _I_D="e5ce3eaa-de91-480e-bfdb-02eaa66e413e" name="Aggregates" order-num="15" objects-loading="none" subcategories-loading="none" child-type="aggregate"/>
            </schema>
            <schema _I_D="b05f0e5d-c672-4c40-a9ce-3ecf3fcd3850" name="pg_toast" is-empty="N" context="pg_toast" subcategories-loading="none" object-loading="extended" schema-owner="postgres" is-system="Y">
                <category _I_D="3e766cfb-3b25-47cf-a787-b394df5690d0" name="Tables" order-num="0" objects-loading="none" subcategories-loading="none" child-type="table"/>
                <category _I_D="744fe716-3b4f-4616-9c20-671731f1ace7" name="Foreign tables" order-num="1" objects-loading="none" subcategories-loading="none" child-type="foreigntable"/>
                <category _I_D="6ca94b18-b914-4cf6-b164-76981bbaeb3e" name="Views" order-num="2" objects-loading="none" subcategories-loading="none" child-type="view"/>
                <category _I_D="50a1513b-1e81-4d02-947f-e5bce32e4339" name="Collations" order-num="3" objects-loading="none" subcategories-loading="none" child-type="collation"/>
                <category _I_D="44ec949c-6427-46cc-87c5-a620f27f0f00" name="Operators" order-num="4" objects-loading="none" subcategories-loading="none" child-type="operator"/>
                <category _I_D="d1450652-97c0-4819-96c5-0ec44bd44aed" name="Rules" order-num="5" objects-loading="none" subcategories-loading="none" child-type="rule"/>
                <category _I_D="940725c4-dd99-4f6c-ac5f-3835fa4b4823" name="FTS Configurations" order-num="6" objects-loading="none" subcategories-loading="none" child-type="ftsconfiguration"/>
                <category _I_D="dd7b7a26-3aa3-42b8-b972-f486177f5b70" name="FTS Dictionaries" order-num="7" objects-loading="none" subcategories-loading="none" child-type="ftsdictionary"/>
                <category _I_D="d650e7bf-58bc-46a0-8a4a-35253c355b42" name="Functions" order-num="8" objects-loading="none" subcategories-loading="none" child-type="function"/>
                <category _I_D="56cf44b5-26db-4ea9-aab4-58cc02012df8" name="Trigger functions" order-num="9" objects-loading="none" subcategories-loading="none" child-type="function"/>
                <category _I_D="e14257e1-a4bb-4bbd-a87a-57923ebf41a4" name="Procedures" order-num="10" objects-loading="none" subcategories-loading="none" child-type="procedure"/>
                <category _I_D="dcd13cf1-8077-466e-9959-9b8b883265f7" name="Sequences" order-num="11" objects-loading="none" subcategories-loading="none" child-type="sequence"/>
                <category _I_D="395ee98a-266a-422a-aa4e-013baddcd879" name="User defined types" order-num="12" objects-loading="none" subcategories-loading="none" child-type="type"/>
                <category _I_D="45481227-973c-48b5-91ca-a62dd6bbd898" name="Domains" order-num="13" objects-loading="none" subcategories-loading="none" child-type="domain"/>
                <category _I_D="9deec325-e82e-4402-aa91-4f0cdbe44e10" name="Materialized Views" order-num="14" objects-loading="none" subcategories-loading="none" child-type="materialized-view"/>
                <category _I_D="634b7392-2252-453f-a5b7-e4f0d5a20745" name="Aggregates" order-num="15" objects-loading="none" subcategories-loading="none" child-type="aggregate"/>
            </schema>
            <schema _I_D="bda6bff8-0007-47f1-ac02-812380f7e67c" name="public" is-empty="Y" context="public" subcategories-loading="none" object-loading="extended" schema-owner="postgres" is-system="N">
                <category _I_D="e023a4a6-6a62-4aaa-8bd6-b99b8038a7f8" name="Tables" order-num="0" objects-loading="none" subcategories-loading="none" child-type="table"/>
                <category _I_D="79858446-81a7-4a08-a13a-b0cdde32ccc9" name="Foreign tables" order-num="1" objects-loading="none" subcategories-loading="none" child-type="foreigntable"/>
                <category _I_D="129e4759-bedf-4d5c-a05e-6f291d5c040b" name="Views" order-num="2" objects-loading="none" subcategories-loading="none" child-type="view"/>
                <category _I_D="1c82a6b8-758f-47a0-a467-f69fed6cc44b" name="Collations" order-num="3" objects-loading="none" subcategories-loading="none" child-type="collation"/>
                <category _I_D="f1b56908-1a67-4550-8bbc-41d8c9565581" name="Operators" order-num="4" objects-loading="none" subcategories-loading="none" child-type="operator"/>
                <category _I_D="2bb4be61-1f13-47a4-a168-16fc5b014080" name="Rules" order-num="5" objects-loading="none" subcategories-loading="none" child-type="rule"/>
                <category _I_D="265d9dfe-1673-4e52-a467-632e2d595580" name="FTS Configurations" order-num="6" objects-loading="none" subcategories-loading="none" child-type="ftsconfiguration"/>
                <category _I_D="34776243-afef-4959-851d-76cbcb6a499d" name="FTS Dictionaries" order-num="7" objects-loading="none" subcategories-loading="none" child-type="ftsdictionary"/>
                <category _I_D="a82dbf22-6184-4933-bd5e-b05883c9973a" name="Functions" order-num="8" objects-loading="none" subcategories-loading="none" child-type="function"/>
                <category _I_D="b87c90ff-a29a-4a12-b7c9-0b07d492ea66" name="Trigger functions" order-num="9" objects-loading="none" subcategories-loading="none" child-type="function"/>
                <category _I_D="a7d721f6-8d9e-477e-9c8c-c5aefa776aac" name="Procedures" order-num="10" objects-loading="none" subcategories-loading="none" child-type="procedure"/>
                <category _I_D="7143ecb4-eca4-40fd-809b-162113568be2" name="Sequences" order-num="11" objects-loading="none" subcategories-loading="none" child-type="sequence"/>
                <category _I_D="4e515537-ff31-4a3d-b760-a9a064e22456" name="User defined types" order-num="12" objects-loading="none" subcategories-loading="none" child-type="type"/>
                <category _I_D="2564da3f-f10f-4a4a-8661-6186ab2fe480" name="Domains" order-num="13" objects-loading="none" subcategories-loading="none" child-type="domain"/>
                <category _I_D="a705b604-5c7d-4339-ac3e-b6fd50311581" name="Materialized Views" order-num="14" objects-loading="none" subcategories-loading="none" child-type="materialized-view"/>
                <category _I_D="483a4d40-f8f1-4bc8-b8c9-233feaf94e99" name="Aggregates" order-num="15" objects-loading="none" subcategories-loading="none" child-type="aggregate"/>
            </schema>
            <schema _I_D="4031aaf6-267b-4832-9f54-4dbde56eae1d" name="dbo" is-empty="N" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo" source-vendor="MSSQL">
                <category _I_D="1dab9be8-a160-4bee-b175-9638f5d3a5dd" name="Tables" order-num="0" child-type="table" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables">
                    <table _I_D="0064b261-deef-47d6-9c2b-f4a103016816" name="dimbatch" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimBatch" source-vendor="MSSQL" partitioned="NO">
                        <category _I_D="dad612f5-bfee-458c-864f-b0005704be97" name="Columns" order-num="0" child-type="column" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimBatch,category Columns">
                            <column _I_D="4258b80f-22fc-4d12-80ce-bdb0cb7c37b5" name="batchid" type-name="int" is-nullable="0" is-identity="YES" is-xml-document="N" dt-name="INTEGER" transformed="2022-09-14 15:32:53" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimBatch,category Columns,column BatchID" source-vendor="MSSQL" identity-generation="ALWAYS" identity-start-with="1" identity-increment-by="1"/>
                            <column _I_D="ca9fee53-5705-46d6-b5ae-649663338ecc" name="dateid" type-name="int" is-nullable="Y" is-xml-document="N" dt-name="INTEGER" transformed="2022-09-14 15:32:53" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimBatch,category Columns,column DateID" source-vendor="MSSQL"/>
                            <column _I_D="67bc1498-4250-4eda-a14b-9e67ccd03b66" name="createdate" type-name="datetime" is-nullable="Y" is-xml-document="N" dt-name="TIMESTAMP WITHOUT TIME ZONE" transformed="2022-09-14 15:32:53" character-maximum-length="8" numeric-precision="23" numeric-scale="3" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimBatch,category Columns,column CreateDate" source-vendor="MSSQL"/>
                        </category>
                        <category _I_D="d19d3e4c-2096-4cb9-bd49-bf04de378b53" name="Constraints" order-num="1" child-type="constraint" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimBatch,category Constraints">
                            <constraint _I_D="779398f6-a9a4-4e47-94f6-f091f64cbdb0" name="pk_dimbatch_789577851" constraint-type-desc="PRIMARY KEY" transformed="2022-09-14 15:32:53" constraint-schema="dbo" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimBatch,category Constraints,constraint PK_DimBatch" source-vendor="MSSQL" constraint-type="PRIMARY KEY">
                                <category _I_D="9720fe69-b628-4cc2-a0e2-ba7e18ad409d" name="Columns" order-num="0" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimBatch,category Constraints,constraint PK_DimBatch,category Columns">
                                    <column _I_D="d4abcbbb-64b3-40b9-961b-35566bed6406" name="batchid" ordinal-position="1" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimBatch,category Constraints,constraint PK_DimBatch,category Columns,column BatchID" source-vendor="MSSQL" descasc="ASC"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="3037dd5e-d0bd-46f7-8ad9-156d50fd632f" name="Indexes" order-num="2" child-type="index" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimBatch,category Indexes"/>
                        <category _I_D="b6d45913-2e3a-4f09-a89a-9d9db1de9bc1" name="Triggers" order-num="3" child-type="trigger" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimBatch,category Triggers"/>
                        <category _I_D="e2b404c7-bd0c-4a9d-8ace-ff6b25bbc420" name="Partitions" order-num="4" child-type="partition" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimBatch,category Partitions"/>
                    </table>
                    <table _I_D="289ef876-7fbf-4e0a-b2bf-23b64a857c42" name="dimdate" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimDate" source-vendor="MSSQL" partitioned="NO">
                        <category _I_D="82af36f5-6c5b-4aab-b4d7-4eb04acb0026" name="Columns" order-num="0" child-type="column" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimDate,category Columns">
                            <column _I_D="bf34ec24-6c4c-4dfc-bf23-942f46a6666c" name="dateid" type-name="int" is-nullable="N" is-xml-document="N" dt-name="INTEGER" transformed="2022-09-14 15:32:53" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimDate,category Columns,column DateID" source-vendor="MSSQL"/>
                            <column _I_D="78630918-487f-496b-b4a0-db32dcedbaf6" name="fulldatealternatekey" type-name="date" is-nullable="N" is-xml-document="N" dt-name="DATE" transformed="2022-09-14 15:32:53" character-maximum-length="3" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimDate,category Columns,column FullDateAlternateKey" source-vendor="MSSQL"/>
                            <column _I_D="49288acf-2d08-4e03-af0b-ad6de533e088" name="daynumberofyear" type-name="smallint" is-nullable="N" is-xml-document="N" dt-name="SMALLINT" transformed="2022-09-14 15:32:53" character-maximum-length="2" numeric-precision="5" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimDate,category Columns,column DayNumberOfYear" source-vendor="MSSQL"/>
                            <column _I_D="a868289f-bc3e-4202-8981-dec164793f2f" name="daynumberofmonth" type-name="tinyint" is-nullable="N" is-xml-document="N" dt-name="SMALLINT" transformed="2022-09-14 15:32:53" character-maximum-length="1" numeric-precision="3" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimDate,category Columns,column DayNumberOfMonth" source-vendor="MSSQL"/>
                            <column _I_D="413011cb-5979-4d02-a82d-da08175209b1" name="daynumberofquarter" type-name="tinyint" is-nullable="N" is-xml-document="N" dt-name="SMALLINT" transformed="2022-09-14 15:32:53" character-maximum-length="1" numeric-precision="3" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimDate,category Columns,column DayNumberOfQuarter" source-vendor="MSSQL"/>
                            <column _I_D="3d23ba12-ddcc-4497-881c-49e84bd1393e" name="monthnumberofyear" type-name="tinyint" is-nullable="N" is-xml-document="N" dt-name="SMALLINT" transformed="2022-09-14 15:32:53" character-maximum-length="1" numeric-precision="3" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimDate,category Columns,column MonthNumberOfYear" source-vendor="MSSQL"/>
                            <column _I_D="147a9c51-9d60-42fd-a099-397cd48afe29" name="monthnumberofquarter" type-name="tinyint" is-nullable="N" is-xml-document="N" dt-name="SMALLINT" transformed="2022-09-14 15:32:53" character-maximum-length="1" numeric-precision="3" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimDate,category Columns,column MonthNumberOfQuarter" source-vendor="MSSQL"/>
                            <column _I_D="de499e8e-2a4a-4af2-b0a7-0bc0a01195a3" name="calendarquarter" type-name="tinyint" is-nullable="N" is-xml-document="N" dt-name="SMALLINT" transformed="2022-09-14 15:32:53" character-maximum-length="1" numeric-precision="3" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimDate,category Columns,column CalendarQuarter" source-vendor="MSSQL"/>
                            <column _I_D="d52adb2f-1ab0-48eb-a420-0273352c6491" name="calendaryear" type-name="smallint" is-nullable="N" is-xml-document="N" dt-name="SMALLINT" transformed="2022-09-14 15:32:53" character-maximum-length="2" numeric-precision="5" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimDate,category Columns,column CalendarYear" source-vendor="MSSQL"/>
                            <column _I_D="a5a8f647-6791-4ef9-a22a-19d889275bb2" name="dayname" type-name="nvarchar" is-nullable="N" is-xml-document="N" dt-name="VARCHAR" dt-attr-1="14" transformed="2022-09-14 15:32:53" character-maximum-length="28" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimDate,category Columns,column DayName" source-vendor="MSSQL"/>
                            <column _I_D="a3cd19c8-5cc6-49c1-91bc-40e2daea00f0" name="monthname" type-name="nvarchar" is-nullable="N" is-xml-document="N" dt-name="VARCHAR" dt-attr-1="14" transformed="2022-09-14 15:32:53" character-maximum-length="28" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimDate,category Columns,column MonthName" source-vendor="MSSQL"/>
                            <column _I_D="3bec6c17-f65b-4581-9599-9b83f661c7cc" name="lastofmonth" type-name="date" is-nullable="N" is-xml-document="N" dt-name="DATE" transformed="2022-09-14 15:32:53" character-maximum-length="3" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimDate,category Columns,column LastOfMonth" source-vendor="MSSQL"/>
                            <column _I_D="48d1630e-3b46-4fa0-adde-1b1adaedde64" name="firstofquarter" type-name="date" is-nullable="N" is-xml-document="N" dt-name="DATE" transformed="2022-09-14 15:32:53" character-maximum-length="3" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimDate,category Columns,column FirstOfQuarter" source-vendor="MSSQL"/>
                            <column _I_D="31b907fb-fddc-4219-82c3-767c8b495b72" name="lastofquarter" type-name="date" is-nullable="N" is-xml-document="N" dt-name="DATE" transformed="2022-09-14 15:32:53" character-maximum-length="3" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimDate,category Columns,column LastOfQuarter" source-vendor="MSSQL"/>
                            <column _I_D="c73b6d16-9f88-45c0-98d5-9d408e669fe9" name="englishdayname" type-name="nvarchar" is-nullable="Y" is-xml-document="N" dt-name="VARCHAR" dt-attr-1="30" transformed="2022-09-14 15:32:53" character-maximum-length="60" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimDate,category Columns,column EnglishDayName" source-vendor="MSSQL"/>
                            <column _I_D="eb868ff3-93b7-4adf-8dc0-9c274960f53b" name="englishmonthname" type-name="nvarchar" is-nullable="Y" is-xml-document="N" dt-name="VARCHAR" dt-attr-1="30" transformed="2022-09-14 15:32:53" character-maximum-length="60" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimDate,category Columns,column EnglishMonthName" source-vendor="MSSQL"/>
                            <column _I_D="69f6fecd-fa24-47a4-8cf4-3567333761dc" name="simplerussiandate" type-name="nvarchar" is-nullable="Y" is-xml-document="N" dt-name="VARCHAR" dt-attr-1="4000" transformed="2022-09-14 15:32:53" character-maximum-length="8000" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimDate,category Columns,column SimpleRussianDate" source-vendor="MSSQL"/>
                        </category>
                        <category _I_D="fffe3a9e-2afd-46ee-9959-d5cd1965ac99" name="Constraints" order-num="1" child-type="constraint" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimDate,category Constraints">
                            <constraint _I_D="0cc128fd-6d2c-4280-96f5-faa92893d6cc" name="pk_dimdate_613577224" constraint-type-desc="PRIMARY KEY" transformed="2022-09-14 15:32:53" constraint-schema="dbo" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimDate,category Constraints,constraint PK_DimDate" source-vendor="MSSQL" constraint-type="PRIMARY KEY">
                                <category _I_D="2a35a8d1-39c7-4e94-8e1c-f3bed586ccc8" name="Columns" order-num="0" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimDate,category Constraints,constraint PK_DimDate,category Columns">
                                    <column _I_D="923d89f8-dd92-43bf-8492-f99530d4af5b" name="dateid" ordinal-position="1" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimDate,category Constraints,constraint PK_DimDate,category Columns,column DateID" source-vendor="MSSQL" descasc="ASC"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="c5afee02-cf4a-414c-be93-e2276ddbe5af" name="Indexes" order-num="2" child-type="index" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimDate,category Indexes"/>
                        <category _I_D="18ba8964-bcc1-45b0-b656-dbede09b7e34" name="Triggers" order-num="3" child-type="trigger" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimDate,category Triggers">
                            <trigger _I_D="fa18a68f-59d0-4c32-9468-6ac8341a66bb" name="tr_dimdate_biu" trigger-schema="dbo" trigger-function-schema="dbo" trigger-function-name="fn_tr_dimdate_biu" before-after-instead-of="BEFORE" row-or-statement="ROW" is-insert="1" is-update="1" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimDate">
                                <complex-attribute name="sql"><![CDATA[EXECUTE PROCEDURE dbo.fn_tr_dimdate_biu()]]></complex-attribute>
                            </trigger>
                        </category>
                        <category _I_D="c7c0f684-c4d1-4828-9405-1338baf1ebd8" name="Partitions" order-num="4" child-type="partition" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimDate,category Partitions"/>
                    </table>
                    <table _I_D="130ff9dc-611f-4c7e-b8a1-8093a1d09e2c" name="dimexchrateusd" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimExchRateUSD" source-vendor="MSSQL" partitioned="NO">
                        <category _I_D="134f51f8-2205-402c-a195-cc9efc6f5b8f" name="Columns" order-num="0" child-type="column" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimExchRateUSD,category Columns">
                            <column _I_D="8561b67a-e996-4c85-88ed-5b7a2f07a35b" name="dateid" type-name="int" is-nullable="N" is-xml-document="N" dt-name="INTEGER" transformed="2022-09-14 15:32:53" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimExchRateUSD,category Columns,column DateID" source-vendor="MSSQL"/>
                            <column _I_D="d4804774-727d-41a1-bf72-0a5d159873d2" name="batchid" type-name="int" is-nullable="Y" is-xml-document="N" dt-name="INTEGER" transformed="2022-09-14 15:32:53" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimExchRateUSD,category Columns,column BatchID" source-vendor="MSSQL"/>
                            <column _I_D="3d60e772-1bb1-4e89-b907-c029ab624838" name="exchangerates" type-name="money" is-nullable="N" is-xml-document="N" dt-name="NUMERIC" dt-attr-1="19" dt-attr-2="4" transformed="2022-09-14 15:32:53" character-maximum-length="8" numeric-precision="19" numeric-scale="4" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimExchRateUSD,category Columns,column ExchangeRates" source-vendor="MSSQL"/>
                            <column _I_D="ffe9d99a-1b62-462d-a42b-2e76e13693da" name="createdate" type-name="datetime" is-nullable="Y" is-xml-document="N" dt-name="TIMESTAMP WITHOUT TIME ZONE" transformed="2022-09-14 15:32:53" character-maximum-length="8" numeric-precision="23" numeric-scale="3" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimExchRateUSD,category Columns,column CreateDate" source-vendor="MSSQL"/>
                        </category>
                        <category _I_D="b5ba12a3-1413-451b-ad9a-dd209117cdc6" name="Constraints" order-num="1" child-type="constraint" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimExchRateUSD,category Constraints">
                            <constraint _I_D="4f62a33e-349d-4e03-8424-be6526bc063b" name="pk_dimexchrateusd_821577965" constraint-type-desc="PRIMARY KEY" transformed="2022-09-14 15:32:53" constraint-schema="dbo" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimExchRateUSD,category Constraints,constraint PK_DimExchRateUSD" source-vendor="MSSQL" constraint-type="PRIMARY KEY">
                                <category _I_D="1df228ac-f82b-4f06-af85-a9d3a23d47d6" name="Columns" order-num="0" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimExchRateUSD,category Constraints,constraint PK_DimExchRateUSD,category Columns">
                                    <column _I_D="7fe06c18-a492-408d-8568-bda132975b6f" name="dateid" ordinal-position="1" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimExchRateUSD,category Constraints,constraint PK_DimExchRateUSD,category Columns,column DateID" source-vendor="MSSQL" descasc="ASC"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="2ca62ae1-272f-4bec-ab27-d9e0b6b45dc2" name="Indexes" order-num="2" child-type="index" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimExchRateUSD,category Indexes"/>
                        <category _I_D="5fd44ca0-8d96-4046-9d31-7b3773ded68d" name="Triggers" order-num="3" child-type="trigger" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimExchRateUSD,category Triggers"/>
                        <category _I_D="10c833a1-dbfb-479f-a7d9-f114ccc19053" name="Partitions" order-num="4" child-type="partition" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimExchRateUSD,category Partitions"/>
                    </table>
                    <table _I_D="33f571dc-e293-4cf9-b5e3-e369d87542e3" name="factincome" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table FactIncome" source-vendor="MSSQL" partitioned="NO">
                        <category _I_D="043b71a2-e73a-4ae2-89d6-a120156d20db" name="Columns" order-num="0" child-type="column" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table FactIncome,category Columns">
                            <column _I_D="59539040-fd03-4612-b631-a80b7a136e85" name="id" type-name="int" is-nullable="0" is-identity="YES" is-xml-document="N" dt-name="INTEGER" transformed="2022-09-14 15:32:53" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table FactIncome,category Columns,column ID" source-vendor="MSSQL" identity-generation="ALWAYS" identity-start-with="1" identity-increment-by="1"/>
                            <column _I_D="9c1f812b-4e6e-4074-bb8c-b9a85e261303" name="dateid" type-name="int" is-nullable="Y" is-xml-document="N" dt-name="INTEGER" transformed="2022-09-14 15:32:53" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table FactIncome,category Columns,column DateID" source-vendor="MSSQL"/>
                            <column _I_D="7bff6da3-8040-4527-8c84-1222c417adb2" name="batchid" type-name="int" is-nullable="Y" is-xml-document="N" dt-name="INTEGER" transformed="2022-09-14 15:32:53" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table FactIncome,category Columns,column BatchID" source-vendor="MSSQL"/>
                            <column _I_D="b743b231-ae85-4243-973b-2baf4debfd72" name="incomevalue" type-name="money" is-nullable="Y" is-xml-document="N" dt-name="NUMERIC" dt-attr-1="19" dt-attr-2="4" transformed="2022-09-14 15:32:53" character-maximum-length="8" numeric-precision="19" numeric-scale="4" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table FactIncome,category Columns,column IncomeValue" source-vendor="MSSQL"/>
                            <column _I_D="c257fa70-71b0-4d7b-8f4f-2d9615504357" name="createdate" type-name="datetime" is-nullable="Y" is-xml-document="N" dt-name="TIMESTAMP WITHOUT TIME ZONE" transformed="2022-09-14 15:32:53" character-maximum-length="8" numeric-precision="23" numeric-scale="3" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table FactIncome,category Columns,column CreateDate" source-vendor="MSSQL"/>
                        </category>
                        <category _I_D="ba948858-aeb0-4b01-a8d0-c5e8a7a6b513" name="Constraints" order-num="1" child-type="constraint" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table FactIncome,category Constraints">
                            <constraint _I_D="91496614-943e-4bcb-a491-03627b8ec5f2" name="pk_factincome_885578193" constraint-type-desc="PRIMARY KEY" transformed="2022-09-14 15:32:53" constraint-schema="dbo" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table FactIncome,category Constraints,constraint PK_FactIncome" source-vendor="MSSQL" constraint-type="PRIMARY KEY">
                                <category _I_D="103b1983-df79-413b-94db-b9e4ad8b7943" name="Columns" order-num="0" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table FactIncome,category Constraints,constraint PK_FactIncome,category Columns">
                                    <column _I_D="b77777ee-64d1-49bc-a094-324f80207c39" name="id" ordinal-position="1" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table FactIncome,category Constraints,constraint PK_FactIncome,category Columns,column ID" source-vendor="MSSQL" descasc="ASC"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="88040273-cb5d-406a-8920-fd170d3ea276" name="Indexes" order-num="2" child-type="index" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table FactIncome,category Indexes"/>
                        <category _I_D="59ee0c07-7bbf-4398-a38a-d5f2fb0a3e1b" name="Triggers" order-num="3" child-type="trigger" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table FactIncome,category Triggers"/>
                        <category _I_D="6da5b851-8599-42cc-8328-1f41296c35a2" name="Partitions" order-num="4" child-type="partition" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table FactIncome,category Partitions"/>
                    </table>
                    <table _I_D="9030f297-16bc-4996-bb79-5d4d905989d2" name="factincomehistory" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table FactIncomeHistory" source-vendor="MSSQL" partitioned="NO">
                        <category _I_D="8708dfc7-bfb6-4759-8f39-6b5417211dc8" name="Columns" order-num="0" child-type="column" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table FactIncomeHistory,category Columns">
                            <column _I_D="cb565e41-50e9-4c87-b172-00df1ec50c70" name="id" type-name="int" is-nullable="0" is-identity="YES" is-xml-document="N" dt-name="INTEGER" transformed="2022-09-14 15:32:53" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table FactIncomeHistory,category Columns,column ID" source-vendor="MSSQL" identity-generation="ALWAYS" identity-start-with="1" identity-increment-by="1"/>
                            <column _I_D="0f275145-2346-428e-89cd-860b3551c9c2" name="dateid" type-name="int" is-nullable="Y" is-xml-document="N" dt-name="INTEGER" transformed="2022-09-14 15:32:53" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table FactIncomeHistory,category Columns,column DateID" source-vendor="MSSQL"/>
                            <column _I_D="ff92a6a1-ee89-4737-9b9f-3dec26980fa1" name="batchid" type-name="int" is-nullable="Y" is-xml-document="N" dt-name="INTEGER" transformed="2022-09-14 15:32:53" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table FactIncomeHistory,category Columns,column BatchID" source-vendor="MSSQL"/>
                            <column _I_D="6a3c6b40-f119-4627-8f89-7cdee673108c" name="incomeusd" type-name="money" is-nullable="Y" is-xml-document="N" dt-name="NUMERIC" dt-attr-1="19" dt-attr-2="4" transformed="2022-09-14 15:32:53" character-maximum-length="8" numeric-precision="19" numeric-scale="4" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table FactIncomeHistory,category Columns,column IncomeUSD" source-vendor="MSSQL"/>
                            <column _I_D="7fd6063e-4d62-493c-a88b-256a58015be5" name="naturalkey" type-name="uniqueidentifier" is-nullable="Y" is-xml-document="N" dt-name="UUID" transformed="2022-09-14 15:32:53" character-maximum-length="16" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table FactIncomeHistory,category Columns,column NaturalKey" source-vendor="MSSQL"/>
                            <column _I_D="adf35c41-b9be-4eff-906c-ce8fd2279940" name="versionkey" type-name="uniqueidentifier" is-nullable="Y" is-xml-document="N" dt-name="UUID" transformed="2022-09-14 15:32:53" character-maximum-length="16" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table FactIncomeHistory,category Columns,column VersionKey" source-vendor="MSSQL"/>
                            <column _I_D="20e293ca-6a5e-40cd-a5da-143eefa6de9e" name="exchangedateid" type-name="int" is-nullable="Y" is-xml-document="N" dt-name="INTEGER" transformed="2022-09-14 15:32:53" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table FactIncomeHistory,category Columns,column ExchangeDateID" source-vendor="MSSQL"/>
                            <column _I_D="560558a6-038c-478a-94ca-17bffde66c46" name="exchangevalue" type-name="money" is-nullable="Y" is-xml-document="N" dt-name="NUMERIC" dt-attr-1="19" dt-attr-2="4" transformed="2022-09-14 15:32:53" character-maximum-length="8" numeric-precision="19" numeric-scale="4" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table FactIncomeHistory,category Columns,column ExchangeValue" source-vendor="MSSQL"/>
                            <column _I_D="64a24927-e84b-4bcc-9712-d7b9ee44a138" name="exchangerate" type-name="money" is-nullable="Y" is-xml-document="N" dt-name="NUMERIC" dt-attr-1="19" dt-attr-2="4" transformed="2022-09-14 15:32:53" character-maximum-length="8" numeric-precision="19" numeric-scale="4" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table FactIncomeHistory,category Columns,column ExchangeRate" source-vendor="MSSQL"/>
                            <column _I_D="399ab8dd-533b-470f-98ca-3c948e083f02" name="endbatchid" type-name="int" is-nullable="Y" is-xml-document="N" dt-name="INTEGER" transformed="2022-09-14 15:32:53" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table FactIncomeHistory,category Columns,column EndBatchID" source-vendor="MSSQL"/>
                            <column _I_D="efe4d7ec-e50a-4dd4-85de-2152d7106b19" name="createdate" type-name="datetime" is-nullable="Y" is-xml-document="N" dt-name="TIMESTAMP WITHOUT TIME ZONE" transformed="2022-09-14 15:32:53" character-maximum-length="8" numeric-precision="23" numeric-scale="3" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table FactIncomeHistory,category Columns,column CreateDate" source-vendor="MSSQL"/>
                            <column _I_D="938cf4d0-256f-4a96-8ee5-7314bbd4439b" name="changedate" type-name="datetime" is-nullable="Y" is-xml-document="N" dt-name="TIMESTAMP WITHOUT TIME ZONE" transformed="2022-09-14 15:32:53" character-maximum-length="8" numeric-precision="23" numeric-scale="3" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table FactIncomeHistory,category Columns,column ChangeDate" source-vendor="MSSQL"/>
                        </category>
                        <category _I_D="74eee6fa-fa76-4f50-9fa9-5e14fefb0ae4" name="Constraints" order-num="1" child-type="constraint" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table FactIncomeHistory,category Constraints">
                            <constraint _I_D="c6c5bdf9-fda2-4743-84d8-086de8753c67" name="pk_factincomehistory_853578079" constraint-type-desc="PRIMARY KEY" transformed="2022-09-14 15:32:53" constraint-schema="dbo" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table FactIncomeHistory,category Constraints,constraint PK_FactIncomeHistory" source-vendor="MSSQL" constraint-type="PRIMARY KEY">
                                <category _I_D="6e059257-1d70-49a6-80e0-c002b0cc1106" name="Columns" order-num="0" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table FactIncomeHistory,category Constraints,constraint PK_FactIncomeHistory,category Columns">
                                    <column _I_D="2fa1a412-c3e1-4d04-bf4d-d3ff533a1666" name="id" ordinal-position="1" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table FactIncomeHistory,category Constraints,constraint PK_FactIncomeHistory,category Columns,column ID" source-vendor="MSSQL" descasc="ASC"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="5e488255-a173-4410-9e06-57fad8a3036e" name="Indexes" order-num="2" child-type="index" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table FactIncomeHistory,category Indexes"/>
                        <category _I_D="fd78caac-6753-4f53-b5ec-b4b3f70f1cff" name="Triggers" order-num="3" child-type="trigger" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table FactIncomeHistory,category Triggers"/>
                        <category _I_D="510175af-439a-4075-b00d-bfeefce5af1e" name="Partitions" order-num="4" child-type="partition" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table FactIncomeHistory,category Partitions"/>
                    </table>
                </category>
                <category _I_D="366f5da4-337d-4e19-a568-fa773ccf8539" name="Trigger functions" objects-loading="extended" subcategories-loading="full" child-type="function" transformed="2022-09-14 15:32:53">
                    <function _I_D="d93109d6-67c3-46d0-b8f3-b10a9022f44c" name="fn_tr_dimdate_biu" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Tables,table DimDate" transformed="2022-09-14 15:32:53">
                        <complex-attribute name="sql"><![CDATA[BEGIN
IF ((TG_OP = 'INSERT' AND NEW.englishdayname IS NOT NULL) OR (TG_OP = 'UPDATE' AND NEW.englishdayname <> OLD.englishdayname)) THEN&#x000d;
    RAISE EXCEPTION ' The column "englishdayname" cannot be modified because it is a computed column ';&#x000d;
END IF;
IF ((TG_OP = 'INSERT' AND NEW.englishmonthname IS NOT NULL) OR (TG_OP = 'UPDATE' AND NEW.englishmonthname <> OLD.englishmonthname)) THEN&#x000d;
    RAISE EXCEPTION ' The column "englishmonthname" cannot be modified because it is a computed column ';&#x000d;
END IF;
IF ((TG_OP = 'INSERT' AND NEW.simplerussiandate IS NOT NULL) OR (TG_OP = 'UPDATE' AND NEW.simplerussiandate <> OLD.simplerussiandate)) THEN&#x000d;
    RAISE EXCEPTION ' The column "simplerussiandate" cannot be modified because it is a computed column ';&#x000d;
END IF;
&#x000d;
/*&#x000d;
[7811 - Severity CRITICAL - PostgreSQL doesn't support the FORMAT(VARCHAR,VARCHAR) function. Review the converted code to make sure that the user-defined function produces the same results as the source code.]&#x000d;
(format([FullDateAlternateKey],'d','ru-ru'))&#x000d;
*/
NEW.englishmonthname := (to_char(NEW.fulldatealternatekey::DATE, 'Month'));
NEW.englishdayname := (CAST (date_part('week', NEW.fulldatealternatekey::DATE) AS VARCHAR(2)));
RETURN NEW;
END;]]></complex-attribute>
                        <category _I_D="74550c78-77e3-4afd-942f-7b6c07373242" name="Parameters" order-num="0" child-type="parameter" transformed="2022-09-14 15:32:53">
                            <parameter _I_D="2f02b7d0-50e3-436c-ac94-48e27aa05359" name="(result)" dt-name="trigger" argument-order="0" transformed="2022-09-14 15:32:53"/>
                        </category>
                    </function>
                </category>
                <category _I_D="0f33c198-225e-432b-991a-2e3ec995c6f2" name="Views" order-num="3" child-type="view" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Views">
                    <view _I_D="5f014367-ef59-4dda-b65e-a4d625bb7d0e" name="vw_quarterincome" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Views,view vw_QuarterIncome" source-vendor="MSSQL" count-all-parsable-nodes="70" count-error-parsable-nodes="0">
                        <complex-attribute name="sql"><![CDATA[SELECT&#x000d;
    calendaryear, calendarquarter, SUM(incomevalue) AS incomevalue&#x000d;
    FROM dbo.factincome AS f&#x000d;
    INNER JOIN dbo.dimdate AS d&#x000d;
        ON f.dateid = d.dateid&#x000d;
    GROUP BY calendaryear, calendarquarter;]]></complex-attribute>
                        <category _I_D="601b710c-3169-40b1-9f28-06fbf60942bf" name="Columns" order-num="0" child-type="column" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Views,view vw_QuarterIncome,category Columns">
                            <column _I_D="46dc5f9d-cb94-48fc-b76b-b5bb51042b3b" name="calendaryear" type-name="smallint" is-nullable="N" is-xml-document="N" dt-name="SMALLINT" transformed="2022-09-14 15:32:53" character-maximum-length="2" numeric-precision="5" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Views,view vw_QuarterIncome,category Columns,column CalendarYear" source-vendor="MSSQL"/>
                            <column _I_D="fa6b72d6-adf3-49fa-a95c-ab3366c4e118" name="calendarquarter" type-name="tinyint" is-nullable="N" is-xml-document="N" dt-name="SMALLINT" transformed="2022-09-14 15:32:53" character-maximum-length="1" numeric-precision="3" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Views,view vw_QuarterIncome,category Columns,column CalendarQuarter" source-vendor="MSSQL"/>
                            <column _I_D="0cf847c2-71ea-456e-a6b8-5843bc8c1788" name="incomevalue" type-name="money" is-nullable="Y" is-xml-document="N" dt-name="NUMERIC" dt-attr-1="19" dt-attr-2="4" transformed="2022-09-14 15:32:53" character-maximum-length="8" numeric-precision="19" numeric-scale="4" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Views,view vw_QuarterIncome,category Columns,column IncomeValue" source-vendor="MSSQL"/>
                        </category>
                        <category _I_D="ecd138da-e5e4-481c-bcef-2414b4af4fd7" name="Triggers" order-num="1" child-type="trigger" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Views,view vw_QuarterIncome,category Triggers"/>
                    </view>
                </category>
                <category _I_D="91da1b83-3490-4f55-839c-1131f0dcb74a" name="Procedures" order-num="4" child-type="procedure" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Procedures">
                    <procedure _I_D="cbce17b7-e576-41cc-bdb2-bd23fd8033ae" object-id="1045578763" schema-id="1" name="sp_filldimdate" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Procedures,procedure sp_FillDimDate" source-vendor="MSSQL" count-all-parsable-nodes="782" count-error-parsable-nodes="34" proc-language="plpgsql">
                        <complex-attribute name="sql"><![CDATA[&#x000d;
/* EXEC [meta].[sp_FillDimDate] @FromDate = '20180101', @ToDate = '20251231', @Culture = 'ru-ru', @TableName = '#Result_Test1', @IsOutput = 1 */&#x000d;
/* EXEC [meta].[sp_FillDimDate] @FromDate = '20180101', @ToDate = '20251231', @Culture = 'ru-ru', @IsOutput = 1 */&#x000d;
/* SET LANGUAGE English --  Russian */&#x000d;
/* SELECT [meta].[ufn_GetTableColumns]( 'dbo', 'DimDate') */&#x000d;
DECLARE&#x000d;
    var_SPName VARCHAR(510);&#x000d;
    var_SPParams TEXT;&#x000d;
    var_SPInfo TEXT;&#x000d;
    var_LogID INTEGER;&#x000d;
    var_RowCount INTEGER;&#x000d;
    sp_auditstart$ReturnCode INTEGER;&#x000d;
    sp_auditfinish$ReturnCode INTEGER;&#x000d;
BEGIN&#x000d;
    /*&#x000d;
    [7674 - Severity CRITICAL - AWS SCT can't convert the CONCAT_NULL_YIELDS_NULL clause of the SET statement. Convert your source code manually.]&#x000d;
    SET CONCAT_NULL_YIELDS_NULL ON&#x000d;
    */&#x000d;
    IF NOT EXISTS (SELECT&#x000d;
        *&#x000d;
        FROM tempdb_dbo.sysobjects&#x000d;
        WHERE id = aws_sqlserver_ext.object_id('tempdb.dbo.#AuditProc')) THEN&#x000d;
        CREATE TEMPORARY TABLE t$auditproc&#x000d;
        (logid INTEGER PRIMARY KEY NOT NULL);&#x000d;
    END IF;&#x000d;
    var_SPName := '[' + current_schema || '].[' + 'sp_filldimdate' || ']';&#x000d;
    var_SPParams := '';&#x000d;
    CALL audit.sp_auditstart(par_SPName := var_SPName, par_SPParams := var_SPParams, par_LogID => var_LogID, return_code => sp_auditstart$ReturnCode);&#x000d;
    /* Debug */&#x000d;
    /* SET @Culture='ru-ru'; -- 'en-US' */&#x000d;
    /* SELECT @FromDate = '20060101', @ToDate = '20061231'; */&#x000d;
    &#x000d;
    /*&#x000d;
    [7811 - Severity CRITICAL - PostgreSQL doesn't support the FORMAT(VARCHAR,VARCHAR) function. Review the converted code to make sure that the user-defined function produces the same results as the source code., 7811 - Severity CRITICAL - PostgreSQL doesn't support the FORMAT(VARCHAR,VARCHAR) function. Review the converted code to make sure that the user-defined function produces the same results as the source code.]&#x000d;
    WITH Days(DateCalendarValue, ID) AS&#x000d;
    (&#x000d;
     SELECT @FromDate, 1 WHERE @FromDate <= @ToDate&#x000d;
     UNION ALL&#x000d;
     SELECT DATEADD(DAY,1,DateCalendarValue), ID+1  FROM Days WHERE DateCalendarValue < @ToDate&#x000d;
    )&#x000d;
    &#x000d;
    SELECT&#x000d;
    	[DateID] = CAST(CONVERT(varchar(25), DateCalendarValue, 112) as int) ,&#x000d;
    	[FullDateAlternateKey] = CAST(DateCalendarValue as date),&#x000d;
    	[DayNumberOfYear]      = DATEPART(dayofyear, DateCalendarValue),&#x000d;
    	[DayNumberOfMonth]     = DATEPART(day, DateCalendarValue),&#x000d;
    	[DayNumberOfQuarter]   = DATEDIFF(dd,DATEADD(qq, DATEDIFF(qq, 0, DateCalendarValue), 0), DateCalendarValue) + 1,&#x000d;
    	[MonthNumberOfYear]    = DATEPART(month, DateCalendarValue),&#x000d;
    	[MonthNumberOfQuarter] = MONTH(DateCalendarValue) - MONTH(DATEADD(qq, DATEDIFF(qq, 0, DateCalendarValue), 0)) + 1,&#x000d;
    	[CalendarQuarter]      = DATEPART(quarter, DateCalendarValue),&#x000d;
    	[CalendarYear]         = DATEPART(year, DateCalendarValue),&#x000d;
    	[DayName]              = FORMAT(DateCalendarValue, 'dddd', @Culture),&#x000d;
    	[MonthName]            = FORMAT(DateCalendarValue, 'MMMM', @Culture),&#x000d;
    	LastOfMonth            = EOMONTH(DateCalendarValue) ,&#x000d;
    	FirstOfQuarter         = CONVERT(nvarchar(10),DATEADD(qq, DATEDIFF(qq, 0, DateCalendarValue), 0), 23),&#x000d;
    	LastOfQuarter          = CONVERT(nvarchar(10), DATEADD (dd, -1, DATEADD(qq, DATEDIFF(qq, 0, DateCalendarValue) +1, 0)), 23)&#x000d;
    &#x000d;
    	into #NewDate&#x000d;
    FROM [Days]&#x000d;
    ORDER BY DateCalendarValue&#x000d;
    OPTION (MAXRECURSION 0);&#x000d;
    */&#x000d;
    &#x000d;
    /*&#x000d;
    [7833 - Severity CRITICAL - AWS SCT can't convert the @@rowcount function in the current context. Convert your source code manually.]&#x000d;
    SET @RowCount = @@ROWCOUNT&#x000d;
    */&#x000d;
    IF (par_TableName IS NULL) THEN&#x000d;
        INSERT INTO dbo.dimdate (dateid, fulldatealternatekey, daynumberofyear, daynumberofmonth, daynumberofquarter, monthnumberofyear, monthnumberofquarter, calendarquarter, calendaryear, dayname, monthname, lastofmonth, firstofquarter, lastofquarter)&#x000d;
        SELECT&#x000d;
            new.dateid, new.fulldatealternatekey, new.daynumberofyear, new.daynumberofmonth, new.daynumberofquarter, new.monthnumberofyear, new.monthnumberofquarter, new.calendarquarter, new.calendaryear, new.dayname, new.monthname, new.lastofmonth, new.firstofquarter, new.lastofquarter&#x000d;
            FROM t$newdate AS new&#x000d;
            LEFT OUTER JOIN dbo.dimdate AS d&#x000d;
                ON new.dateid = d.dateid&#x000d;
            WHERE d.dateid IS NULL;&#x000d;
    END IF;&#x000d;
&#x000d;
    IF (NOT par_TableName IS NULL) THEN&#x000d;
        OPEN p_refcur FOR&#x000d;
        EXECUTE 'CREATE TABLE  ' || par_TableName || '&#x000d;
			AS SELECT dateid, new.fulldatealternatekey, new.daynumberofyear, new.daynumberofmonth, new.daynumberofquarter, new.monthnumberofyear, new.monthnumberofquarter, new.calendarquarter, new.calendaryear, new.dayname, new.monthname, new.lastofmonth, new.firstofquarter, new.lastofquarter FROM t$newdate AS new&#x000d;
			';&#x000d;
    END IF;&#x000d;
    CALL audit.sp_auditfinish(par_LogID := var_LogID, par_RecordCount := var_RowCount, return_code => sp_auditfinish$ReturnCode);&#x000d;
&#x000d;
    IF par_IsOutput = 1 THEN&#x000d;
        OPEN p_refcur_2 FOR&#x000d;
        SELECT&#x000d;
            *&#x000d;
            FROM t$newdate;&#x000d;
    END IF;&#x000d;
    /*&#x000d;
    &#x000d;
    DROP TABLE IF EXISTS t$auditproc;&#x000d;
    */&#x000d;
    /*&#x000d;
    &#x000d;
    Temporary table must be removed before end of the function.&#x000d;
    */&#x000d;
    /*&#x000d;
    &#x000d;
    DROP TABLE IF EXISTS t$newdate;&#x000d;
    */&#x000d;
    /*&#x000d;
    &#x000d;
    Temporary table must be removed before end of the function.&#x000d;
    */&#x000d;
END;]]></complex-attribute>
                        <category _I_D="e4e311d3-9e1d-4a8e-820a-dd64daa22cea" name="Parameters" order-num="0" child-type="parameter" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Procedures,procedure sp_FillDimDate,category Parameters">
                            <parameter _I_D="5a6b866d-12a4-4c59-b446-aceb398eb9a1" name="par_fromdate" dt-name="TIMESTAMP WITHOUT TIME ZONE" transformed="2022-09-14 15:32:53" argument-order="1" argument-datatype="datetime" argument-mode="IN" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Procedures,procedure sp_FillDimDate,category Parameters,parameter \@FromDate" source-vendor="MSSQL"/>
                            <parameter _I_D="9471827e-47a9-4ea4-bdb5-5c6780965b22" name="par_todate" dt-name="TIMESTAMP WITHOUT TIME ZONE" transformed="2022-09-14 15:32:53" argument-order="2" argument-datatype="datetime" argument-mode="IN" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Procedures,procedure sp_FillDimDate,category Parameters,parameter \@ToDate" source-vendor="MSSQL"/>
                            <parameter _I_D="6f0adb14-ef5c-4522-a728-836044c40bd5" name="par_culture" dt-name="VARCHAR" dt-attr-1="128" transformed="2022-09-14 15:32:53" argument-order="3" argument-datatype="nvarchar" argument-mode="IN" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Procedures,procedure sp_FillDimDate,category Parameters,parameter \@Culture" source-vendor="MSSQL"/>
                            <parameter _I_D="c290e926-52e0-49e3-a59e-2d171c33b756" name="par_tablename" dt-name="VARCHAR" dt-attr-1="128" transformed="2022-09-14 15:32:53" argument-order="4" argument-datatype="nvarchar" argument-mode="IN" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Procedures,procedure sp_FillDimDate,category Parameters,parameter \@TableName" source-vendor="MSSQL" argument-default="NULL"/>
                            <parameter _I_D="69c37b45-84b1-4ed6-862c-716f63f5dfd7" name="par_isoutput" dt-name="NUMERIC" dt-attr-1="1" dt-attr-2="0" transformed="2022-09-14 15:32:53" argument-order="5" argument-datatype="bit" argument-mode="IN" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Procedures,procedure sp_FillDimDate,category Parameters,parameter \@IsOutput" source-vendor="MSSQL" argument-default="1"/>
                            <parameter _I_D="97b6000e-176a-4168-bda3-69c9c5eb8f94" name="p_refcur" dt-name="refcursor" transformed="2022-09-14 15:32:53" argument-order="6" argument-datatype="refcursor" argument-mode="INOUT" argument-default="NULL"/>
                            <parameter _I_D="243291ff-a174-4b93-b3a2-3c47d2e807ec" name="p_refcur_2" dt-name="refcursor" transformed="2022-09-14 15:32:53" argument-order="7" argument-datatype="refcursor" argument-mode="INOUT" argument-default="NULL"/>
                        </category>
                    </procedure>
                    <procedure _I_D="0d08a105-cfc9-41a7-8778-bc9ffb3cde85" object-id="1045578763" schema-id="1" name="sp_filldimdate$tmp" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Procedures,procedure sp_FillDimDate" source-vendor="MSSQL" count-all-parsable-nodes="782" count-error-parsable-nodes="34">
                        <complex-attribute name="sql"><![CDATA[&#x000d;
/*&#x000d;
[7674 - Severity CRITICAL - AWS SCT can't convert the CONCAT_NULL_YIELDS_NULL clause of the SET statement. Convert your source code manually.]&#x000d;
SET CONCAT_NULL_YIELDS_NULL ON&#x000d;
*/&#x000d;
IF NOT EXISTS (SELECT&#x000d;
    *&#x000d;
    FROM tempdb_dbo.sysobjects&#x000d;
    WHERE id = aws_sqlserver_ext.object_id('tempdb.dbo.#AuditProc')) THEN&#x000d;
    CREATE TEMPORARY TABLE t$auditproc&#x000d;
    (logid INTEGER PRIMARY KEY NOT NULL);&#x000d;
END IF;&#x000d;
var_SPName := '[' + current_schema || '].[' + 'sp_filldimdate' || ']';&#x000d;
var_SPParams := '';&#x000d;
CALL audit.sp_auditstart(par_SPName := var_SPName, par_SPParams := var_SPParams, par_LogID => var_LogID, return_code => sp_auditstart$ReturnCode);&#x000d;
/* Debug */&#x000d;
/* SET @Culture='ru-ru'; -- 'en-US' */&#x000d;
/* SELECT @FromDate = '20060101', @ToDate = '20061231'; */&#x000d;
&#x000d;
/*&#x000d;
[7811 - Severity CRITICAL - PostgreSQL doesn't support the FORMAT(VARCHAR,VARCHAR) function. Review the converted code to make sure that the user-defined function produces the same results as the source code., 7811 - Severity CRITICAL - PostgreSQL doesn't support the FORMAT(VARCHAR,VARCHAR) function. Review the converted code to make sure that the user-defined function produces the same results as the source code.]&#x000d;
WITH Days(DateCalendarValue, ID) AS&#x000d;
(&#x000d;
 SELECT @FromDate, 1 WHERE @FromDate <= @ToDate&#x000d;
 UNION ALL&#x000d;
 SELECT DATEADD(DAY,1,DateCalendarValue), ID+1  FROM Days WHERE DateCalendarValue < @ToDate&#x000d;
)&#x000d;
&#x000d;
SELECT&#x000d;
	[DateID] = CAST(CONVERT(varchar(25), DateCalendarValue, 112) as int) ,&#x000d;
	[FullDateAlternateKey] = CAST(DateCalendarValue as date),&#x000d;
	[DayNumberOfYear]      = DATEPART(dayofyear, DateCalendarValue),&#x000d;
	[DayNumberOfMonth]     = DATEPART(day, DateCalendarValue),&#x000d;
	[DayNumberOfQuarter]   = DATEDIFF(dd,DATEADD(qq, DATEDIFF(qq, 0, DateCalendarValue), 0), DateCalendarValue) + 1,&#x000d;
	[MonthNumberOfYear]    = DATEPART(month, DateCalendarValue),&#x000d;
	[MonthNumberOfQuarter] = MONTH(DateCalendarValue) - MONTH(DATEADD(qq, DATEDIFF(qq, 0, DateCalendarValue), 0)) + 1,&#x000d;
	[CalendarQuarter]      = DATEPART(quarter, DateCalendarValue),&#x000d;
	[CalendarYear]         = DATEPART(year, DateCalendarValue),&#x000d;
	[DayName]              = FORMAT(DateCalendarValue, 'dddd', @Culture),&#x000d;
	[MonthName]            = FORMAT(DateCalendarValue, 'MMMM', @Culture),&#x000d;
	LastOfMonth            = EOMONTH(DateCalendarValue) ,&#x000d;
	FirstOfQuarter         = CONVERT(nvarchar(10),DATEADD(qq, DATEDIFF(qq, 0, DateCalendarValue), 0), 23),&#x000d;
	LastOfQuarter          = CONVERT(nvarchar(10), DATEADD (dd, -1, DATEADD(qq, DATEDIFF(qq, 0, DateCalendarValue) +1, 0)), 23)&#x000d;
&#x000d;
	into #NewDate&#x000d;
FROM [Days]&#x000d;
ORDER BY DateCalendarValue&#x000d;
OPTION (MAXRECURSION 0);&#x000d;
*/&#x000d;
&#x000d;
/*&#x000d;
[7833 - Severity CRITICAL - AWS SCT can't convert the @@rowcount function in the current context. Convert your source code manually.]&#x000d;
SET @RowCount = @@ROWCOUNT&#x000d;
*/&#x000d;
IF (par_TableName IS NULL) THEN&#x000d;
    INSERT INTO dbo.dimdate (dateid, fulldatealternatekey, daynumberofyear, daynumberofmonth, daynumberofquarter, monthnumberofyear, monthnumberofquarter, calendarquarter, calendaryear, dayname, monthname, lastofmonth, firstofquarter, lastofquarter)&#x000d;
    SELECT&#x000d;
        new.dateid, new.fulldatealternatekey, new.daynumberofyear, new.daynumberofmonth, new.daynumberofquarter, new.monthnumberofyear, new.monthnumberofquarter, new.calendarquarter, new.calendaryear, new.dayname, new.monthname, new.lastofmonth, new.firstofquarter, new.lastofquarter&#x000d;
        FROM t$newdate AS new&#x000d;
        LEFT OUTER JOIN dbo.dimdate AS d&#x000d;
            ON new.dateid = d.dateid&#x000d;
        WHERE d.dateid IS NULL;&#x000d;
END IF;&#x000d;
&#x000d;
IF (NOT par_TableName IS NULL) THEN&#x000d;
    OPEN p_refcur FOR&#x000d;
    EXECUTE 'CREATE TABLE  ' || par_TableName || '&#x000d;
			AS SELECT dateid, new.fulldatealternatekey, new.daynumberofyear, new.daynumberofmonth, new.daynumberofquarter, new.monthnumberofyear, new.monthnumberofquarter, new.calendarquarter, new.calendaryear, new.dayname, new.monthname, new.lastofmonth, new.firstofquarter, new.lastofquarter FROM t$newdate AS new&#x000d;
			';&#x000d;
END IF;&#x000d;
CALL audit.sp_auditfinish(par_LogID := var_LogID, par_RecordCount := var_RowCount, return_code => sp_auditfinish$ReturnCode);&#x000d;
&#x000d;
IF par_IsOutput = 1 THEN&#x000d;
    DROP TABLE IF EXISTS sp_FillDimDate$TMPTBL;&#x000d;
    CREATE TEMP TABLE sp_FillDimDate$TMPTBL&#x000d;
    AS&#x000d;
    SELECT&#x000d;
        *&#x000d;
        FROM t$newdate;&#x000d;
END IF;&#x000d;
/*&#x000d;
&#x000d;
DROP TABLE IF EXISTS t$auditproc;&#x000d;
*/&#x000d;
/*&#x000d;
&#x000d;
Temporary table must be removed before end of the function.&#x000d;
*/&#x000d;
/*&#x000d;
&#x000d;
DROP TABLE IF EXISTS t$newdate;&#x000d;
*/&#x000d;
/*&#x000d;
&#x000d;
Temporary table must be removed before end of the function.&#x000d;
*/]]></complex-attribute>
                        <category _I_D="abdb754e-2ef9-4892-9ed5-212fd1593828" name="Parameters" order-num="0" child-type="parameter" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Procedures,procedure sp_FillDimDate,category Parameters">
                            <parameter _I_D="c7767019-10fc-4783-92ae-59c30775a5df" name="par_fromdate" dt-name="TIMESTAMP WITHOUT TIME ZONE" transformed="2022-09-14 15:32:53" argument-order="1" argument-datatype="datetime" argument-mode="IN" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Procedures,procedure sp_FillDimDate,category Parameters,parameter \@FromDate" source-vendor="MSSQL"/>
                            <parameter _I_D="c71882ff-09b0-40e1-ae2b-eff0702dc90e" name="par_todate" dt-name="TIMESTAMP WITHOUT TIME ZONE" transformed="2022-09-14 15:32:53" argument-order="2" argument-datatype="datetime" argument-mode="IN" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Procedures,procedure sp_FillDimDate,category Parameters,parameter \@ToDate" source-vendor="MSSQL"/>
                            <parameter _I_D="7e2f0d17-52fe-477d-8323-1aec131169fb" name="par_culture" dt-name="VARCHAR" dt-attr-1="128" transformed="2022-09-14 15:32:53" argument-order="3" argument-datatype="nvarchar" argument-mode="IN" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Procedures,procedure sp_FillDimDate,category Parameters,parameter \@Culture" source-vendor="MSSQL"/>
                            <parameter _I_D="2879ad69-79b8-40f0-989e-2b3b08db3b1d" name="par_tablename" dt-name="VARCHAR" dt-attr-1="128" transformed="2022-09-14 15:32:53" argument-order="4" argument-datatype="nvarchar" argument-mode="IN" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Procedures,procedure sp_FillDimDate,category Parameters,parameter \@TableName" source-vendor="MSSQL" argument-default="NULL"/>
                            <parameter _I_D="9e8079bb-1a8b-4df2-956a-a57e7d3caada" name="par_isoutput" dt-name="NUMERIC" dt-attr-1="1" dt-attr-2="0" transformed="2022-09-14 15:32:53" argument-order="5" argument-datatype="bit" argument-mode="IN" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Procedures,procedure sp_FillDimDate,category Parameters,parameter \@IsOutput" source-vendor="MSSQL" argument-default="1"/>
                            <parameter _I_D="51f7808a-179d-4e74-a4ca-0b23d36206a2" name="p_refcur" dt-name="refcursor" transformed="2022-09-14 15:32:53" argument-order="6" argument-datatype="refcursor" argument-mode="INOUT" argument-default="NULL"/>
                        </category>
                    </procedure>
                    <procedure _I_D="4870e3e2-86ed-4931-bddf-672a72ca8c8a" object-id="1061578820" schema-id="1" name="sp_fillfactincome" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Procedures,procedure sp_FillFactIncome" source-vendor="MSSQL" count-all-parsable-nodes="845" count-error-parsable-nodes="16" proc-language="plpgsql">
                        <complex-attribute name="sql"><![CDATA[&#x000d;
/*&#x000d;
Example:&#x000d;
[dbo].[sp_FillFactIncome]&#x000d;
*/&#x000d;
DECLARE&#x000d;
    var_SPName VARCHAR(510);&#x000d;
    var_SPParams TEXT;&#x000d;
    var_SPInfo TEXT;&#x000d;
    var_LogID INTEGER;&#x000d;
    var_RowCount INTEGER;&#x000d;
    var_Trancnt INTEGER;&#x000d;
    var_AuditMessage TEXT;&#x000d;
    var_ExecStr TEXT;&#x000d;
    var_OverridePrintEnabling NUMERIC(1, 0);&#x000d;
    var_Res INTEGER;&#x000d;
    var_RowCounttmp INTEGER;&#x000d;
    error_catch$ERROR_NUMBER TEXT;&#x000d;
    error_catch$ERROR_SEVERITY TEXT;&#x000d;
    error_catch$ERROR_STATE TEXT;&#x000d;
    error_catch$ERROR_LINE TEXT;&#x000d;
    error_catch$ERROR_PROCEDURE TEXT;&#x000d;
    error_catch$ERROR_MESSAGE TEXT;&#x000d;
    sp_auditstart$ReturnCode INTEGER;&#x000d;
    sp_print$ReturnCode INTEGER;&#x000d;
    sp_auditfinish$ReturnCode INTEGER;&#x000d;
BEGIN&#x000d;
    /*&#x000d;
    [7674 - Severity CRITICAL - AWS SCT can't convert the CONCAT_NULL_YIELDS_NULL clause of the SET statement. Convert your source code manually.]&#x000d;
    SET CONCAT_NULL_YIELDS_NULL ON&#x000d;
    */&#x000d;
    IF NOT EXISTS (SELECT&#x000d;
        *&#x000d;
        FROM tempdb_dbo.sysobjects&#x000d;
        WHERE id = aws_sqlserver_ext.object_id('tempdb.dbo.#AuditProc')) THEN&#x000d;
        CREATE TEMPORARY TABLE t$auditproc&#x000d;
        (logid INTEGER PRIMARY KEY NOT NULL);&#x000d;
    END IF;&#x000d;
    var_SPName := '[' + current_schema || '].[' + 'sp_fillfactincome' || ']';&#x000d;
    var_SPParams := '@ErrMessage=' || COALESCE('''' || par_ErrMessage || '''', 'NULL');&#x000d;
    CALL audit.sp_auditstart(par_SPName := var_SPName, par_SPParams := var_SPParams, par_LogID => var_LogID, return_code => sp_auditstart$ReturnCode);&#x000d;
    /*&#x000d;
    [7674 - Severity CRITICAL - AWS SCT can't convert the XACT_ABORT clause of the SET statement. Convert your source code manually.]&#x000d;
    SET XACT_ABORT OFF&#x000d;
    */&#x000d;
    /*&#x000d;
    [7674 - Severity CRITICAL - AWS SCT can't convert the CONCAT_NULL_YIELDS_NULL clause of the SET statement. Convert your source code manually.]&#x000d;
    SET CONCAT_NULL_YIELDS_NULL ON&#x000d;
    */&#x000d;
    var_OverridePrintEnabling := 0;&#x000d;
    var_AuditMessage := '[dbo].[sp_FillFactIncome]; start';&#x000d;
    CALL audit.sp_print(var_AuditMessage, var_OverridePrintEnabling, return_code => sp_print$ReturnCode);&#x000d;
&#x000d;
    BEGIN&#x000d;
        /*&#x000d;
        [7811 - Severity CRITICAL - PostgreSQL doesn't support the @@TRANCOUNT function. Review the converted code to make sure that the user-defined function produces the same results as the source code.]&#x000d;
        SET @Trancnt = @@TRANCOUNT&#x000d;
        */&#x000d;
        IF var_Trancnt > 0 THEN&#x000d;
            /*&#x000d;
            [7807 - Severity CRITICAL - PostgreSQL does not support explicit transaction management commands such as BEGIN TRAN, SAVE TRAN in functions. Convert your source code manually.]&#x000d;
            SAVE TRAN tr_FillFactIncome&#x000d;
            */&#x000d;
            BEGIN&#x000d;
            END;&#x000d;
        ELSE&#x000d;
            /*&#x000d;
            [7807 - Severity CRITICAL - PostgreSQL does not support explicit transaction management commands such as BEGIN TRAN, SAVE TRAN in functions. Convert your source code manually.]&#x000d;
            BEGIN TRAN&#x000d;
            */&#x000d;
            BEGIN&#x000d;
            END;&#x000d;
        END IF;&#x000d;
        TRUNCATE TABLE dbo.factincome;&#x000d;
        INSERT INTO dbo.factincome (dateid, batchid, incomevalue, createdate)&#x000d;
        SELECT&#x000d;
            fih.dateid, fih.batchid, (fih.incomeusd) * der.exchangerates AS incomevalue, clock_timestamp() AS createdate&#x000d;
            FROM dbo.factincomehistory AS fih&#x000d;
            INNER JOIN dbo.dimexchrateusd AS der&#x000d;
                ON fih.dateid = der.dateid&#x000d;
            WHERE fih.endbatchid IS NULL;&#x000d;
        GET DIAGNOSTICS var_RowCount = ROW_COUNT;&#x000d;
        INSERT INTO dbo.factincome (dateid, batchid, incomevalue, createdate)&#x000d;
        SELECT&#x000d;
            dateid, ex.batchid, ex.incomevalue - base.incomevalue AS incomevalue, clock_timestamp() AS createdate&#x000d;
            FROM (SELECT&#x000d;
                fih.id, fih.dateid, (fih.exchangevalue) * der.exchangerates AS incomevalue, der.exchangerates AS der_exchangerates&#x000d;
                FROM dbo.factincomehistory AS fih&#x000d;
                INNER JOIN dbo.dimexchrateusd AS der&#x000d;
                    ON fih.dateid = der.dateid&#x000d;
                WHERE fih.endbatchid IS NULL) AS base&#x000d;
            INNER JOIN (SELECT&#x000d;
                fih.id, fih.exchangedateid, fih.batchid, (fih.exchangevalue) * der.exchangerates AS incomevalue, der.exchangerates AS der_exchangerates&#x000d;
                FROM dbo.factincomehistory AS fih&#x000d;
                LEFT OUTER JOIN dbo.dimexchrateusd AS der&#x000d;
                    ON fih.exchangedateid = der.dateid&#x000d;
                WHERE fih.endbatchid IS NULL AND NOT fih.exchangevalue IS NULL) AS ex&#x000d;
                ON base.id = ex.id&#x000d;
            WHERE base.incomevalue < ex.incomevalue;&#x000d;
        GET DIAGNOSTICS var_RowCounttmp = ROW_COUNT;&#x000d;
        var_RowCount := var_RowCount + var_RowCounttmp;&#x000d;
&#x000d;
        IF var_Trancnt = 0 THEN&#x000d;
            COMMIT;&#x000d;
        END IF;&#x000d;
        var_AuditMessage := '[dbo].[sp_FillFactIncome] Inserted FactIncome @RowCount= ' || LTRIM(to_char(var_RowCount::DOUBLE PRECISION, '9999999999')) || ' finish';&#x000d;
        CALL audit.sp_print(var_AuditMessage, var_OverridePrintEnabling, return_code => sp_print$ReturnCode);&#x000d;
        CALL audit.sp_auditfinish(par_LogID := var_LogID, par_RecordCount := var_RowCount, return_code => sp_auditfinish$ReturnCode);&#x000d;
        EXCEPTION&#x000d;
            WHEN OTHERS THEN&#x000d;
                error_catch$ERROR_NUMBER := '0';&#x000d;
                error_catch$ERROR_SEVERITY := '0';&#x000d;
                error_catch$ERROR_LINE := '0';&#x000d;
                error_catch$ERROR_PROCEDURE := 'SP_FILLFACTINCOME';&#x000d;
                GET STACKED DIAGNOSTICS error_catch$ERROR_STATE = RETURNED_SQLSTATE,&#x000d;
                    error_catch$ERROR_MESSAGE = MESSAGE_TEXT;&#x000d;
                SELECT&#x000d;
                    error_catch$ERROR_MESSAGE&#x000d;
                    INTO par_ErrMessage;&#x000d;
&#x000d;
                IF var_Trancnt = 0 THEN&#x000d;
                    ROLLBACK;&#x000d;
                ELSE&#x000d;
                    IF xact_state() != - 1 THEN&#x000d;
                        ROLLBACK;&#x000d;
                    END IF;&#x000d;
                END IF;&#x000d;
&#x000d;
                IF xact_state() != - 1 THEN&#x000d;
                    var_AuditMessage := '[dbo].[sp_FillFactIncome]; error=''' || par_ErrMessage || '''';&#x000d;
                    CALL audit.sp_print(var_AuditMessage, 2, return_code => sp_print$ReturnCode);&#x000d;
                    CALL audit.sp_auditerror(par_LogID := var_LogID, par_ErrorMessage := par_ErrMessage);&#x000d;
                END IF;&#x000d;
                CALL audit.sp_auditfinish(par_LogID := var_LogID, par_RecordCount := var_RowCount, return_code => sp_auditfinish$ReturnCode);&#x000d;
                return_code := - 1;&#x000d;
                RETURN;&#x000d;
    END;&#x000d;
    /*&#x000d;
    &#x000d;
    DROP TABLE IF EXISTS t$auditproc;&#x000d;
    */&#x000d;
    /*&#x000d;
    &#x000d;
    Temporary table must be removed before end of the function.&#x000d;
    */&#x000d;
END;]]></complex-attribute>
                        <category _I_D="d54c9d49-6d80-429f-a495-ac5eb8cffbd0" name="Parameters" order-num="0" child-type="parameter" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Procedures,procedure sp_FillFactIncome,category Parameters">
                            <parameter _I_D="f69c4ef0-a237-468e-ba12-fb9886ba4b75" name="par_errmessage" dt-name="VARCHAR" dt-attr-1="4000" transformed="2022-09-14 15:32:53" argument-order="1" argument-datatype="nvarchar" argument-mode="INOUT" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Procedures,procedure sp_FillFactIncome,category Parameters,parameter \@ErrMessage" source-vendor="MSSQL" argument-default="NULL"/>
                            <parameter _I_D="6b9f378d-f71f-4c7b-93e6-371232008221" name="return_code" dt-name="int" transformed="2022-09-14 15:32:53" argument-order="2" argument-datatype="int" argument-mode="INOUT" argument-default="0"/>
                        </category>
                    </procedure>
                    <procedure _I_D="9867d126-ddf1-4651-a721-bd7256a932f6" object-id="1237579447" schema-id="1" name="sp_runbatch" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Procedures,procedure sp_RunBatch" source-vendor="MSSQL" count-all-parsable-nodes="1398" count-error-parsable-nodes="31" proc-language="plpgsql">
                        <complex-attribute name="sql"><![CDATA[&#x000d;
/*&#x000d;
Example:&#x000d;
[dbo].[sp_RunBatch]&#x000d;
TRUNCATE TABLE [audit].[LogProcedures]&#x000d;
SELECT * FROM [audit].[LogProcedures]&#x000d;
SELECT 'ExcelFileIncomeBookCmd',''&#x000d;
INSERT [meta].[ConfigApp] (Parameter, StrValue) VALUES( 'ExcelFileIncomeBook','E:\Work\SQL\IndividualEntrepreneur\IncomeBook.xlsx')&#x000d;
UPDATE [meta].[ConfigApp] SET StrValue = 'E:\Work\SQL\IndividualEntrepreneur\Declaration.xlsm'&#x000d;
WHERE Parameter = 'ExcelFileIncomeBook'&#x000d;
	EXEC [dbo].[sp_RunBatch]&#x000d;
	EXEC [dbo].[sp_RunTransform]&#x000d;
	EXEC [dbo].[sp_FillFactIncome]&#x000d;
*/&#x000d;
DECLARE&#x000d;
    var_SPName VARCHAR(510);&#x000d;
    var_SPParams TEXT;&#x000d;
    var_SPInfo TEXT;&#x000d;
    var_LogID INTEGER;&#x000d;
    var_RowCount INTEGER;&#x000d;
    var_Trancnt INTEGER;&#x000d;
    var_AuditMessage TEXT;&#x000d;
    var_ExecStr TEXT;&#x000d;
    var_OverridePrintEnabling NUMERIC(1, 0);&#x000d;
    var_Res INTEGER;&#x000d;
    var_BatchID INTEGER;&#x000d;
    var_FromDate INTEGER;&#x000d;
    var_ToDate INTEGER;&#x000d;
    var_CreateDate TIMESTAMP WITHOUT TIME ZONE;&#x000d;
    var_StartDate INTEGER;&#x000d;
    var_ID INTEGER;&#x000d;
    var_EndDate INTEGER;&#x000d;
    /*&#x000d;
    [7774 - Severity CRITICAL - AWS SCT can't convert arithmetic operations with mixed types of operands. Revise your code to use cast operands to the expected type, and try again.]&#x000d;
    PeriodsTable CURSOR LOCAL STATIC FOR&#x000d;
    		SELECT&#x000d;
    			r.ID,&#x000d;
    			StartDate = s.FullDateAlternateKey,&#x000d;
    			EndDate = DATEADD(mm,1 ,e.FullDateAlternateKey)&#x000d;
    		FROM (&#x000d;
    		SELECT sr.ID,&#x000d;
    				StartDate = CAST(sr.DateID / 100 AS int) * 100 + 1,&#x000d;
    				EndDate = CAST(ed.DateID / 100 AS int) * 100 + 1&#x000d;
    &#x000d;
    			FROM (&#x000d;
    				SELECT ID =ROW_NUMBER() OVER (ORDER BY DateID),&#x000d;
    				DateID = CASE WHEN dLag is Null THEN DateID&#x000d;
    					ELSE (&#x000d;
    						CASE WHEN IsNull(dDiff,1) <> 1 THEN idLead&#x000d;
    						ELSE NULL&#x000d;
    						END&#x000d;
    					)&#x000d;
    					END&#x000d;
    			FROM #tmp1&#x000d;
    			WHERE dLag is Null or IsNull(dDiff,1) <> 1&#x000d;
    			) sr INNER JOIN (&#x000d;
    				SELECT ID = ROW_NUMBER() OVER (ORDER BY DateID), DateID&#x000d;
    				FROM #tmp1&#x000d;
    				WHERE IsNULL(dDiff,2) <> 1&#x000d;
    				) ed ON sr.ID = ed.ID&#x000d;
    			) r INNER JOIN DimDate s ON s.DateID = r.StartDate&#x000d;
    			INNER JOIN DimDate e ON e.DateID = r.EndDate&#x000d;
    		ORDER BY ID&#x000d;
    */&#x000d;
    var_Start TIMESTAMP WITHOUT TIME ZONE;&#x000d;
    var_End TIMESTAMP WITHOUT TIME ZONE;&#x000d;
    error_catch$ERROR_NUMBER TEXT;&#x000d;
    error_catch$ERROR_SEVERITY TEXT;&#x000d;
    error_catch$ERROR_STATE TEXT;&#x000d;
    error_catch$ERROR_LINE TEXT;&#x000d;
    error_catch$ERROR_PROCEDURE TEXT;&#x000d;
    error_catch$ERROR_MESSAGE TEXT;&#x000d;
    sp_auditstart$ReturnCode INTEGER;&#x000d;
    sp_print$ReturnCode INTEGER;&#x000d;
    sp_auditfinish$ReturnCode INTEGER;&#x000d;
BEGIN&#x000d;
    /*&#x000d;
    [7674 - Severity CRITICAL - AWS SCT can't convert the CONCAT_NULL_YIELDS_NULL clause of the SET statement. Convert your source code manually.]&#x000d;
    SET CONCAT_NULL_YIELDS_NULL ON&#x000d;
    */&#x000d;
    IF NOT EXISTS (SELECT&#x000d;
        *&#x000d;
        FROM tempdb_dbo.sysobjects&#x000d;
        WHERE id = aws_sqlserver_ext.object_id('tempdb.dbo.#AuditProc')) THEN&#x000d;
        CREATE TEMPORARY TABLE t$auditproc&#x000d;
        (logid INTEGER PRIMARY KEY NOT NULL);&#x000d;
    END IF;&#x000d;
    var_SPName := '[' + current_schema || '].[' + 'sp_runbatch' || ']';&#x000d;
    var_SPParams := '@ErrMessage=' || COALESCE('''' || par_ErrMessage || '''', 'NULL');&#x000d;
    CALL audit.sp_auditstart(par_SPName := var_SPName, par_SPParams := var_SPParams, par_LogID => var_LogID, return_code => sp_auditstart$ReturnCode);&#x000d;
    /*&#x000d;
    [7674 - Severity CRITICAL - AWS SCT can't convert the XACT_ABORT clause of the SET statement. Convert your source code manually.]&#x000d;
    SET XACT_ABORT OFF&#x000d;
    */&#x000d;
    /*&#x000d;
    [7674 - Severity CRITICAL - AWS SCT can't convert the CONCAT_NULL_YIELDS_NULL clause of the SET statement. Convert your source code manually.]&#x000d;
    SET CONCAT_NULL_YIELDS_NULL ON&#x000d;
    */&#x000d;
    var_OverridePrintEnabling := 0;&#x000d;
    var_AuditMessage := '[dbo].[sp_RunBatch]; start';&#x000d;
    CALL audit.sp_print(var_AuditMessage, var_OverridePrintEnabling, return_code => sp_print$ReturnCode);&#x000d;
&#x000d;
    BEGIN&#x000d;
        /*&#x000d;
        [7811 - Severity CRITICAL - PostgreSQL doesn't support the @@TRANCOUNT function. Review the converted code to make sure that the user-defined function produces the same results as the source code.]&#x000d;
        SET @Trancnt = @@TRANCOUNT&#x000d;
        */&#x000d;
        IF var_Trancnt > 0 THEN&#x000d;
            /*&#x000d;
            [7807 - Severity CRITICAL - PostgreSQL does not support explicit transaction management commands such as BEGIN TRAN, SAVE TRAN in functions. Convert your source code manually.]&#x000d;
            SAVE TRAN tr_GenerateTable&#x000d;
            */&#x000d;
            BEGIN&#x000d;
            END;&#x000d;
        ELSE&#x000d;
            /*&#x000d;
            [7807 - Severity CRITICAL - PostgreSQL does not support explicit transaction management commands such as BEGIN TRAN, SAVE TRAN in functions. Convert your source code manually.]&#x000d;
            BEGIN TRAN&#x000d;
            */&#x000d;
            BEGIN&#x000d;
            END;&#x000d;
        END IF;&#x000d;
        SELECT&#x000d;
            clock_timestamp(), CAST (aws_sqlserver_ext.conv_datetime_to_string('VARCHAR(25)', 'DATETIME', clock_timestamp(), 112) AS INTEGER)&#x000d;
            INTO var_CreateDate, var_StartDate;&#x000d;
        INSERT INTO dbo.dimbatch (dateid, createdate)&#x000d;
        SELECT&#x000d;
            var_StartDate, var_CreateDate;&#x000d;
        TRUNCATE TABLE upload.incomebook;&#x000d;
        CALL upload.upl_incomebook(par_ErrMessage => par_ErrMessage, return_code => var_Res);&#x000d;
&#x000d;
        IF var_Res != 0 THEN&#x000d;
            RAISE 'Error %, severity %, state % was raised. Message: %. Argument: %', '50000', 16, 1, 'Error: [%]', par_ErrMessage USING ERRCODE = '50000';&#x000d;
        END IF;&#x000d;
        SELECT&#x000d;
            MIN(dateid), MAX(dateid)&#x000d;
            INTO var_FromDate, var_ToDate&#x000d;
            FROM upload.incomebook AS i&#x000d;
            INNER JOIN dbo.dimdate AS d&#x000d;
                ON i.date = d.fulldatealternatekey;&#x000d;
&#x000d;
        IF EXISTS (SELECT&#x000d;
            *&#x000d;
            FROM dbo.dimdate AS d&#x000d;
            LEFT OUTER JOIN upload.incomebook AS i&#x000d;
                ON i.date = d.fulldatealternatekey&#x000d;
            WHERE i.date IS NULL AND (dateid >= var_FromDate OR dateid <= var_ToDate)) THEN&#x000d;
            TRUNCATE TABLE upload.currencyperiod;&#x000d;
            TRUNCATE TABLE upload.cbrusdrate;&#x000d;
            SELECT&#x000d;
                MIN(dateid), MAX(dateid)&#x000d;
                INTO var_FromDate, var_ToDate&#x000d;
                FROM upload.incomebook AS i&#x000d;
                INNER JOIN dbo.dimdate AS d&#x000d;
                    ON i.date = d.fulldatealternatekey;&#x000d;
            SELECT&#x000d;
                MAX(batchid)&#x000d;
                INTO var_BatchID&#x000d;
                FROM dbo.dimbatch;&#x000d;
            CREATE TEMPORARY TABLE t$tmp1&#x000d;
            AS&#x000d;
            SELECT&#x000d;
                d.dateid, fulldatealternatekey, lead(d.dateid, 1, 0) OVER (ORDER BY d.dateid) AS idlead, lead(d.fulldatealternatekey) OVER (ORDER BY d.dateid) AS dlead, lag(d.fulldatealternatekey) OVER (ORDER BY d.dateid) AS dlag, aws_sqlserver_ext.datediff('day', d.fulldatealternatekey::TIMESTAMP, lead(d.fulldatealternatekey) OVER (ORDER BY d.dateid)::TIMESTAMP) AS ddiff&#x000d;
                FROM dbo.dimdate AS d&#x000d;
                LEFT OUTER JOIN dbo.dimexchrateusd AS i&#x000d;
                    ON i.dateid = d.dateid&#x000d;
                WHERE i.dateid IS NULL AND (d.dateid >= var_FromDate AND d.dateid <= var_ToDate);&#x000d;
            /*&#x000d;
            [7774 - Severity CRITICAL - AWS SCT can't convert arithmetic operations with mixed types of operands. Revise your code to use cast operands to the expected type, and try again.]&#x000d;
            OPEN PeriodsTable&#x000d;
            */&#x000d;
            /*&#x000d;
            [7774 - Severity CRITICAL - AWS SCT can't convert arithmetic operations with mixed types of operands. Revise your code to use cast operands to the expected type, and try again.]&#x000d;
            FETCH NEXT FROM PeriodsTable INTO @ID, @Start, @End&#x000d;
            */&#x000d;
            WHILE (CASE FOUND::INT&#x000d;
                WHEN 0 THEN - 1&#x000d;
                ELSE 0&#x000d;
            END) = 0 LOOP&#x000d;
                INSERT INTO upload.currencyperiod (batchid, dateid_start, dateid_end, createdate)&#x000d;
                SELECT&#x000d;
                    var_BatchID, CAST (aws_sqlserver_ext.conv_datetime_to_string('VARCHAR(25)', 'DATETIME', var_Start, 112) AS INTEGER), CAST (aws_sqlserver_ext.conv_datetime_to_string('VARCHAR(25)', 'DATETIME', var_End, 112) AS INTEGER), var_CreateDate;&#x000d;
                CALL upload.upl_cbrusdrate(par_FromDate := var_Start, par_ToDate := var_End, par_ErrMessage => par_ErrMessage, return_code => var_Res);&#x000d;
&#x000d;
                IF var_Res != 0 THEN&#x000d;
                    /*&#x000d;
                    [7774 - Severity CRITICAL - AWS SCT can't convert arithmetic operations with mixed types of operands. Revise your code to use cast operands to the expected type, and try again.]&#x000d;
                    CLOSE PeriodsTable&#x000d;
                    */&#x000d;
                    RAISE 'Error %, severity %, state % was raised. Message: %. Argument: %', '50000', 16, 1, 'Error: [%]', par_ErrMessage USING ERRCODE = '50000';&#x000d;
                END IF;&#x000d;
                /*&#x000d;
                [7774 - Severity CRITICAL - AWS SCT can't convert arithmetic operations with mixed types of operands. Revise your code to use cast operands to the expected type, and try again.]&#x000d;
                FETCH NEXT FROM PeriodsTable INTO @ID, @Start, @End&#x000d;
                */&#x000d;
            END LOOP;&#x000d;
            /*&#x000d;
            [7774 - Severity CRITICAL - AWS SCT can't convert arithmetic operations with mixed types of operands. Revise your code to use cast operands to the expected type, and try again.]&#x000d;
            CLOSE PeriodsTable&#x000d;
            */&#x000d;
        END IF;&#x000d;
&#x000d;
        IF var_Trancnt = 0 THEN&#x000d;
            COMMIT;&#x000d;
        END IF;&#x000d;
        var_AuditMessage := '[dbo].[sp_RunBatch]; finish';&#x000d;
        CALL audit.sp_print(var_AuditMessage, var_OverridePrintEnabling, return_code => sp_print$ReturnCode);&#x000d;
        CALL audit.sp_auditfinish(par_LogID := var_LogID, par_RecordCount := var_RowCount, return_code => sp_auditfinish$ReturnCode);&#x000d;
        EXCEPTION&#x000d;
            WHEN OTHERS THEN&#x000d;
                error_catch$ERROR_NUMBER := '0';&#x000d;
                error_catch$ERROR_SEVERITY := '0';&#x000d;
                error_catch$ERROR_LINE := '0';&#x000d;
                error_catch$ERROR_PROCEDURE := 'SP_RUNBATCH';&#x000d;
                GET STACKED DIAGNOSTICS error_catch$ERROR_STATE = RETURNED_SQLSTATE,&#x000d;
                    error_catch$ERROR_MESSAGE = MESSAGE_TEXT;&#x000d;
                SELECT&#x000d;
                    error_catch$ERROR_MESSAGE&#x000d;
                    INTO par_ErrMessage;&#x000d;
&#x000d;
                IF var_Trancnt = 0 THEN&#x000d;
                    ROLLBACK;&#x000d;
                ELSE&#x000d;
                    IF xact_state() != - 1 THEN&#x000d;
                        ROLLBACK;&#x000d;
                    END IF;&#x000d;
                END IF;&#x000d;
&#x000d;
                IF xact_state() != - 1 THEN&#x000d;
                    var_AuditMessage := '[dbo].[sp_RunBatch]; error=''' || par_ErrMessage || '''';&#x000d;
                    CALL audit.sp_print(var_AuditMessage, 2, return_code => sp_print$ReturnCode);&#x000d;
                    CALL audit.sp_auditerror(par_LogID := var_LogID, par_ErrorMessage := par_ErrMessage);&#x000d;
                END IF;&#x000d;
                CALL audit.sp_auditfinish(par_LogID := var_LogID, par_RecordCount := var_RowCount, return_code => sp_auditfinish$ReturnCode);&#x000d;
                return_code := - 1;&#x000d;
                RETURN;&#x000d;
    END;&#x000d;
    /*&#x000d;
    &#x000d;
    DROP TABLE IF EXISTS t$auditproc;&#x000d;
    */&#x000d;
    /*&#x000d;
    &#x000d;
    Temporary table must be removed before end of the function.&#x000d;
    */&#x000d;
    /*&#x000d;
    &#x000d;
    DROP TABLE IF EXISTS t$tmp1;&#x000d;
    */&#x000d;
    /*&#x000d;
    &#x000d;
    Temporary table must be removed before end of the function.&#x000d;
    */&#x000d;
END;]]></complex-attribute>
                        <category _I_D="2be096c5-bd71-4355-8027-d6dc77cf9609" name="Parameters" order-num="0" child-type="parameter" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Procedures,procedure sp_RunBatch,category Parameters">
                            <parameter _I_D="4442d02a-8120-43ef-abde-a5a6264501d5" name="par_errmessage" dt-name="VARCHAR" dt-attr-1="4000" transformed="2022-09-14 15:32:53" argument-order="1" argument-datatype="nvarchar" argument-mode="INOUT" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Procedures,procedure sp_RunBatch,category Parameters,parameter \@ErrMessage" source-vendor="MSSQL" argument-default="NULL"/>
                            <parameter _I_D="aabe16e2-b114-4462-bae2-a7eecaf57e87" name="return_code" dt-name="int" transformed="2022-09-14 15:32:53" argument-order="2" argument-datatype="int" argument-mode="INOUT" argument-default="0"/>
                        </category>
                    </procedure>
                    <procedure _I_D="a4dd4e42-9ce5-4931-990c-84ccac858246" object-id="1141579105" schema-id="1" name="sp_runtransform" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Procedures,procedure sp_RunTransform" source-vendor="MSSQL" count-all-parsable-nodes="1767" count-error-parsable-nodes="174" proc-language="plpgsql">
                        <complex-attribute name="sql"><![CDATA[&#x000d;
/*&#x000d;
Example:&#x000d;
[dbo].[sp_RunTransform]&#x000d;
*/&#x000d;
DECLARE&#x000d;
    var_SPName VARCHAR(510);&#x000d;
    var_SPParams TEXT;&#x000d;
    var_SPInfo TEXT;&#x000d;
    var_LogID INTEGER;&#x000d;
    var_RowCount INTEGER;&#x000d;
    var_Trancnt INTEGER;&#x000d;
    var_AuditMessage TEXT;&#x000d;
    var_ExecStr TEXT;&#x000d;
    var_OverridePrintEnabling NUMERIC(1, 0);&#x000d;
    var_Res INTEGER;&#x000d;
    var_BatchID INTEGER;&#x000d;
    var_FromDate INTEGER;&#x000d;
    var_ToDate INTEGER;&#x000d;
    var_CreateDate TIMESTAMP WITHOUT TIME ZONE;&#x000d;
    var_StartDate INTEGER;&#x000d;
    error_catch$ERROR_NUMBER TEXT;&#x000d;
    error_catch$ERROR_SEVERITY TEXT;&#x000d;
    error_catch$ERROR_STATE TEXT;&#x000d;
    error_catch$ERROR_LINE TEXT;&#x000d;
    error_catch$ERROR_PROCEDURE TEXT;&#x000d;
    error_catch$ERROR_MESSAGE TEXT;&#x000d;
    sp_auditstart$ReturnCode INTEGER;&#x000d;
    sp_print$ReturnCode INTEGER;&#x000d;
    sp_auditfinish$ReturnCode INTEGER;&#x000d;
BEGIN&#x000d;
    /*&#x000d;
    [7674 - Severity CRITICAL - AWS SCT can't convert the CONCAT_NULL_YIELDS_NULL clause of the SET statement. Convert your source code manually.]&#x000d;
    SET CONCAT_NULL_YIELDS_NULL ON&#x000d;
    */&#x000d;
    IF NOT EXISTS (SELECT&#x000d;
        *&#x000d;
        FROM tempdb_dbo.sysobjects&#x000d;
        WHERE id = aws_sqlserver_ext.object_id('tempdb.dbo.#AuditProc')) THEN&#x000d;
        CREATE TEMPORARY TABLE t$auditproc&#x000d;
        (logid INTEGER PRIMARY KEY NOT NULL);&#x000d;
    END IF;&#x000d;
    var_SPName := '[' + current_schema || '].[' + 'sp_runtransform' || ']';&#x000d;
    var_SPParams := '@ErrMessage=' || COALESCE('''' || par_ErrMessage || '''', 'NULL');&#x000d;
    CALL audit.sp_auditstart(par_SPName := var_SPName, par_SPParams := var_SPParams, par_LogID => var_LogID, return_code => sp_auditstart$ReturnCode);&#x000d;
    /*&#x000d;
    [7674 - Severity CRITICAL - AWS SCT can't convert the XACT_ABORT clause of the SET statement. Convert your source code manually.]&#x000d;
    SET XACT_ABORT OFF&#x000d;
    */&#x000d;
    /*&#x000d;
    [7674 - Severity CRITICAL - AWS SCT can't convert the CONCAT_NULL_YIELDS_NULL clause of the SET statement. Convert your source code manually.]&#x000d;
    SET CONCAT_NULL_YIELDS_NULL ON&#x000d;
    */&#x000d;
    var_OverridePrintEnabling := 0;&#x000d;
    var_AuditMessage := '[dbo].[sp_RunTransform]; start';&#x000d;
    CALL audit.sp_print(var_AuditMessage, var_OverridePrintEnabling, return_code => sp_print$ReturnCode);&#x000d;
&#x000d;
    BEGIN&#x000d;
        /*&#x000d;
        [7811 - Severity CRITICAL - PostgreSQL doesn't support the @@TRANCOUNT function. Review the converted code to make sure that the user-defined function produces the same results as the source code.]&#x000d;
        SET @Trancnt = @@TRANCOUNT&#x000d;
        */&#x000d;
        IF var_Trancnt > 0 THEN&#x000d;
            /*&#x000d;
            [7807 - Severity CRITICAL - PostgreSQL does not support explicit transaction management commands such as BEGIN TRAN, SAVE TRAN in functions. Convert your source code manually.]&#x000d;
            SAVE TRAN tr_RunTransform&#x000d;
            */&#x000d;
            BEGIN&#x000d;
            END;&#x000d;
        ELSE&#x000d;
            /*&#x000d;
            [7807 - Severity CRITICAL - PostgreSQL does not support explicit transaction management commands such as BEGIN TRAN, SAVE TRAN in functions. Convert your source code manually.]&#x000d;
            BEGIN TRAN&#x000d;
            */&#x000d;
            BEGIN&#x000d;
            END;&#x000d;
        END IF;&#x000d;
        SELECT&#x000d;
            clock_timestamp(), CAST (aws_sqlserver_ext.conv_datetime_to_string('VARCHAR(25)', 'DATETIME', clock_timestamp(), 112) AS INTEGER)&#x000d;
            INTO var_CreateDate, var_StartDate;&#x000d;
        SELECT&#x000d;
            MAX(batchid)&#x000d;
            INTO var_BatchID&#x000d;
            FROM dbo.dimbatch;&#x000d;
&#x000d;
        IF EXISTS (SELECT&#x000d;
            *&#x000d;
            FROM upload.cbrusdrate) THEN&#x000d;
            INSERT INTO dbo.dimexchrateusd (DateID, BatchID, ExchangeRates, CreateDate)&#x000d;
            VALUES (dd.DateID, der.BatchID, der.ExchangeRates, der.CreateDate, der.Date, dd.FullDateAlternateKey, der.Date, dd.DateID, c.DateID_Start, dd.DateID, c.DateID_End, der.Date, [Date], var_BatchID, ExchangeRates, var_CreateDate, der.NextDate, Date, Date)&#x000d;
            ON CONFLICT (DateID) DO UPDATE SET BatchID = excluded.BatchID, ExchangeRates = excluded.ExchangeRates, CreateDate = excluded.CreateDate;&#x000d;
            /*&#x000d;
            [7833 - Severity CRITICAL - AWS SCT can't convert the @@rowcount function in the current context. Convert your source code manually.]&#x000d;
            SET @RowCount = @@ROWCOUNT&#x000d;
            */&#x000d;
            var_AuditMessage := '[dbo].[sp_RunTransform]; Merge DimExchRateUSD @RowCount= ' || LTRIM(to_char(var_RowCount::DOUBLE PRECISION, '9999999999')) || ' ';&#x000d;
            CALL audit.sp_print(var_AuditMessage, var_OverridePrintEnabling, return_code => sp_print$ReturnCode);&#x000d;
        END IF;&#x000d;
        TRUNCATE TABLE staging.factincomehistory;&#x000d;
        /*&#x000d;
        [7708 - Severity CRITICAL - AWS SCT can't convert the usage of the unsupported VARBINARY data type. Convert your source code manually., 7708 - Severity CRITICAL - AWS SCT can't convert the usage of the unsupported VARBINARY data type. Convert your source code manually.]&#x000d;
        INSERT [staging].[FactIncomeHistory]([DateID], [BatchID], [IncomeUSD], [NaturalKey], [VersionKey], [ExchangeDateID], [ExchangeValue], [ExchangeRate])&#x000d;
        	SELECT d.[DateID],&#x000d;
        		BatchID = @BatchID,&#x000d;
        		[IncomeUSD],&#x000d;
        		[NaturalKey] = CAST (SUBSTRING(HASHBYTES ( 'SHA2_256', LTRIM(RTRIM(STR(d.[CalendarYear]))) + LTRIM(RTRIM(STR(d.[MonthNumberOfYear]))) ), 0,32) as uniqueidentifier),&#x000d;
        		[VersionKey] = CAST (SUBSTRING(HASHBYTES ( 'SHA2_256', LTRIM(RTRIM(STR(d.[DateID]))) + CAST([IncomeUSD] as varchar(30)) + LTRIM(RTRIM(IsNull(STR(d2.[DateID]),'null'))) + IsNull(CAST([ExchangeValue] as varchar(30)) ,'null') + IsNull(CAST([ExchangeRate] as varchar(30)) ,'null')  )  , 0,32) as uniqueidentifier),&#x000d;
        		[ExchangeDateID] = d2.[DateID],&#x000d;
        		i.[ExchangeValue],&#x000d;
        		i.[ExchangeRate]&#x000d;
        	FROM [upload].[IncomeBook] i INNER JOIN DimDate d ON  CAST(i.Date as date) = d.FullDateAlternateKey&#x000d;
        		LEFT JOIN DimDate d2 ON  CAST(i.ExchangeData as date) = d2.FullDateAlternateKey&#x000d;
        */&#x000d;
        SELECT&#x000d;
            MIN(dateid), MAX(dateid)&#x000d;
            INTO var_FromDate, var_ToDate&#x000d;
            FROM staging.factincomehistory;&#x000d;
        /* Fix deleted */&#x000d;
        INSERT INTO staging.factincomehistory (id, dateid, batchid, incomeusd, naturalkey, versionkey, exchangedateid, exchangevalue, exchangerate, endbatchid)&#x000d;
        SELECT&#x000d;
            source.id, source.dateid, source.batchid, source.incomeusd, source.naturalkey, source.versionkey, source.exchangedateid, source.exchangevalue, source.exchangerate, var_BatchID&#x000d;
            FROM dbo.factincomehistory AS source&#x000d;
            WHERE source.endbatchid IS NULL AND NOT EXISTS (SELECT&#x000d;
                1&#x000d;
                FROM staging.factincomehistory AS target&#x000d;
                WHERE source.naturalkey = target.naturalkey) AND (source.dateid >= var_FromDate OR source.dateid <= var_ToDate);&#x000d;
        GET DIAGNOSTICS var_RowCount = ROW_COUNT;&#x000d;
        DELETE FROM staging.factincomehistory AS source&#x000d;
        USING dbo.factincomehistory AS source, staging.factincomehistory AS target&#x000d;
            WHERE source.endbatchid IS NULL AND target.id IS NULL AND (source.naturalkey = target.naturalkey AND source.versionkey = target.versionkey);&#x000d;
        INSERT INTO staging.factincomehistory (id, dateid, batchid, incomeusd, naturalkey, versionkey, exchangedateid, exchangevalue, exchangerate, endbatchid)&#x000d;
        SELECT&#x000d;
            source.id, source.dateid, source.batchid, source.incomeusd, source.naturalkey, source.versionkey, source.exchangedateid, source.exchangevalue, source.exchangerate, var_BatchID&#x000d;
            FROM dbo.factincomehistory AS source&#x000d;
            WHERE source.endbatchid IS NULL AND EXISTS (SELECT&#x000d;
                1&#x000d;
                FROM staging.factincomehistory AS target&#x000d;
                WHERE source.naturalkey = target.naturalkey AND target.id IS NULL);&#x000d;
        GET DIAGNOSTICS var_RowCount = ROW_COUNT;&#x000d;
        INSERT INTO dbo.factincomehistory ([DateID], [BatchID], [IncomeUSD], [NaturalKey], [VersionKey], [ExchangeDateID], [ExchangeValue], [ExchangeRate], CreateDate)&#x000d;
        VALUES (dd.DateID, der.BatchID, der.ExchangeRates, der.CreateDate, der.Date, dd.FullDateAlternateKey, der.Date, dd.DateID, c.DateID_Start, dd.DateID, c.DateID_End, der.Date, [Date], var_BatchID, ExchangeRates, var_CreateDate, der.NextDate, Date, Date)&#x000d;
        ON CONFLICT (ID) DO UPDATE SET EndBatchID = excluded.EndBatchID, [ChangeDate] = excluded.[ChangeDate];&#x000d;
        /*&#x000d;
        [7833 - Severity CRITICAL - AWS SCT can't convert the @@rowcount function in the current context. Convert your source code manually.]&#x000d;
        SET @RowCount = @@ROWCOUNT&#x000d;
        */&#x000d;
        IF var_Trancnt = 0 THEN&#x000d;
            COMMIT;&#x000d;
        END IF;&#x000d;
        var_AuditMessage := '[dbo].[sp_RunTransform]; Merge FactIncomeHistory @RowCount= ' || LTRIM(to_char(var_RowCount::DOUBLE PRECISION, '9999999999')) || '; finish';&#x000d;
        CALL audit.sp_print(var_AuditMessage, var_OverridePrintEnabling, return_code => sp_print$ReturnCode);&#x000d;
        CALL audit.sp_auditfinish(par_LogID := var_LogID, par_RecordCount := var_RowCount, return_code => sp_auditfinish$ReturnCode);&#x000d;
        EXCEPTION&#x000d;
            WHEN OTHERS THEN&#x000d;
                error_catch$ERROR_NUMBER := '0';&#x000d;
                error_catch$ERROR_SEVERITY := '0';&#x000d;
                error_catch$ERROR_LINE := '0';&#x000d;
                error_catch$ERROR_PROCEDURE := 'SP_RUNTRANSFORM';&#x000d;
                GET STACKED DIAGNOSTICS error_catch$ERROR_STATE = RETURNED_SQLSTATE,&#x000d;
                    error_catch$ERROR_MESSAGE = MESSAGE_TEXT;&#x000d;
                SELECT&#x000d;
                    error_catch$ERROR_MESSAGE&#x000d;
                    INTO par_ErrMessage;&#x000d;
&#x000d;
                IF var_Trancnt = 0 THEN&#x000d;
                    ROLLBACK;&#x000d;
                ELSE&#x000d;
                    IF xact_state() != - 1 THEN&#x000d;
                        ROLLBACK;&#x000d;
                    END IF;&#x000d;
                END IF;&#x000d;
&#x000d;
                IF xact_state() != - 1 THEN&#x000d;
                    var_AuditMessage := '[dbo].[sp_RunTransform]; error=''' || par_ErrMessage || '''';&#x000d;
                    CALL audit.sp_print(var_AuditMessage, 2, return_code => sp_print$ReturnCode);&#x000d;
                    CALL audit.sp_auditerror(par_LogID := var_LogID, par_ErrorMessage := par_ErrMessage);&#x000d;
                END IF;&#x000d;
                CALL audit.sp_auditfinish(par_LogID := var_LogID, par_RecordCount := var_RowCount, return_code => sp_auditfinish$ReturnCode);&#x000d;
                return_code := - 1;&#x000d;
                RETURN;&#x000d;
    END;&#x000d;
    /*&#x000d;
    &#x000d;
    DROP TABLE IF EXISTS t$auditproc;&#x000d;
    */&#x000d;
    /*&#x000d;
    &#x000d;
    Temporary table must be removed before end of the function.&#x000d;
    */&#x000d;
END;]]></complex-attribute>
                        <category _I_D="471397d3-741d-4ba7-9638-8fc110d943ae" name="Parameters" order-num="0" child-type="parameter" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Procedures,procedure sp_RunTransform,category Parameters">
                            <parameter _I_D="47678e03-1f23-4599-9fac-a97a0ef42381" name="par_errmessage" dt-name="VARCHAR" dt-attr-1="4000" transformed="2022-09-14 15:32:53" argument-order="1" argument-datatype="nvarchar" argument-mode="INOUT" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Procedures,procedure sp_RunTransform,category Parameters,parameter \@ErrMessage" source-vendor="MSSQL" argument-default="NULL"/>
                            <parameter _I_D="a69c7e82-247c-4d06-928e-312457496167" name="return_code" dt-name="int" transformed="2022-09-14 15:32:53" argument-order="2" argument-datatype="int" argument-mode="INOUT" argument-default="0"/>
                        </category>
                    </procedure>
                </category>
                <category _I_D="09adb7ea-a0a1-41b4-814a-0de9bf877923" name="Functions" order-num="5" child-type="function" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category SQL scalar functions"/>
                <category _I_D="71bf20a2-9fc5-4a6c-8f04-0076dc8c9b60" name="Sequences" order-num="10" child-type="sequence" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Sequences"/>
                <category _I_D="3669672f-efc7-4a4d-a090-9bc9f5ba4f04" name="Domains" order-num="11" child-type="domain" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Types"/>
                <category _I_D="82a9dce3-b267-4ac2-a5ca-ad8ecdc3fd3c" name="User defined types" order-num="12" child-type="table-type" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema dbo,category Table types"/>
            </schema>
            <schema _I_D="8eac4070-c4b0-44ab-95e9-5e553211614c" name="staging" is-empty="N" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging" source-vendor="MSSQL">
                <category _I_D="2c658674-8f5e-4f87-b1c8-62ae6ba95b95" name="Tables" order-num="0" child-type="table" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Tables">
                    <table _I_D="88f46ff3-d7d8-4b3c-adc0-2b63687b3c75" name="dimincome" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Tables,table DimIncome" source-vendor="MSSQL" partitioned="NO">
                        <category _I_D="54ed9bd0-129c-426d-8cbb-41a3474ab7e1" name="Columns" order-num="0" child-type="column" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Tables,table DimIncome,category Columns">
                            <column _I_D="116d5be7-951d-4760-8985-d0a87c4e5167" name="id" type-name="int" is-nullable="Y" is-xml-document="N" dt-name="INTEGER" transformed="2022-09-14 15:32:53" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Tables,table DimIncome,category Columns,column ID" source-vendor="MSSQL"/>
                            <column _I_D="c5cdf4fa-b7d0-4095-bde6-90221784b91f" name="dateid" type-name="int" is-nullable="Y" is-xml-document="N" dt-name="INTEGER" transformed="2022-09-14 15:32:53" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Tables,table DimIncome,category Columns,column DateID" source-vendor="MSSQL"/>
                            <column _I_D="15d0403d-3960-4a29-8bd5-1c38a949f35a" name="batchid" type-name="int" is-nullable="Y" is-xml-document="N" dt-name="INTEGER" transformed="2022-09-14 15:32:53" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Tables,table DimIncome,category Columns,column BatchID" source-vendor="MSSQL"/>
                            <column _I_D="d03ad58c-37e9-4e63-b7f2-dfabf773dc95" name="incomeusd" type-name="money" is-nullable="Y" is-xml-document="N" dt-name="NUMERIC" dt-attr-1="19" dt-attr-2="4" transformed="2022-09-14 15:32:53" character-maximum-length="8" numeric-precision="19" numeric-scale="4" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Tables,table DimIncome,category Columns,column IncomeUSD" source-vendor="MSSQL"/>
                            <column _I_D="8661bd75-7cf9-4274-9ca1-c6bfefd2397a" name="naturalkey" type-name="uniqueidentifier" is-nullable="Y" is-xml-document="N" dt-name="UUID" transformed="2022-09-14 15:32:53" character-maximum-length="16" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Tables,table DimIncome,category Columns,column NaturalKey" source-vendor="MSSQL"/>
                            <column _I_D="57cc6783-f04a-4763-835f-909c4e23d639" name="exchangedata" type-name="int" is-nullable="Y" is-xml-document="N" dt-name="INTEGER" transformed="2022-09-14 15:32:53" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Tables,table DimIncome,category Columns,column ExchangeData" source-vendor="MSSQL"/>
                            <column _I_D="69c0d827-921f-415f-92ec-c441c3ad0307" name="exchangevalue" type-name="money" is-nullable="Y" is-xml-document="N" dt-name="NUMERIC" dt-attr-1="19" dt-attr-2="4" transformed="2022-09-14 15:32:53" character-maximum-length="8" numeric-precision="19" numeric-scale="4" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Tables,table DimIncome,category Columns,column ExchangeValue" source-vendor="MSSQL"/>
                            <column _I_D="9deaf6c6-e873-4227-a6ac-d48d95f88c79" name="exchangerate" type-name="money" is-nullable="Y" is-xml-document="N" dt-name="NUMERIC" dt-attr-1="19" dt-attr-2="4" transformed="2022-09-14 15:32:53" character-maximum-length="8" numeric-precision="19" numeric-scale="4" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Tables,table DimIncome,category Columns,column ExchangeRate" source-vendor="MSSQL"/>
                            <column _I_D="cb3316b7-b250-453d-8293-824d85ba4ac6" name="createdate" type-name="datetime" is-nullable="Y" is-xml-document="N" dt-name="TIMESTAMP WITHOUT TIME ZONE" transformed="2022-09-14 15:32:53" character-maximum-length="8" numeric-precision="23" numeric-scale="3" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Tables,table DimIncome,category Columns,column CreateDate" source-vendor="MSSQL"/>
                            <column _I_D="73e8159e-dbb2-43c8-a781-aa23a752b836" name="changedate" type-name="datetime" is-nullable="Y" is-xml-document="N" dt-name="TIMESTAMP WITHOUT TIME ZONE" transformed="2022-09-14 15:32:53" character-maximum-length="8" numeric-precision="23" numeric-scale="3" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Tables,table DimIncome,category Columns,column ChangeDate" source-vendor="MSSQL"/>
                        </category>
                        <category _I_D="60eb55e8-46d1-41dc-8ab4-f89edc1103c1" name="Constraints" order-num="1" child-type="constraint" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Tables,table DimIncome,category Constraints"/>
                        <category _I_D="24829f24-9fae-41bc-9202-bb13cd8cbd15" name="Indexes" order-num="2" child-type="index" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Tables,table DimIncome,category Indexes"/>
                        <category _I_D="35760efb-d084-476d-aaa7-56206911ea35" name="Triggers" order-num="3" child-type="trigger" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Tables,table DimIncome,category Triggers"/>
                        <category _I_D="7c983479-be83-488d-b8a9-b9dd18643a5b" name="Partitions" order-num="4" child-type="partition" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Tables,table DimIncome,category Partitions"/>
                    </table>
                    <table _I_D="d8a90d9d-f6a6-4440-a272-efcb7bab78a1" name="factincomehistory" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Tables,table FactIncomeHistory" source-vendor="MSSQL" partitioned="NO">
                        <category _I_D="8aa9f099-1659-4b7a-9dba-2198127a6b9d" name="Columns" order-num="0" child-type="column" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Tables,table FactIncomeHistory,category Columns">
                            <column _I_D="5521ef89-9a4a-40bd-8819-466b516d6dcd" name="id" type-name="int" is-nullable="Y" is-xml-document="N" dt-name="INTEGER" transformed="2022-09-14 15:32:53" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Tables,table FactIncomeHistory,category Columns,column ID" source-vendor="MSSQL"/>
                            <column _I_D="d41ea63b-1777-400d-b449-1c6fce864f9f" name="dateid" type-name="int" is-nullable="Y" is-xml-document="N" dt-name="INTEGER" transformed="2022-09-14 15:32:53" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Tables,table FactIncomeHistory,category Columns,column DateID" source-vendor="MSSQL"/>
                            <column _I_D="1eb7f3d3-3993-4729-81bc-903cd5cbf95e" name="batchid" type-name="int" is-nullable="Y" is-xml-document="N" dt-name="INTEGER" transformed="2022-09-14 15:32:53" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Tables,table FactIncomeHistory,category Columns,column BatchID" source-vendor="MSSQL"/>
                            <column _I_D="ff6ed9bc-9091-4baf-a0c5-b95a39874f8e" name="incomeusd" type-name="money" is-nullable="Y" is-xml-document="N" dt-name="NUMERIC" dt-attr-1="19" dt-attr-2="4" transformed="2022-09-14 15:32:53" character-maximum-length="8" numeric-precision="19" numeric-scale="4" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Tables,table FactIncomeHistory,category Columns,column IncomeUSD" source-vendor="MSSQL"/>
                            <column _I_D="f7c513d6-bc46-46ac-8f5e-80ed706d256c" name="naturalkey" type-name="uniqueidentifier" is-nullable="Y" is-xml-document="N" dt-name="UUID" transformed="2022-09-14 15:32:53" character-maximum-length="16" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Tables,table FactIncomeHistory,category Columns,column NaturalKey" source-vendor="MSSQL"/>
                            <column _I_D="f012684b-d47a-4c8f-b0ab-1e5d33ed707f" name="versionkey" type-name="uniqueidentifier" is-nullable="Y" is-xml-document="N" dt-name="UUID" transformed="2022-09-14 15:32:53" character-maximum-length="16" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Tables,table FactIncomeHistory,category Columns,column VersionKey" source-vendor="MSSQL"/>
                            <column _I_D="45509216-6838-4ecd-a301-5e32acefd561" name="exchangedateid" type-name="int" is-nullable="Y" is-xml-document="N" dt-name="INTEGER" transformed="2022-09-14 15:32:53" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Tables,table FactIncomeHistory,category Columns,column ExchangeDateID" source-vendor="MSSQL"/>
                            <column _I_D="1137218d-05eb-4127-ba6a-f8bd93af7129" name="exchangevalue" type-name="money" is-nullable="Y" is-xml-document="N" dt-name="NUMERIC" dt-attr-1="19" dt-attr-2="4" transformed="2022-09-14 15:32:53" character-maximum-length="8" numeric-precision="19" numeric-scale="4" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Tables,table FactIncomeHistory,category Columns,column ExchangeValue" source-vendor="MSSQL"/>
                            <column _I_D="7f4d2038-f451-4033-8661-429dcfe429d5" name="exchangerate" type-name="money" is-nullable="Y" is-xml-document="N" dt-name="NUMERIC" dt-attr-1="19" dt-attr-2="4" transformed="2022-09-14 15:32:53" character-maximum-length="8" numeric-precision="19" numeric-scale="4" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Tables,table FactIncomeHistory,category Columns,column ExchangeRate" source-vendor="MSSQL"/>
                            <column _I_D="ea758564-1550-4b25-a04f-0f53b512481b" name="endbatchid" type-name="int" is-nullable="Y" is-xml-document="N" dt-name="INTEGER" transformed="2022-09-14 15:32:53" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Tables,table FactIncomeHistory,category Columns,column EndBatchID" source-vendor="MSSQL"/>
                        </category>
                        <category _I_D="5b92fb27-d4f3-4e1a-9fc0-dcc9229f45ef" name="Constraints" order-num="1" child-type="constraint" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Tables,table FactIncomeHistory,category Constraints"/>
                        <category _I_D="7e74c19b-3f3a-46f0-a9fe-7eb2cc3fd326" name="Indexes" order-num="2" child-type="index" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Tables,table FactIncomeHistory,category Indexes"/>
                        <category _I_D="ad336632-0f81-4682-84c7-7069ab5b0e1d" name="Triggers" order-num="3" child-type="trigger" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Tables,table FactIncomeHistory,category Triggers"/>
                        <category _I_D="a17808ff-f2e4-4ba8-8664-eaff93972dce" name="Partitions" order-num="4" child-type="partition" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Tables,table FactIncomeHistory,category Partitions"/>
                    </table>
                </category>
                <category _I_D="4c59a449-fcf4-4486-8a07-4eee4ca11361" name="Views" order-num="3" child-type="view" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Views"/>
                <category _I_D="f0bdded8-331c-4be8-9bac-bc83623a9378" name="Procedures" order-num="4" child-type="procedure" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Procedures"/>
                <category _I_D="2ebe8280-428f-41ea-a3c7-d469571afa05" name="Functions" order-num="5" child-type="function" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category SQL scalar functions"/>
                <category _I_D="6bb0a089-cba6-4858-a7b5-a34ae92cb4d2" name="Sequences" order-num="10" child-type="sequence" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Sequences"/>
                <category _I_D="2d5c58d2-2726-4cd3-a9cf-ed198355f355" name="Domains" order-num="11" child-type="domain" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Types"/>
                <category _I_D="018a35c1-300b-4497-ac1d-7b7abf1c55d5" name="User defined types" order-num="12" child-type="table-type" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema staging,category Table types"/>
            </schema>
            <schema _I_D="8e4c375e-df39-46ae-b2de-8ebec964a4f1" name="meta" is-empty="N" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema meta" source-vendor="MSSQL">
                <category _I_D="8796eb29-a771-452d-ac96-70be77f0d4cc" name="Tables" order-num="0" child-type="table" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema meta,category Tables">
                    <table _I_D="073cc60b-8720-42e7-b2c9-0868f421b279" name="configapp" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema meta,category Tables,table ConfigApp" source-vendor="MSSQL" partitioned="NO">
                        <category _I_D="aedabb22-7c90-429e-8135-6bf0a6b00d74" name="Columns" order-num="0" child-type="column" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema meta,category Tables,table ConfigApp,category Columns">
                            <column _I_D="8b00d6b2-ef33-4edc-ab80-3306f3f89281" name="parameter" type-name="nvarchar" is-nullable="N" is-xml-document="N" dt-name="VARCHAR" dt-attr-1="128" transformed="2022-09-14 15:32:53" character-maximum-length="256" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema meta,category Tables,table ConfigApp,category Columns,column Parameter" source-vendor="MSSQL"/>
                            <column _I_D="45a94af7-990b-4c01-8de4-cae512032e7d" name="strvalue" type-name="nvarchar" is-nullable="Y" is-xml-document="N" dt-name="VARCHAR" dt-attr-1="256" transformed="2022-09-14 15:32:53" character-maximum-length="512" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema meta,category Tables,table ConfigApp,category Columns,column StrValue" source-vendor="MSSQL"/>
                        </category>
                        <category _I_D="0324ac61-c9cb-4c4f-99dd-d2e1bf5f6234" name="Constraints" order-num="1" child-type="constraint" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema meta,category Tables,table ConfigApp,category Constraints">
                            <constraint _I_D="3a2d76c1-2521-49de-b307-5ff07eeb4d62" name="pk_audit_logprocedures_917578307" constraint-type-desc="PRIMARY KEY" transformed="2022-09-14 15:32:53" constraint-schema="meta" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema meta,category Tables,table ConfigApp,category Constraints,constraint PK_audit_LogProcedures" source-vendor="MSSQL" constraint-type="PRIMARY KEY">
                                <category _I_D="4ac1cdcc-b0bb-45b2-9ecc-541f316761bc" name="Columns" order-num="0" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema meta,category Tables,table ConfigApp,category Constraints,constraint PK_audit_LogProcedures,category Columns">
                                    <column _I_D="e4464bf1-73bc-4b5f-8236-f1e8e5d7872b" name="parameter" ordinal-position="1" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema meta,category Tables,table ConfigApp,category Constraints,constraint PK_audit_LogProcedures,category Columns,column Parameter" source-vendor="MSSQL" descasc="ASC"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="1c3aa98e-30b4-4d3d-b34b-68de0fe105fe" name="Indexes" order-num="2" child-type="index" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema meta,category Tables,table ConfigApp,category Indexes"/>
                        <category _I_D="20b15976-3914-4e34-807f-2e2515149d8d" name="Triggers" order-num="3" child-type="trigger" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema meta,category Tables,table ConfigApp,category Triggers"/>
                        <category _I_D="05b5263b-8416-4c98-8e0d-54302a88d793" name="Partitions" order-num="4" child-type="partition" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema meta,category Tables,table ConfigApp,category Partitions"/>
                    </table>
                </category>
                <category _I_D="581461af-8994-4b88-8899-4fa5b87d8a9e" name="Views" order-num="3" child-type="view" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema meta,category Views"/>
                <category _I_D="5c8f5dd1-13ee-4049-9713-c5fba8ec9385" name="Procedures" order-num="4" child-type="procedure" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema meta,category Procedures">
                    <procedure _I_D="e1b1bd1b-2b9d-4aa3-b0ba-2cec10e31bff" object-id="1077578877" schema-id="6" name="sp_initdatabase" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema meta,category Procedures,procedure sp_InitDataBase" source-vendor="MSSQL" count-all-parsable-nodes="89" count-error-parsable-nodes="0" proc-language="plpgsql">
                        <complex-attribute name="sql"><![CDATA[&#x000d;
/*&#x000d;
[meta].[sp_InitDataBase]&#x000d;
TRUNCATE TABLE [meta].[ConfigApp]&#x000d;
*/&#x000d;
BEGIN&#x000d;
    IF (NOT EXISTS (SELECT&#x000d;
        1&#x000d;
        FROM meta.configapp)) THEN&#x000d;
        INSERT INTO meta.configapp (parameter, strvalue)&#x000d;
        VALUES ('AuditProcAll', '1');&#x000d;
        INSERT INTO meta.configapp (parameter, strvalue)&#x000d;
        VALUES ('AuditPrintAll', '1');&#x000d;
        INSERT INTO meta.configapp (parameter, strvalue)&#x000d;
        SELECT&#x000d;
            'ExcelFileIncomeBookCmd', 'Select * from [Sheet1$]';&#x000d;
    END IF;&#x000d;
END;]]></complex-attribute>
                        <category _I_D="af75b9a9-03fc-498a-84e5-11cc647d52b1" name="Parameters" order-num="0" child-type="parameter" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema meta,category Procedures,procedure sp_InitDataBase,category Parameters">
                            <parameter _I_D="71310aa3-62de-47a4-ae07-2ecc460bd709" name="par_isdebugmode" dt-name="NUMERIC" dt-attr-1="1" dt-attr-2="0" transformed="2022-09-14 15:32:53" argument-order="1" argument-datatype="bit" argument-mode="IN" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema meta,category Procedures,procedure sp_InitDataBase,category Parameters,parameter \@IsDebugMode" source-vendor="MSSQL" argument-default="0"/>
                        </category>
                    </procedure>
                </category>
                <category _I_D="4ce604ac-8532-40d2-9e7b-ecd889bc07e2" name="Functions" order-num="5" child-type="function" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema meta,category SQL scalar functions">
                    <function _I_D="50853669-3670-4c12-9e48-e62ce07ea60d" name="ufn_convertdectostr" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema meta,category SQL scalar functions,scalar-function ufn_ConvertDecToStr" transformed="2022-09-14 15:32:53" function-id="1093578934" schema-id="6" source-vendor="MSSQL" function-type="RET_SCALAR" count-all-parsable-nodes="84" count-error-parsable-nodes="0">
                        <complex-attribute name="sql"><![CDATA[&#x000d;
/* SELECT meta.ufn_ConvertDecToStr(0.00000010000), '0.0000001' */&#x000d;
BEGIN&#x000d;
    RETURN&#x000d;
    CASE&#x000d;
        WHEN aws_sqlserver_ext.ROUND3(par_val, 0, 1) = par_val THEN LTRIM(to_char(par_val::DOUBLE PRECISION, '99999999999999999999'))&#x000d;
        ELSE LEFT(par_val, LENGTH(par_val) - aws_sqlserver_ext.patindex('%[^0]%', REVERSE(par_val)) + 1)&#x000d;
    END;&#x000d;
END;]]></complex-attribute>
                        <category _I_D="59d841b1-0485-4903-82eb-d22f655ac6f9" name="Parameters" order-num="0" child-type="parameter" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema meta,category SQL scalar functions,scalar-function ufn_ConvertDecToStr,category Parameters">
                            <parameter _I_D="36cced21-57d3-4a1e-afb8-0d4da0947ad2" name="(result)" dt-name="VARCHAR" dt-attr-1="50" transformed="2022-09-14 15:32:53" argument-order="0" argument-datatype="nvarchar" argument-mode="INOUT" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema meta,category SQL scalar functions,scalar-function ufn_ConvertDecToStr,category Parameters,parameter (result)" source-vendor="MSSQL"/>
                            <parameter _I_D="5f903de1-9158-4512-8c74-a9b2c61814c9" name="par_val" dt-name="NUMERIC" dt-attr-1="36" dt-attr-2="16" transformed="2022-09-14 15:32:53" argument-order="1" argument-datatype="decimal" argument-mode="IN" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema meta,category SQL scalar functions,scalar-function ufn_ConvertDecToStr,category Parameters,parameter \@val" source-vendor="MSSQL"/>
                        </category>
                    </function>
                    <function _I_D="826d8e26-bcd1-417a-9056-b2858bd233bb" name="ufn_getconfigvalue" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema meta,category SQL scalar functions,scalar-function ufn_GetConfigValue" transformed="2022-09-14 15:32:53" function-id="1109578991" schema-id="6" source-vendor="MSSQL" function-type="RET_SCALAR" count-all-parsable-nodes="45" count-error-parsable-nodes="0">
                        <complex-attribute name="sql"><![CDATA[&#x000d;
/*&#x000d;
SELECT * FROM sys.sql_modules WHERE object_id  in (&#x000d;
SELECT object_id  FROM sys.objects WHERE name= 'ufn_GetConfigValue'&#x000d;
)&#x000d;
*/&#x000d;
DECLARE&#x000d;
    var_Value VARCHAR(256);&#x000d;
BEGIN&#x000d;
    var_Value := (SELECT&#x000d;
        strvalue&#x000d;
        FROM meta.configapp&#x000d;
        WHERE LOWER(parameter) = LOWER(par_Parameter));&#x000d;
    RETURN var_Value;&#x000d;
END;]]></complex-attribute>
                        <category _I_D="4ccafedd-c313-4369-95f4-025960e87702" name="Parameters" order-num="0" child-type="parameter" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema meta,category SQL scalar functions,scalar-function ufn_GetConfigValue,category Parameters">
                            <parameter _I_D="a7cab896-cde6-476f-83e4-454d1316926e" name="(result)" dt-name="VARCHAR" dt-attr-1="256" transformed="2022-09-14 15:32:53" argument-order="0" argument-datatype="nvarchar" argument-mode="INOUT" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema meta,category SQL scalar functions,scalar-function ufn_GetConfigValue,category Parameters,parameter (result)" source-vendor="MSSQL"/>
                            <parameter _I_D="7a846322-e19a-431e-b3ab-eb745fd49f63" name="par_parameter" dt-name="VARCHAR" dt-attr-1="256" transformed="2022-09-14 15:32:53" argument-order="1" argument-datatype="nvarchar" argument-mode="IN" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema meta,category SQL scalar functions,scalar-function ufn_GetConfigValue,category Parameters,parameter \@Parameter" source-vendor="MSSQL"/>
                        </category>
                    </function>
                    <function _I_D="04468b0e-ac94-4430-a1ad-eb318e9563eb" name="ufn_getlastdate" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema meta,category SQL scalar functions,scalar-function ufn_GetLastDate" transformed="2022-09-14 15:32:53" function-id="1125579048" schema-id="6" source-vendor="MSSQL" function-type="RET_SCALAR" count-all-parsable-nodes="18" count-error-parsable-nodes="0">
                        <complex-attribute name="sql"><![CDATA[&#x000d;
/* SELECT [meta].[ufn_GetLastDate]() */&#x000d;
BEGIN&#x000d;
    RETURN make_date(2100, 12, 31);&#x000d;
END;]]></complex-attribute>
                        <category _I_D="a76fe17e-9620-4acb-87ac-ed480e7b68b9" name="Parameters" order-num="0" child-type="parameter" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema meta,category SQL scalar functions,scalar-function ufn_GetLastDate,category Parameters">
                            <parameter _I_D="1d5c8dbd-6af4-4c74-a1f6-eec6225950c9" name="(result)" dt-name="TIMESTAMP WITHOUT TIME ZONE" transformed="2022-09-14 15:32:53" argument-order="0" argument-datatype="datetime" argument-mode="INOUT" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema meta,category SQL scalar functions,scalar-function ufn_GetLastDate,category Parameters,parameter (result)" source-vendor="MSSQL"/>
                        </category>
                    </function>
                </category>
                <category _I_D="29dd15c7-eae8-450c-8f9c-6602d94efe51" name="Sequences" order-num="10" child-type="sequence" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema meta,category Sequences"/>
                <category _I_D="be3336c7-8357-4c79-9388-51fa2c2efd6b" name="Domains" order-num="11" child-type="domain" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema meta,category Types"/>
                <category _I_D="08c9faf5-01a9-4b42-b970-2addb2a0b889" name="User defined types" order-num="12" child-type="table-type" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema meta,category Table types"/>
            </schema>
            <schema _I_D="7d2dea55-10b6-4ee1-bf42-1b40c15559ed" name="uts" is-empty="N" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema uts" source-vendor="MSSQL">
                <category _I_D="653504d5-16e0-4c49-b7b5-b61d74cd9cea" name="Tables" order-num="0" child-type="table" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema uts,category Tables">
                    <table _I_D="b02c09dc-f5bb-494b-8647-b02d9fa64315" name="resultunittest" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema uts,category Tables,table ResultUnitTest" source-vendor="MSSQL" partitioned="NO">
                        <category _I_D="4b5a7392-b222-4a0d-9f0b-33551c56e4db" name="Columns" order-num="0" child-type="column" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema uts,category Tables,table ResultUnitTest,category Columns">
                            <column _I_D="e29fcdc1-8285-4ec0-a048-e6c144f96083" name="testname" type-name="nvarchar" is-nullable="Y" is-xml-document="N" dt-name="VARCHAR" dt-attr-1="200" transformed="2022-09-14 15:32:53" character-maximum-length="400" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema uts,category Tables,table ResultUnitTest,category Columns,column TestName" source-vendor="MSSQL"/>
                            <column _I_D="5b3332d9-0728-45b4-ac18-95ed540fc527" name="stepid" type-name="int" is-nullable="Y" is-xml-document="N" dt-name="INTEGER" transformed="2022-09-14 15:32:53" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema uts,category Tables,table ResultUnitTest,category Columns,column StepID" source-vendor="MSSQL"/>
                            <column _I_D="57d42469-1dfb-4ba9-832b-75ed3a44bada" name="error" type-name="nvarchar" is-nullable="Y" is-xml-document="N" dt-name="TEXT" transformed="2022-09-14 15:32:53" character-maximum-length="-1" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema uts,category Tables,table ResultUnitTest,category Columns,column Error" source-vendor="MSSQL"/>
                            <column _I_D="d5aa034f-43af-44e1-8cde-170ff72e645d" name="datestamp" type-name="datetime" is-nullable="Y" is-xml-document="N" dt-name="TIMESTAMP WITHOUT TIME ZONE" default-definition="clock_timestamp()" transformed="2022-09-14 15:32:53" character-maximum-length="8" numeric-precision="23" numeric-scale="3" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema uts,category Tables,table ResultUnitTest,category Columns,column datestamp" source-vendor="MSSQL"/>
                        </category>
                        <category _I_D="2758157a-6446-4e7d-9e11-6114edbfedf3" name="Constraints" order-num="1" child-type="constraint" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema uts,category Tables,table ResultUnitTest,category Constraints"/>
                        <category _I_D="cf2487fd-0127-4d60-b16c-3b03889f1e76" name="Indexes" order-num="2" child-type="index" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema uts,category Tables,table ResultUnitTest,category Indexes"/>
                        <category _I_D="1ef94dcd-d24e-4764-ab5a-33d4b6307fc4" name="Triggers" order-num="3" child-type="trigger" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema uts,category Tables,table ResultUnitTest,category Triggers"/>
                        <category _I_D="f137aacd-a419-4a2e-a401-327c13347a9e" name="Partitions" order-num="4" child-type="partition" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema uts,category Tables,table ResultUnitTest,category Partitions"/>
                    </table>
                </category>
                <category _I_D="05e253af-adcf-4147-ae34-6fd3213e1c8f" name="Views" order-num="3" child-type="view" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema uts,category Views"/>
                <category _I_D="98f7656d-1866-4899-87b9-53858592ff04" name="Procedures" order-num="4" child-type="procedure" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema uts,category Procedures">
                    <procedure _I_D="baef8000-342b-4ebc-8273-515070bc2d06" object-id="1221579390" schema-id="7" name="usp_unittest" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema uts,category Procedures,procedure usp_UnitTest" source-vendor="MSSQL" count-all-parsable-nodes="1050" count-error-parsable-nodes="16" proc-language="plpgsql">
                        <complex-attribute name="sql"><![CDATA[&#x000d;
/* EXEC [uts].[usp_UnitTest] @TestsList='2' */&#x000d;
/* SELECT * FROM uts.ResultUnitTest */&#x000d;
/* Debug */&#x000d;
DECLARE&#x000d;
    var_TotalTestCount INTEGER;&#x000d;
    var_TestName VARCHAR(100);&#x000d;
    var_sql TEXT;&#x000d;
    var_TableNameOut VARCHAR(255);&#x000d;
    var_Error VARCHAR(500);&#x000d;
    var_TestID INTEGER;&#x000d;
    var_res INTEGER;&#x000d;
    var_ErrMessage TEXT;&#x000d;
    cur CURSOR FOR&#x000d;
    SELECT&#x000d;
        testid&#x000d;
        FROM t$test&#x000d;
        ORDER BY testid ASC NULLS FIRST;&#x000d;
    var_ErrorMessage VARCHAR(4000);&#x000d;
    var_ErrorNumber INTEGER;&#x000d;
    var_ErrorSeverity INTEGER;&#x000d;
    var_ErrorState INTEGER;&#x000d;
    var_ErrorLine INTEGER;&#x000d;
    var_ErrorProcedure VARCHAR(200);&#x000d;
BEGIN&#x000d;
    var_TotalTestCount := 3;&#x000d;
    par_TestsList := COALESCE(RTRIM(LTRIM(par_TestsList)), '');&#x000d;
&#x000d;
    IF EXISTS (SELECT&#x000d;
        *&#x000d;
        FROM aws_sqlserver_ext.SYS_OBJECTS&#x000d;
        WHERE object_id = aws_sqlserver_ext.object_id('tempdb.dbo.#Test') AND LOWER(type) IN (LOWER('U'))) THEN&#x000d;
        DROP TABLE ieaccountinginusd_dbo.t$Test;&#x000d;
    END IF;&#x000d;
    CREATE TEMPORARY TABLE t$test&#x000d;
    AS&#x000d;
    SELECT&#x000d;
        CAST (LTRIM(RTRIM(value)) AS INTEGER) AS testid&#x000d;
        FROM string_split(par_TestsList, ',')&#x000d;
        WHERE aws_sqlserver_ext.isnumeric(LTRIM(RTRIM(value))) = 1;&#x000d;
&#x000d;
    WHILE var_TotalTestCount > 0 AND LOWER(par_TestsList) = LOWER('') LOOP&#x000d;
        INSERT INTO t$test (testid)&#x000d;
        VALUES (var_TotalTestCount);&#x000d;
        var_TotalTestCount := (var_TotalTestCount - 1)::INT;&#x000d;
    END LOOP;&#x000d;
&#x000d;
    IF EXISTS (SELECT&#x000d;
        *&#x000d;
        FROM aws_sqlserver_ext.SYS_OBJECTS AS o&#x000d;
        INNER JOIN aws_sqlserver_ext.SYS_SCHEMAS AS s&#x000d;
            ON o.schema_id = s.schema_id&#x000d;
        WHERE o.name = 'ResultUnitTest' AND LOWER(o.type) = LOWER('U') AND s.name = 'uts') THEN&#x000d;
        DROP TABLE uts.resultunittest;&#x000d;
    END IF;&#x000d;
    CREATE TABLE uts.resultunittest&#x000d;
    (testname VARCHAR(200),&#x000d;
        stepid INTEGER,&#x000d;
        error TEXT,&#x000d;
        datestamp TIMESTAMP WITHOUT TIME ZONE DEFAULT (clock_timestamp()));&#x000d;
    INSERT INTO uts.resultunittest (testname, error)&#x000d;
    SELECT&#x000d;
        '   EXEC uts.usp_UnitTest @TestsList = ''' || COALESCE(par_TestsList, '') || '''' AS testname, '' AS error;&#x000d;
    OPEN cur;&#x000d;
    FETCH NEXT FROM cur INTO var_TestID;&#x000d;
&#x000d;
    WHILE (CASE FOUND::INT&#x000d;
        WHEN 0 THEN - 1&#x000d;
        ELSE 0&#x000d;
    END) = 0 LOOP&#x000d;
        DECLARE&#x000d;
            error_catch$ERROR_NUMBER TEXT;&#x000d;
            error_catch$ERROR_SEVERITY TEXT;&#x000d;
            error_catch$ERROR_STATE TEXT;&#x000d;
            error_catch$ERROR_LINE TEXT;&#x000d;
            error_catch$ERROR_PROCEDURE TEXT;&#x000d;
            error_catch$ERROR_MESSAGE TEXT;&#x000d;
        BEGIN&#x000d;
            IF var_TestID = 1 THEN&#x000d;
                SELECT&#x000d;
                    '1. Fill Dim Date'&#x000d;
                    INTO var_TestName;&#x000d;
                CALL dbo.sp_filldimdate(par_FromDate := '20190101', par_ToDate := '20221231', par_Culture := 'ru-ru', par_IsOutput := 0);&#x000d;
&#x000d;
                IF NOT EXISTS (SELECT&#x000d;
                    *&#x000d;
                    FROM uts.resultunittest&#x000d;
                    WHERE LOWER(testname) = LOWER(var_TestName)) THEN&#x000d;
                    INSERT INTO uts.resultunittest (testname, error)&#x000d;
                    VALUES (var_TestName, '');&#x000d;
                END IF;&#x000d;
            END IF;&#x000d;
&#x000d;
            IF var_TestID = 2 THEN&#x000d;
                SELECT&#x000d;
                    '2. Upload IncomeBook.xlsx into DWH'&#x000d;
                    INTO var_TestName;&#x000d;
                CALL dbo.sp_runbatch(par_ErrMessage => var_ErrMessage, return_code => var_res);&#x000d;
                var_sql := '&#x000d;
		INSERT uts.ResultUnitTest( TestName, StepID, Error)&#x000d;
		SELECT TestName = ''' || var_TestName || ''', StepID = 1, Error =  ' || COALESCE(var_ErrMessage, '') || '&#x000d;
		';&#x000d;
&#x000d;
                IF var_res != 0 THEN&#x000d;
                    /*&#x000d;
                    [7672 - Severity CRITICAL - PostgreSQL doesn't support EXECUTE statements that run a character string. Convert your source code manually.]&#x000d;
                    EXEC( @sql)&#x000d;
                    */&#x000d;
                    BEGIN&#x000d;
                    END;&#x000d;
                END IF;&#x000d;
                CALL dbo.sp_runtransform(par_ErrMessage => var_ErrMessage, return_code => var_res);&#x000d;
                var_sql := '&#x000d;
		INSERT uts.ResultUnitTest( TestName, StepID, Error)&#x000d;
		SELECT TestName = ''' || var_TestName || ''', StepID = 2, Error =  ' || COALESCE(var_ErrMessage, '') || '&#x000d;
		';&#x000d;
&#x000d;
                IF var_res != 0 THEN&#x000d;
                    /*&#x000d;
                    [7672 - Severity CRITICAL - PostgreSQL doesn't support EXECUTE statements that run a character string. Convert your source code manually.]&#x000d;
                    EXEC( @sql)&#x000d;
                    */&#x000d;
                    BEGIN&#x000d;
                    END;&#x000d;
                END IF;&#x000d;
                CALL dbo.sp_fillfactincome(par_ErrMessage => var_ErrMessage, return_code => var_res);&#x000d;
                var_sql := '&#x000d;
		INSERT uts.ResultUnitTest( TestName, StepID, Error)&#x000d;
		SELECT TestName = ''' || var_TestName || ''', StepID = 3, Error =  ' || COALESCE(var_ErrMessage, '') || '&#x000d;
		';&#x000d;
&#x000d;
                IF var_res != 0 THEN&#x000d;
                    /*&#x000d;
                    [7672 - Severity CRITICAL - PostgreSQL doesn't support EXECUTE statements that run a character string. Convert your source code manually.]&#x000d;
                    EXEC( @sql)&#x000d;
                    */&#x000d;
                    BEGIN&#x000d;
                    END;&#x000d;
                END IF;&#x000d;
&#x000d;
                IF NOT EXISTS (SELECT&#x000d;
                    *&#x000d;
                    FROM uts.resultunittest&#x000d;
                    WHERE LOWER(testname) = LOWER(var_TestName)) THEN&#x000d;
                    INSERT INTO uts.resultunittest (testname, error)&#x000d;
                    VALUES (var_TestName, '');&#x000d;
                END IF;&#x000d;
            END IF;&#x000d;
            /* --------------------------------------- */&#x000d;
            EXCEPTION&#x000d;
                WHEN OTHERS THEN&#x000d;
                    error_catch$ERROR_NUMBER := '0';&#x000d;
                    error_catch$ERROR_SEVERITY := '0';&#x000d;
                    error_catch$ERROR_LINE := '0';&#x000d;
                    error_catch$ERROR_PROCEDURE := 'USP_UNITTEST';&#x000d;
                    GET STACKED DIAGNOSTICS error_catch$ERROR_STATE = RETURNED_SQLSTATE,&#x000d;
                        error_catch$ERROR_MESSAGE = MESSAGE_TEXT;&#x000d;
&#x000d;
                    IF xact_state() <> 0 THEN&#x000d;
                        /*&#x000d;
                        [7807 - Severity CRITICAL - PostgreSQL does not support explicit transaction management commands such as BEGIN TRAN, SAVE TRAN in functions. Convert your source code manually.]&#x000d;
                        ROLLBACK TRANSACTION&#x000d;
                        */&#x000d;
                        BEGIN&#x000d;
                        END;&#x000d;
                    END IF;&#x000d;
                    SELECT&#x000d;
                        error_catch$ERROR_NUMBER, error_catch$ERROR_SEVERITY, error_catch$ERROR_STATE, error_catch$ERROR_LINE, COALESCE(error_catch$ERROR_PROCEDURE, '-')&#x000d;
                        INTO var_ErrorNumber, var_ErrorSeverity, var_ErrorState, var_ErrorLine, var_ErrorProcedure;&#x000d;
                    var_ErrorMessage := 'Error ' || LTRIM(to_char(var_ErrorNumber::DOUBLE PRECISION, '9999999999')) || ', Level ' || LTRIM(to_char(var_ErrorSeverity::DOUBLE PRECISION, '9999999999')) || ', State ' || LTRIM(to_char(var_ErrorState::DOUBLE PRECISION, '9999999999')) || ', Procedure ' || var_ErrorProcedure || ', Line ' || LTRIM(to_char(var_ErrorLine::DOUBLE PRECISION, '9999999999')) || ', ' || 'Message: ' || error_catch$ERROR_MESSAGE;&#x000d;
                    INSERT INTO uts.resultunittest (testname, error)&#x000d;
                    VALUES ('[' + current_schema || '].[' + 'usp_unittest' || '].' || COALESCE(var_TestName, 'NULL'), var_ErrorMessage);&#x000d;
                    /*&#x000d;
                    &#x000d;
                    DROP TABLE IF EXISTS t$test;&#x000d;
                    */&#x000d;
                    /*&#x000d;
                    &#x000d;
                    Temporary table must be removed before end of the function.&#x000d;
                    */&#x000d;
        END;&#x000d;
        FETCH NEXT FROM cur INTO var_TestID;&#x000d;
        /* --------------------------------------- */&#x000d;
    END LOOP;&#x000d;
    CLOSE cur;&#x000d;
    OPEN p_refcur FOR&#x000d;
    SELECT&#x000d;
        *&#x000d;
        FROM uts.resultunittest;&#x000d;
END;]]></complex-attribute>
                        <category _I_D="6689930c-2b51-4010-9a04-1949b7a6b4fd" name="Parameters" order-num="0" child-type="parameter" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema uts,category Procedures,procedure usp_UnitTest,category Parameters">
                            <parameter _I_D="a6346198-09de-4f0e-b3c4-2bb78330c63f" name="par_withoutput" dt-name="NUMERIC" dt-attr-1="1" dt-attr-2="0" transformed="2022-09-14 15:32:53" argument-order="1" argument-datatype="bit" argument-mode="IN" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema uts,category Procedures,procedure usp_UnitTest,category Parameters,parameter \@WithOutput" source-vendor="MSSQL" argument-default="1"/>
                            <parameter _I_D="f3a239b4-257e-4f62-b96d-4265f6d5fb4a" name="par_withcleanup" dt-name="INTEGER" transformed="2022-09-14 15:32:53" argument-order="2" argument-datatype="int" argument-mode="IN" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema uts,category Procedures,procedure usp_UnitTest,category Parameters,parameter \@WithCleanup" source-vendor="MSSQL" argument-default="1"/>
                            <parameter _I_D="9b75713a-ceb3-49c6-a495-9210d04966ac" name="par_testslist" dt-name="VARCHAR" dt-attr-1="4000" transformed="2022-09-14 15:32:53" argument-order="3" argument-datatype="nvarchar" argument-mode="IN" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema uts,category Procedures,procedure usp_UnitTest,category Parameters,parameter \@TestsList" source-vendor="MSSQL" argument-default="''"/>
                            <parameter _I_D="1136803a-356e-48f2-bbfa-21d859c6ba12" name="p_refcur" dt-name="refcursor" transformed="2022-09-14 15:32:53" argument-order="4" argument-datatype="refcursor" argument-mode="INOUT" argument-default="NULL"/>
                        </category>
                    </procedure>
                    <procedure _I_D="f71b9aa7-18af-4a68-a04c-a56bca7ce470" object-id="1221579390" schema-id="7" name="usp_unittest$tmp" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema uts,category Procedures,procedure usp_UnitTest" source-vendor="MSSQL" count-all-parsable-nodes="1050" count-error-parsable-nodes="16">
                        <complex-attribute name="sql"><![CDATA[var_TotalTestCount := 3;&#x000d;
par_TestsList := COALESCE(RTRIM(LTRIM(par_TestsList)), '');&#x000d;
&#x000d;
IF EXISTS (SELECT&#x000d;
    *&#x000d;
    FROM aws_sqlserver_ext.SYS_OBJECTS&#x000d;
    WHERE object_id = aws_sqlserver_ext.object_id('tempdb.dbo.#Test') AND LOWER(type) IN (LOWER('U'))) THEN&#x000d;
    DROP TABLE ieaccountinginusd_dbo.t$Test;&#x000d;
END IF;&#x000d;
CREATE TEMPORARY TABLE t$test&#x000d;
AS&#x000d;
SELECT&#x000d;
    CAST (LTRIM(RTRIM(value)) AS INTEGER) AS testid&#x000d;
    FROM string_split(par_TestsList, ',')&#x000d;
    WHERE aws_sqlserver_ext.isnumeric(LTRIM(RTRIM(value))) = 1;&#x000d;
&#x000d;
WHILE var_TotalTestCount > 0 AND LOWER(par_TestsList) = LOWER('') LOOP&#x000d;
    INSERT INTO t$test (testid)&#x000d;
    VALUES (var_TotalTestCount);&#x000d;
    var_TotalTestCount := (var_TotalTestCount - 1)::INT;&#x000d;
END LOOP;&#x000d;
&#x000d;
IF EXISTS (SELECT&#x000d;
    *&#x000d;
    FROM aws_sqlserver_ext.SYS_OBJECTS AS o&#x000d;
    INNER JOIN aws_sqlserver_ext.SYS_SCHEMAS AS s&#x000d;
        ON o.schema_id = s.schema_id&#x000d;
    WHERE o.name = 'ResultUnitTest' AND LOWER(o.type) = LOWER('U') AND s.name = 'uts') THEN&#x000d;
    DROP TABLE uts.resultunittest;&#x000d;
END IF;&#x000d;
CREATE TABLE uts.resultunittest&#x000d;
(testname VARCHAR(200),&#x000d;
    stepid INTEGER,&#x000d;
    error TEXT,&#x000d;
    datestamp TIMESTAMP WITHOUT TIME ZONE DEFAULT (clock_timestamp()));&#x000d;
INSERT INTO uts.resultunittest (testname, error)&#x000d;
SELECT&#x000d;
    '   EXEC uts.usp_UnitTest @TestsList = ''' || COALESCE(par_TestsList, '') || '''' AS testname, '' AS error;&#x000d;
OPEN cur;&#x000d;
FETCH NEXT FROM cur INTO var_TestID;&#x000d;
&#x000d;
WHILE (CASE FOUND::INT&#x000d;
    WHEN 0 THEN - 1&#x000d;
    ELSE 0&#x000d;
END) = 0 LOOP&#x000d;
    DECLARE&#x000d;
        error_catch$ERROR_NUMBER TEXT;&#x000d;
        error_catch$ERROR_SEVERITY TEXT;&#x000d;
        error_catch$ERROR_STATE TEXT;&#x000d;
        error_catch$ERROR_LINE TEXT;&#x000d;
        error_catch$ERROR_PROCEDURE TEXT;&#x000d;
        error_catch$ERROR_MESSAGE TEXT;&#x000d;
    BEGIN&#x000d;
        IF var_TestID = 1 THEN&#x000d;
            SELECT&#x000d;
                '1. Fill Dim Date'&#x000d;
                INTO var_TestName;&#x000d;
            CALL dbo.sp_filldimdate(par_FromDate := '20190101', par_ToDate := '20221231', par_Culture := 'ru-ru', par_IsOutput := 0);&#x000d;
&#x000d;
            IF NOT EXISTS (SELECT&#x000d;
                *&#x000d;
                FROM uts.resultunittest&#x000d;
                WHERE LOWER(testname) = LOWER(var_TestName)) THEN&#x000d;
                INSERT INTO uts.resultunittest (testname, error)&#x000d;
                VALUES (var_TestName, '');&#x000d;
            END IF;&#x000d;
        END IF;&#x000d;
&#x000d;
        IF var_TestID = 2 THEN&#x000d;
            SELECT&#x000d;
                '2. Upload IncomeBook.xlsx into DWH'&#x000d;
                INTO var_TestName;&#x000d;
            CALL dbo.sp_runbatch(par_ErrMessage => var_ErrMessage, return_code => var_res);&#x000d;
            var_sql := '&#x000d;
		INSERT uts.ResultUnitTest( TestName, StepID, Error)&#x000d;
		SELECT TestName = ''' || var_TestName || ''', StepID = 1, Error =  ' || COALESCE(var_ErrMessage, '') || '&#x000d;
		';&#x000d;
&#x000d;
            IF var_res != 0 THEN&#x000d;
                /*&#x000d;
                [7672 - Severity CRITICAL - PostgreSQL doesn't support EXECUTE statements that run a character string. Convert your source code manually.]&#x000d;
                EXEC( @sql)&#x000d;
                */&#x000d;
                BEGIN&#x000d;
                END;&#x000d;
            END IF;&#x000d;
            CALL dbo.sp_runtransform(par_ErrMessage => var_ErrMessage, return_code => var_res);&#x000d;
            var_sql := '&#x000d;
		INSERT uts.ResultUnitTest( TestName, StepID, Error)&#x000d;
		SELECT TestName = ''' || var_TestName || ''', StepID = 2, Error =  ' || COALESCE(var_ErrMessage, '') || '&#x000d;
		';&#x000d;
&#x000d;
            IF var_res != 0 THEN&#x000d;
                /*&#x000d;
                [7672 - Severity CRITICAL - PostgreSQL doesn't support EXECUTE statements that run a character string. Convert your source code manually.]&#x000d;
                EXEC( @sql)&#x000d;
                */&#x000d;
                BEGIN&#x000d;
                END;&#x000d;
            END IF;&#x000d;
            CALL dbo.sp_fillfactincome(par_ErrMessage => var_ErrMessage, return_code => var_res);&#x000d;
            var_sql := '&#x000d;
		INSERT uts.ResultUnitTest( TestName, StepID, Error)&#x000d;
		SELECT TestName = ''' || var_TestName || ''', StepID = 3, Error =  ' || COALESCE(var_ErrMessage, '') || '&#x000d;
		';&#x000d;
&#x000d;
            IF var_res != 0 THEN&#x000d;
                /*&#x000d;
                [7672 - Severity CRITICAL - PostgreSQL doesn't support EXECUTE statements that run a character string. Convert your source code manually.]&#x000d;
                EXEC( @sql)&#x000d;
                */&#x000d;
                BEGIN&#x000d;
                END;&#x000d;
            END IF;&#x000d;
&#x000d;
            IF NOT EXISTS (SELECT&#x000d;
                *&#x000d;
                FROM uts.resultunittest&#x000d;
                WHERE LOWER(testname) = LOWER(var_TestName)) THEN&#x000d;
                INSERT INTO uts.resultunittest (testname, error)&#x000d;
                VALUES (var_TestName, '');&#x000d;
            END IF;&#x000d;
        END IF;&#x000d;
        /* --------------------------------------- */&#x000d;
        EXCEPTION&#x000d;
            WHEN OTHERS THEN&#x000d;
                error_catch$ERROR_NUMBER := '0';&#x000d;
                error_catch$ERROR_SEVERITY := '0';&#x000d;
                error_catch$ERROR_LINE := '0';&#x000d;
                error_catch$ERROR_PROCEDURE := 'USP_UNITTEST';&#x000d;
                GET STACKED DIAGNOSTICS error_catch$ERROR_STATE = RETURNED_SQLSTATE,&#x000d;
                    error_catch$ERROR_MESSAGE = MESSAGE_TEXT;&#x000d;
&#x000d;
                IF xact_state() <> 0 THEN&#x000d;
                    /*&#x000d;
                    [7807 - Severity CRITICAL - PostgreSQL does not support explicit transaction management commands such as BEGIN TRAN, SAVE TRAN in functions. Convert your source code manually.]&#x000d;
                    ROLLBACK TRANSACTION&#x000d;
                    */&#x000d;
                    BEGIN&#x000d;
                    END;&#x000d;
                END IF;&#x000d;
                SELECT&#x000d;
                    error_catch$ERROR_NUMBER, error_catch$ERROR_SEVERITY, error_catch$ERROR_STATE, error_catch$ERROR_LINE, COALESCE(error_catch$ERROR_PROCEDURE, '-')&#x000d;
                    INTO var_ErrorNumber, var_ErrorSeverity, var_ErrorState, var_ErrorLine, var_ErrorProcedure;&#x000d;
                var_ErrorMessage := 'Error ' || LTRIM(to_char(var_ErrorNumber::DOUBLE PRECISION, '9999999999')) || ', Level ' || LTRIM(to_char(var_ErrorSeverity::DOUBLE PRECISION, '9999999999')) || ', State ' || LTRIM(to_char(var_ErrorState::DOUBLE PRECISION, '9999999999')) || ', Procedure ' || var_ErrorProcedure || ', Line ' || LTRIM(to_char(var_ErrorLine::DOUBLE PRECISION, '9999999999')) || ', ' || 'Message: ' || error_catch$ERROR_MESSAGE;&#x000d;
                INSERT INTO uts.resultunittest (testname, error)&#x000d;
                VALUES ('[' + current_schema || '].[' + 'usp_unittest' || '].' || COALESCE(var_TestName, 'NULL'), var_ErrorMessage);&#x000d;
                /*&#x000d;
                &#x000d;
                DROP TABLE IF EXISTS t$test;&#x000d;
                */&#x000d;
                /*&#x000d;
                &#x000d;
                Temporary table must be removed before end of the function.&#x000d;
                */&#x000d;
    END;&#x000d;
    FETCH NEXT FROM cur INTO var_TestID;&#x000d;
    /* --------------------------------------- */&#x000d;
END LOOP;&#x000d;
CLOSE cur;&#x000d;
DROP TABLE IF EXISTS usp_UnitTest$TMPTBL;&#x000d;
CREATE TEMP TABLE usp_UnitTest$TMPTBL&#x000d;
AS&#x000d;
SELECT&#x000d;
    *&#x000d;
    FROM uts.resultunittest;]]></complex-attribute>
                        <category _I_D="e1ea7aef-ee72-4e3d-9c04-52e14b355bb5" name="Parameters" order-num="0" child-type="parameter" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema uts,category Procedures,procedure usp_UnitTest,category Parameters">
                            <parameter _I_D="b014ebe2-aca2-481a-827d-13328ca7264e" name="par_withoutput" dt-name="NUMERIC" dt-attr-1="1" dt-attr-2="0" transformed="2022-09-14 15:32:53" argument-order="1" argument-datatype="bit" argument-mode="IN" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema uts,category Procedures,procedure usp_UnitTest,category Parameters,parameter \@WithOutput" source-vendor="MSSQL" argument-default="1"/>
                            <parameter _I_D="c3c0a1f5-ef7d-457e-b179-eb016b2af412" name="par_withcleanup" dt-name="INTEGER" transformed="2022-09-14 15:32:53" argument-order="2" argument-datatype="int" argument-mode="IN" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema uts,category Procedures,procedure usp_UnitTest,category Parameters,parameter \@WithCleanup" source-vendor="MSSQL" argument-default="1"/>
                            <parameter _I_D="b7b06f1f-2bb7-4af5-9326-877e3c457880" name="par_testslist" dt-name="VARCHAR" dt-attr-1="4000" transformed="2022-09-14 15:32:53" argument-order="3" argument-datatype="nvarchar" argument-mode="IN" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema uts,category Procedures,procedure usp_UnitTest,category Parameters,parameter \@TestsList" source-vendor="MSSQL" argument-default="''"/>
                        </category>
                    </procedure>
                </category>
                <category _I_D="025a3664-f3f0-4d4a-9a84-be1d0c160118" name="Functions" order-num="5" child-type="function" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema uts,category SQL scalar functions"/>
                <category _I_D="233fbc7b-404a-431f-a22d-455e54a021d1" name="Sequences" order-num="10" child-type="sequence" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema uts,category Sequences"/>
                <category _I_D="35c38026-16cb-4789-b441-f39c00968d73" name="Domains" order-num="11" child-type="domain" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema uts,category Types"/>
                <category _I_D="2b77115c-2cbd-4370-82a6-fde608ffe026" name="User defined types" order-num="12" child-type="table-type" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema uts,category Table types"/>
            </schema>
            <schema _I_D="57c09d91-74bd-43cb-b4a4-df7a7204cbf3" name="audit" is-empty="N" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit" source-vendor="MSSQL">
                <category _I_D="0dd48e95-35a8-4f84-a733-dff783c1fa2e" name="Tables" order-num="0" child-type="table" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Tables">
                    <table _I_D="804ad543-188a-452e-9175-79a2c93872c8" name="logprocedures" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Tables,table LogProcedures" source-vendor="MSSQL" partitioned="NO">
                        <category _I_D="9b3e3900-998b-4f8e-9fe2-481333b3d83b" name="Columns" order-num="0" child-type="column" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Tables,table LogProcedures,category Columns">
                            <column _I_D="2d0c536f-cda1-4da4-8d77-e61269410793" name="logid" type-name="bigint" is-nullable="0" is-identity="YES" is-xml-document="N" dt-name="BIGINT" transformed="2022-09-14 15:32:53" character-maximum-length="8" numeric-precision="19" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Tables,table LogProcedures,category Columns,column LogID" source-vendor="MSSQL" identity-generation="ALWAYS" identity-start-with="1" identity-increment-by="1"/>
                            <column _I_D="94a07f7f-500e-4d2b-aa00-45b5caa97cd5" name="mainid" type-name="bigint" is-nullable="Y" is-xml-document="N" dt-name="BIGINT" transformed="2022-09-14 15:32:53" character-maximum-length="8" numeric-precision="19" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Tables,table LogProcedures,category Columns,column MainID" source-vendor="MSSQL"/>
                            <column _I_D="a88f2412-9a25-4897-86c4-d00c4cd0e267" name="parentid" type-name="bigint" is-nullable="Y" is-xml-document="N" dt-name="BIGINT" transformed="2022-09-14 15:32:53" character-maximum-length="8" numeric-precision="19" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Tables,table LogProcedures,category Columns,column ParentID" source-vendor="MSSQL"/>
                            <column _I_D="e7d36587-0ada-4351-9c24-8aa9c2663836" name="starttime" type-name="datetime" is-nullable="N" is-xml-document="N" dt-name="TIMESTAMP WITHOUT TIME ZONE" default-definition="clock_timestamp()" transformed="2022-09-14 15:32:53" character-maximum-length="8" numeric-precision="23" numeric-scale="3" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Tables,table LogProcedures,category Columns,column StartTime" source-vendor="MSSQL"/>
                            <column _I_D="2694ac16-b0b9-4674-b829-b57a659572c0" name="endtime" type-name="datetime" is-nullable="Y" is-xml-document="N" dt-name="TIMESTAMP WITHOUT TIME ZONE" transformed="2022-09-14 15:32:53" character-maximum-length="8" numeric-precision="23" numeric-scale="3" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Tables,table LogProcedures,category Columns,column EndTime" source-vendor="MSSQL"/>
                            <column _I_D="a49a5fe8-533b-4de4-9a67-54ab80d6adfc" name="duration" type-name="int" is-nullable="Y" is-xml-document="N" dt-name="INTEGER" transformed="2022-09-14 15:32:53" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Tables,table LogProcedures,category Columns,column Duration" source-vendor="MSSQL"/>
                            <column _I_D="e49c9a58-0bc5-4ded-8fce-7465e340b77a" name="rowcount" type-name="int" is-nullable="Y" is-xml-document="N" dt-name="INTEGER" transformed="2022-09-14 15:32:53" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Tables,table LogProcedures,category Columns,column RowCount" source-vendor="MSSQL"/>
                            <column _I_D="dd717b01-e4e7-447e-96fd-539629bbcfb6" name="sys_user_name" type-name="varchar" is-nullable="N" is-xml-document="N" dt-name="VARCHAR" dt-attr-1="256" transformed="2022-09-14 15:32:53" character-maximum-length="256" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Tables,table LogProcedures,category Columns,column SYS_USER_NAME" source-vendor="MSSQL"/>
                            <column _I_D="320182ab-e1de-408d-8436-0a433e2efa66" name="sys_host_name" type-name="varchar" is-nullable="N" is-xml-document="N" dt-name="VARCHAR" dt-attr-1="100" transformed="2022-09-14 15:32:53" character-maximum-length="100" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Tables,table LogProcedures,category Columns,column SYS_HOST_NAME" source-vendor="MSSQL"/>
                            <column _I_D="386fb035-b151-42ae-9238-dbe921e38b7a" name="sys_app_name" type-name="varchar" is-nullable="N" is-xml-document="N" dt-name="VARCHAR" dt-attr-1="128" transformed="2022-09-14 15:32:53" character-maximum-length="128" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Tables,table LogProcedures,category Columns,column SYS_APP_NAME" source-vendor="MSSQL"/>
                            <column _I_D="f2ef1ebd-2497-4c04-8fe9-9bb0b49ab45a" name="spid" type-name="int" is-nullable="N" is-xml-document="N" dt-name="INTEGER" transformed="2022-09-14 15:32:53" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Tables,table LogProcedures,category Columns,column SPID" source-vendor="MSSQL"/>
                            <column _I_D="53b37d73-2421-4f18-a350-ada8f13240b5" name="spname" type-name="varchar" is-nullable="Y" is-xml-document="N" dt-name="VARCHAR" dt-attr-1="512" transformed="2022-09-14 15:32:53" character-maximum-length="512" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Tables,table LogProcedures,category Columns,column SPName" source-vendor="MSSQL"/>
                            <column _I_D="a0f7668c-d704-49e8-8aa0-58b5ce330ecd" name="spparams" type-name="varchar" is-nullable="Y" is-xml-document="N" dt-name="TEXT" transformed="2022-09-14 15:32:53" character-maximum-length="-1" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Tables,table LogProcedures,category Columns,column SPParams" source-vendor="MSSQL"/>
                            <column _I_D="92fd9777-bbf9-40df-a5b8-76685a504d88" name="spinfo" type-name="varchar" is-nullable="Y" is-xml-document="N" dt-name="TEXT" transformed="2022-09-14 15:32:53" character-maximum-length="-1" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Tables,table LogProcedures,category Columns,column SPInfo" source-vendor="MSSQL"/>
                            <column _I_D="3fb0938a-4d4b-466d-8356-18f290be181b" name="errormessage" type-name="varchar" is-nullable="Y" is-xml-document="N" dt-name="VARCHAR" dt-attr-1="2048" transformed="2022-09-14 15:32:53" character-maximum-length="2048" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Tables,table LogProcedures,category Columns,column ErrorMessage" source-vendor="MSSQL"/>
                            <column _I_D="1534a0b8-c830-4723-947c-adba7ec9a61c" name="transactioncount" type-name="int" is-nullable="Y" is-xml-document="N" dt-name="INTEGER" transformed="2022-09-14 15:32:53" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Tables,table LogProcedures,category Columns,column TransactionCount" source-vendor="MSSQL"/>
                        </category>
                        <category _I_D="7e82502e-d4d8-4313-a2b1-0eba949f13f7" name="Constraints" order-num="1" child-type="constraint" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Tables,table LogProcedures,category Constraints">
                            <constraint _I_D="6d9d80e4-9fa6-464a-86b7-693be036fd9f" name="pk_audit_logprocedures_677577452" constraint-type-desc="PRIMARY KEY" transformed="2022-09-14 15:32:53" constraint-schema="audit" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Tables,table LogProcedures,category Constraints,constraint PK_audit_LogProcedures" source-vendor="MSSQL" constraint-type="PRIMARY KEY">
                                <category _I_D="e7237f15-4499-4fa1-90bd-a4f19de3b774" name="Columns" order-num="0" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Tables,table LogProcedures,category Constraints,constraint PK_audit_LogProcedures,category Columns">
                                    <column _I_D="72076b8b-19af-4700-a37b-0ec54732d7eb" name="logid" ordinal-position="1" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Tables,table LogProcedures,category Constraints,constraint PK_audit_LogProcedures,category Columns,column LogID" source-vendor="MSSQL" descasc="ASC"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="cddd94b7-797e-4614-afd7-be0ead86fd49" name="Indexes" order-num="2" child-type="index" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Tables,table LogProcedures,category Indexes"/>
                        <category _I_D="9af13632-a79f-475c-be07-5b7d3a25fbab" name="Triggers" order-num="3" child-type="trigger" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Tables,table LogProcedures,category Triggers"/>
                        <category _I_D="248211e3-54cd-4619-aa00-7223271cacaa" name="Partitions" order-num="4" child-type="partition" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Tables,table LogProcedures,category Partitions"/>
                    </table>
                </category>
                <category _I_D="dfafebe4-a4f0-46ce-8b40-c0fb26d37a89" name="Views" order-num="3" child-type="view" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Views"/>
                <category _I_D="5166774a-827e-43f3-975d-b94852299c79" name="Procedures" order-num="4" child-type="procedure" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Procedures">
                    <procedure _I_D="b22714e0-9862-4bb4-9806-bc7161ded14b" object-id="981578535" schema-id="8" name="sp_auditerror" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Procedures,procedure sp_AuditError" source-vendor="MSSQL" count-all-parsable-nodes="85" count-error-parsable-nodes="0" proc-language="plpgsql">
                        <complex-attribute name="sql"><![CDATA[DECLARE&#x000d;
    sp_auditfinish$ReturnCode INTEGER;&#x000d;
BEGIN&#x000d;
    UPDATE audit.logprocedures&#x000d;
    SET errormessage = LEFT(COALESCE(errormessage, '') || COALESCE(par_ErrorMessage, 'Error') || '; ', 2048)&#x000d;
        WHERE logid = par_LogID;&#x000d;
&#x000d;
    IF par_isFinish = 1 THEN&#x000d;
        CALL audit.sp_auditfinish(par_LogID := par_LogID, return_code => sp_auditfinish$ReturnCode);&#x000d;
    END IF;&#x000d;
END;]]></complex-attribute>
                        <category _I_D="c49689d3-8ea0-45ca-b29f-2d7044e67cc3" name="Parameters" order-num="0" child-type="parameter" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Procedures,procedure sp_AuditError,category Parameters">
                            <parameter _I_D="c277c64b-3981-423b-8a5a-8f065f39f231" name="par_logid" dt-name="INTEGER" transformed="2022-09-14 15:32:53" argument-order="1" argument-datatype="int" argument-mode="IN" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Procedures,procedure sp_AuditError,category Parameters,parameter \@LogID" source-vendor="MSSQL" argument-default="NULL"/>
                            <parameter _I_D="4ec094f2-f43d-4361-a5af-dfcbff4d055e" name="par_errormessage" dt-name="VARCHAR" dt-attr-1="2048" transformed="2022-09-14 15:32:53" argument-order="2" argument-datatype="varchar" argument-mode="IN" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Procedures,procedure sp_AuditError,category Parameters,parameter \@ErrorMessage" source-vendor="MSSQL" argument-default="NULL"/>
                            <parameter _I_D="7bef4e79-d1cf-4e7c-af6a-bcce61dfa6f2" name="par_isfinish" dt-name="NUMERIC" dt-attr-1="1" dt-attr-2="0" transformed="2022-09-14 15:32:53" argument-order="3" argument-datatype="bit" argument-mode="IN" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Procedures,procedure sp_AuditError,category Parameters,parameter \@isFinish" source-vendor="MSSQL" argument-default="0"/>
                        </category>
                    </procedure>
                    <procedure _I_D="6a99ca14-cdc0-4753-80dd-dc0e14cbc153" object-id="997578592" schema-id="8" name="sp_auditfinish" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Procedures,procedure sp_AuditFinish" source-vendor="MSSQL" count-all-parsable-nodes="260" count-error-parsable-nodes="3" proc-language="plpgsql">
                        <complex-attribute name="sql"><![CDATA[DECLARE&#x000d;
    var_AuditProcEnable VARCHAR(128);&#x000d;
    var_TranCount INTEGER;&#x000d;
BEGIN&#x000d;
    SELECT&#x000d;
        meta.ufn_getconfigvalue('AuditProcAll')&#x000d;
        INTO var_AuditProcEnable;&#x000d;
&#x000d;
    IF var_AuditProcEnable IS NULL THEN&#x000d;
        return_code := 0;&#x000d;
        RETURN;&#x000d;
    END IF;&#x000d;
&#x000d;
    IF NOT EXISTS (SELECT&#x000d;
        *&#x000d;
        FROM tempdb_dbo.sysobjects&#x000d;
        WHERE id = aws_sqlserver_ext.object_id('tempdb.dbo.#AuditProc')) THEN&#x000d;
        CREATE TEMPORARY TABLE t$auditproc&#x000d;
        (logid INTEGER PRIMARY KEY NOT NULL);&#x000d;
    END IF;&#x000d;
    /*&#x000d;
    [7811 - Severity CRITICAL - PostgreSQL doesn't support the @@TRANCOUNT function. Review the converted code to make sure that the user-defined function produces the same results as the source code.]&#x000d;
    SET @TranCount = @@TRANCOUNT&#x000d;
    */&#x000d;
    UPDATE audit.logprocedures&#x000d;
    SET endtime = clock_timestamp(), duration = aws_sqlserver_ext.datediff('millisecond', starttime::TIMESTAMP, clock_timestamp()::TIMESTAMP), rowcount = par_RecordCount, spinfo = COALESCE(spinfo, '') ||&#x000d;
    CASE&#x000d;
        WHEN transactioncount = var_TranCount THEN ''&#x000d;
        ELSE 'Tran count changed to ' || COALESCE(LTRIM(to_char(var_TranCount::DOUBLE PRECISION, '9999999999')), 'NULL') || ';'&#x000d;
    END ||&#x000d;
    CASE&#x000d;
        WHEN par_SPInfo IS NULL THEN ''&#x000d;
        ELSE 'Finish:' || aws_sqlserver_ext.conv_datetime_to_string('VARCHAR(19)', 'DATETIME', clock_timestamp(), 120) || ':' || par_SPInfo || ';'&#x000d;
    END&#x000d;
        WHERE logid = par_LogID;&#x000d;
    DELETE FROM t$auditproc&#x000d;
        WHERE logid >= par_LogID;&#x000d;
    /*&#x000d;
    &#x000d;
    DROP TABLE IF EXISTS t$auditproc;&#x000d;
    */&#x000d;
    /*&#x000d;
    &#x000d;
    Temporary table must be removed before end of the function.&#x000d;
    */&#x000d;
END;]]></complex-attribute>
                        <category _I_D="ae645c1e-83c8-4fac-ab68-3d8f5fdca8a9" name="Parameters" order-num="0" child-type="parameter" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Procedures,procedure sp_AuditFinish,category Parameters">
                            <parameter _I_D="8d83c62e-3d1b-414b-8df2-f43ab10a73c8" name="par_logid" dt-name="INTEGER" transformed="2022-09-14 15:32:53" argument-order="1" argument-datatype="int" argument-mode="IN" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Procedures,procedure sp_AuditFinish,category Parameters,parameter \@LogID" source-vendor="MSSQL" argument-default="NULL"/>
                            <parameter _I_D="1a322ce0-d72e-4fc6-9ec3-c201b238c0cb" name="par_recordcount" dt-name="INTEGER" transformed="2022-09-14 15:32:53" argument-order="2" argument-datatype="int" argument-mode="IN" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Procedures,procedure sp_AuditFinish,category Parameters,parameter \@RecordCount" source-vendor="MSSQL" argument-default="NULL"/>
                            <parameter _I_D="52498a7e-4365-4e07-bc37-4e93d1d17086" name="par_spinfo" dt-name="TEXT" transformed="2022-09-14 15:32:53" argument-order="3" argument-datatype="varchar" argument-mode="IN" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Procedures,procedure sp_AuditFinish,category Parameters,parameter \@SPInfo" source-vendor="MSSQL" argument-default="NULL"/>
                            <parameter _I_D="d15992b6-c48f-47f3-afdb-38b2e5c0ae7b" name="return_code" dt-name="int" transformed="2022-09-14 15:32:53" argument-order="4" argument-datatype="int" argument-mode="INOUT" argument-default="0"/>
                        </category>
                    </procedure>
                    <procedure _I_D="2a138e0b-a085-47f6-af78-a6af605046ab" object-id="1013578649" schema-id="8" name="sp_auditstart" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Procedures,procedure sp_AuditStart" source-vendor="MSSQL" count-all-parsable-nodes="324" count-error-parsable-nodes="3" proc-language="plpgsql">
                        <complex-attribute name="sql"><![CDATA[&#x000d;
/*&#x000d;
DECLARE @ID int&#x000d;
EXEC audit.sp_AuditStart @ID = @ID output&#x000d;
SELECT @ID&#x000d;
SELECT [meta].[ufn_GetConfigValue]('AuditProcAll')&#x000d;
*/&#x000d;
DECLARE&#x000d;
    var_AuditProcEnable VARCHAR(128);&#x000d;
    var_ParentID INTEGER;&#x000d;
    var_MainID INTEGER;&#x000d;
    var_CountIds INTEGER;&#x000d;
    var_TranCount INTEGER;&#x000d;
    SCOPE_IDENTITY BIGINT;&#x000d;
BEGIN&#x000d;
    SELECT&#x000d;
        meta.ufn_getconfigvalue('AuditProcAll')&#x000d;
        INTO var_AuditProcEnable;&#x000d;
&#x000d;
    IF var_AuditProcEnable IS NULL THEN&#x000d;
        return_code := 0;&#x000d;
        RETURN;&#x000d;
    END IF;&#x000d;
&#x000d;
    IF NOT EXISTS (SELECT&#x000d;
        *&#x000d;
        FROM tempdb_dbo.sysobjects&#x000d;
        WHERE id = aws_sqlserver_ext.object_id('tempdb.dbo.#AuditProc')) THEN&#x000d;
        CREATE TEMPORARY TABLE t$auditproc&#x000d;
        (logid INTEGER PRIMARY KEY NOT NULL);&#x000d;
    END IF;&#x000d;
    /*&#x000d;
    [7811 - Severity CRITICAL - PostgreSQL doesn't support the @@TRANCOUNT function. Review the converted code to make sure that the user-defined function produces the same results as the source code.]&#x000d;
    SET @TranCount = @@TRANCOUNT&#x000d;
    */&#x000d;
    SELECT&#x000d;
        MIN(logid), MAX(logid), COUNT(logid)&#x000d;
        INTO var_MainID, var_ParentID, var_CountIds&#x000d;
        FROM t$auditproc;&#x000d;
    par_SPName := LEFT(REPEAT('    ',&#x000d;
    CASE&#x000d;
        WHEN var_CountIds < 0 THEN NULL::INT&#x000d;
        ELSE var_CountIds&#x000d;
    END) || LTRIM(RTRIM(par_SPName)), 512) || COALESCE(': ' || par_SPSub, '');&#x000d;
    INSERT INTO audit.logprocedures (mainid, parentid, spname, spparams, transactioncount)&#x000d;
    VALUES (var_MainID, var_ParentID, par_SPName, par_SPParams, var_TranCount);&#x000d;
    par_LogID := SCOPE_IDENTITY;&#x000d;
&#x000d;
    IF var_MainID IS NULL THEN&#x000d;
        UPDATE audit.logprocedures&#x000d;
        SET mainid = par_LogID&#x000d;
            WHERE logid = par_LogID;&#x000d;
    END IF;&#x000d;
&#x000d;
    IF var_ParentID IS NULL OR var_ParentID < par_LogID THEN&#x000d;
        INSERT INTO t$auditproc (logid)&#x000d;
        VALUES (par_LogID);&#x000d;
    END IF;&#x000d;
    /*&#x000d;
    &#x000d;
    DROP TABLE IF EXISTS t$auditproc;&#x000d;
    */&#x000d;
    /*&#x000d;
    &#x000d;
    Temporary table must be removed before end of the function.&#x000d;
    */&#x000d;
END;]]></complex-attribute>
                        <category _I_D="fc2a700b-b28d-4840-9248-1243728a6b20" name="Parameters" order-num="0" child-type="parameter" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Procedures,procedure sp_AuditStart,category Parameters">
                            <parameter _I_D="6b4a7242-d698-4a41-8445-0a02bf9bae90" name="par_spname" dt-name="VARCHAR" dt-attr-1="512" transformed="2022-09-14 15:32:53" argument-order="1" argument-datatype="varchar" argument-mode="IN" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Procedures,procedure sp_AuditStart,category Parameters,parameter \@SPName" source-vendor="MSSQL" argument-default="NULL"/>
                            <parameter _I_D="5b9b081d-f12b-401a-9c3a-c9839048be3b" name="par_spparams" dt-name="TEXT" transformed="2022-09-14 15:32:53" argument-order="2" argument-datatype="varchar" argument-mode="IN" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Procedures,procedure sp_AuditStart,category Parameters,parameter \@SPParams" source-vendor="MSSQL" argument-default="NULL"/>
                            <parameter _I_D="843d9b5f-c8bd-417d-a54d-9afa85a4e036" name="par_spsub" dt-name="VARCHAR" dt-attr-1="256" transformed="2022-09-14 15:32:53" argument-order="3" argument-datatype="varchar" argument-mode="IN" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Procedures,procedure sp_AuditStart,category Parameters,parameter \@SPSub" source-vendor="MSSQL" argument-default="NULL"/>
                            <parameter _I_D="aeb4bb94-68db-4338-8975-d1eda717f912" name="par_logid" dt-name="INTEGER" transformed="2022-09-14 15:32:53" argument-order="4" argument-datatype="int" argument-mode="INOUT" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Procedures,procedure sp_AuditStart,category Parameters,parameter \@LogID" source-vendor="MSSQL" argument-default="NULL"/>
                            <parameter _I_D="13676718-ee03-4f27-a536-23b8525369d7" name="return_code" dt-name="int" transformed="2022-09-14 15:32:53" argument-order="5" argument-datatype="int" argument-mode="INOUT" argument-default="0"/>
                        </category>
                    </procedure>
                    <procedure _I_D="86744468-a60a-4b24-a7cc-c3742e16131c" object-id="1029578706" schema-id="8" name="sp_print" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Procedures,procedure sp_Print" source-vendor="MSSQL" count-all-parsable-nodes="198" count-error-parsable-nodes="0" proc-language="plpgsql">
                        <complex-attribute name="sql"><![CDATA[&#x000d;
/* [audit].[sp_Print] @string = ' SELECT * FROM Security ' */&#x000d;
DECLARE&#x000d;
    var_str VARCHAR(4000);&#x000d;
    var_part INTEGER;&#x000d;
    var_len INTEGER;&#x000d;
    var_AuditPrintEnable VARCHAR(128);&#x000d;
BEGIN&#x000d;
    var_part := 4000;&#x000d;
    var_len := LENGTH(par_string);&#x000d;
    SELECT&#x000d;
        meta.ufn_getconfigvalue('AuditPrintAll')&#x000d;
        INTO var_AuditPrintEnable;&#x000d;
&#x000d;
    IF COALESCE(var_AuditPrintEnable, 0) = 2 OR (par_OverrideConfig = 0 AND COALESCE(var_AuditPrintEnable, 0) = 0) THEN&#x000d;
        return_code := 0;&#x000d;
        RETURN;&#x000d;
    END IF;&#x000d;
&#x000d;
    WHILE var_len > 0 LOOP&#x000d;
        IF var_len <= var_part THEN&#x000d;
            RAISE NOTICE '%', par_string;&#x000d;
            EXIT;&#x000d;
        END IF;&#x000d;
        var_str := LEFT(par_string, var_part);&#x000d;
        /* SET @str = LEFT(@str, LEN(@str ) - CHARINDEX(CHAR(13), REVERSE(@str)) + 1) */&#x000d;
        RAISE NOTICE '%', var_str;&#x000d;
        par_string := RIGHT(par_string, var_len - LENGTH(var_str));&#x000d;
        var_len := LENGTH(par_string);&#x000d;
    END LOOP;&#x000d;
END;]]></complex-attribute>
                        <category _I_D="df4aec14-0d22-4c7d-a304-2ca2f5b13c36" name="Parameters" order-num="0" child-type="parameter" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Procedures,procedure sp_Print,category Parameters">
                            <parameter _I_D="0525da5d-231e-4e3a-925e-1ba7ec4624cd" name="par_string" dt-name="TEXT" transformed="2022-09-14 15:32:53" argument-order="1" argument-datatype="nvarchar" argument-mode="IN" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Procedures,procedure sp_Print,category Parameters,parameter \@string" source-vendor="MSSQL"/>
                            <parameter _I_D="d20cc2f2-7b72-4c8f-acae-edb014110930" name="par_overrideconfig" dt-name="NUMERIC" dt-attr-1="1" dt-attr-2="0" transformed="2022-09-14 15:32:53" argument-order="2" argument-datatype="bit" argument-mode="IN" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Procedures,procedure sp_Print,category Parameters,parameter \@OverrideConfig" source-vendor="MSSQL" argument-default="0"/>
                            <parameter _I_D="f751f475-38e5-49ce-99fb-6adbea6e5e07" name="return_code" dt-name="int" transformed="2022-09-14 15:32:53" argument-order="3" argument-datatype="int" argument-mode="INOUT" argument-default="0"/>
                        </category>
                    </procedure>
                </category>
                <category _I_D="44bf3a3e-617e-4c9f-8e18-1b1b90ff8b55" name="Functions" order-num="5" child-type="function" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category SQL scalar functions"/>
                <category _I_D="f3ee30ed-8781-4085-8da8-10f0b35838d9" name="Sequences" order-num="10" child-type="sequence" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Sequences"/>
                <category _I_D="324b8083-d305-4783-abb4-a826cab6faaa" name="Domains" order-num="11" child-type="domain" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Types"/>
                <category _I_D="4f914c37-8288-48c8-bda9-4415b2b49d24" name="User defined types" order-num="12" child-type="table-type" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema audit,category Table types"/>
            </schema>
            <schema _I_D="625d6290-fba8-407a-8c4a-37304c5aa6fe" name="upload" is-empty="N" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload" source-vendor="MSSQL">
                <category _I_D="2e625c2c-832d-4352-8a19-d6ddf8e85c72" name="Tables" order-num="0" child-type="table" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables">
                    <table _I_D="d78bef29-2f02-4a1c-89bf-becbbeb254e6" name="cbrusdrate" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables,table CbrUsdRate" source-vendor="MSSQL" partitioned="NO">
                        <category _I_D="dbc60208-3f8a-4eb1-a3fb-818aa6534784" name="Columns" order-num="0" child-type="column" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables,table CbrUsdRate,category Columns">
                            <column _I_D="d7d02980-de1f-4dfb-98eb-1317a861460a" name="id" type-name="int" is-nullable="0" is-identity="YES" is-xml-document="N" dt-name="INTEGER" transformed="2022-09-14 15:32:53" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables,table CbrUsdRate,category Columns,column ID" source-vendor="MSSQL" identity-generation="ALWAYS" identity-start-with="1" identity-increment-by="1"/>
                            <column _I_D="1015c890-1eb4-4f9a-93e4-459ed24f06ed" name="date" type-name="datetime" is-nullable="Y" is-xml-document="N" dt-name="TIMESTAMP WITHOUT TIME ZONE" transformed="2022-09-14 15:32:53" character-maximum-length="8" numeric-precision="23" numeric-scale="3" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables,table CbrUsdRate,category Columns,column Date" source-vendor="MSSQL"/>
                            <column _I_D="a490554c-c1e9-4985-9cbf-3db55ed89591" name="exchangerates" type-name="money" is-nullable="Y" is-xml-document="N" dt-name="NUMERIC" dt-attr-1="19" dt-attr-2="4" transformed="2022-09-14 15:32:53" character-maximum-length="8" numeric-precision="19" numeric-scale="4" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables,table CbrUsdRate,category Columns,column ExchangeRates" source-vendor="MSSQL"/>
                        </category>
                        <category _I_D="aa0b26ca-d353-4e23-8acf-3de8eb9a1766" name="Constraints" order-num="1" child-type="constraint" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables,table CbrUsdRate,category Constraints"/>
                        <category _I_D="0d8a72f5-4ea9-4262-9764-7f47067e03f6" name="Indexes" order-num="2" child-type="index" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables,table CbrUsdRate,category Indexes"/>
                        <category _I_D="53fca54f-9b84-4e73-b210-d264aef73ad0" name="Triggers" order-num="3" child-type="trigger" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables,table CbrUsdRate,category Triggers"/>
                        <category _I_D="bcd46b18-cfc6-4872-afe3-f955670824a0" name="Partitions" order-num="4" child-type="partition" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables,table CbrUsdRate,category Partitions"/>
                    </table>
                    <table _I_D="7aed7d41-887c-42f2-abd9-37b6c8e02e0f" name="currencyperiod" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables,table CurrencyPeriod" source-vendor="MSSQL" partitioned="NO">
                        <category _I_D="e73f248d-b360-4191-85d4-c72d775470a0" name="Columns" order-num="0" child-type="column" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables,table CurrencyPeriod,category Columns">
                            <column _I_D="caefeae0-9d60-466a-92bd-90a7cbef748d" name="id" type-name="int" is-nullable="0" is-identity="YES" is-xml-document="N" dt-name="INTEGER" transformed="2022-09-14 15:32:53" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables,table CurrencyPeriod,category Columns,column ID" source-vendor="MSSQL" identity-generation="ALWAYS" identity-start-with="1" identity-increment-by="1"/>
                            <column _I_D="ff32b67a-23dc-489d-a36b-5cdb3664e859" name="batchid" type-name="int" is-nullable="N" is-xml-document="N" dt-name="INTEGER" transformed="2022-09-14 15:32:53" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables,table CurrencyPeriod,category Columns,column BatchID" source-vendor="MSSQL"/>
                            <column _I_D="9307e73f-747c-4249-8bf8-3c0698da3088" name="dateid_start" type-name="int" is-nullable="N" is-xml-document="N" dt-name="INTEGER" transformed="2022-09-14 15:32:53" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables,table CurrencyPeriod,category Columns,column DateID_Start" source-vendor="MSSQL"/>
                            <column _I_D="1756d956-c52b-48ec-9179-d76d3352a698" name="dateid_end" type-name="int" is-nullable="N" is-xml-document="N" dt-name="INTEGER" transformed="2022-09-14 15:32:53" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables,table CurrencyPeriod,category Columns,column DateID_End" source-vendor="MSSQL"/>
                            <column _I_D="ce7c1c3d-98a9-4f0e-9adc-39a5a86221a3" name="createdate" type-name="datetime" is-nullable="Y" is-xml-document="N" dt-name="TIMESTAMP WITHOUT TIME ZONE" transformed="2022-09-14 15:32:53" character-maximum-length="8" numeric-precision="23" numeric-scale="3" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables,table CurrencyPeriod,category Columns,column CreateDate" source-vendor="MSSQL"/>
                        </category>
                        <category _I_D="488849a9-9531-427b-96cc-7e2d6fde5a2d" name="Constraints" order-num="1" child-type="constraint" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables,table CurrencyPeriod,category Constraints">
                            <constraint _I_D="38a69ba1-2b5c-46f8-a95a-2b0e9c86649d" name="pk_currencyperiod_645577338" constraint-type-desc="PRIMARY KEY" transformed="2022-09-14 15:32:53" constraint-schema="upload" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables,table CurrencyPeriod,category Constraints,constraint PK_CurrencyPeriod" source-vendor="MSSQL" constraint-type="PRIMARY KEY">
                                <category _I_D="94e71b72-517f-4a0a-a536-649eee884962" name="Columns" order-num="0" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables,table CurrencyPeriod,category Constraints,constraint PK_CurrencyPeriod,category Columns">
                                    <column _I_D="e060d706-9bb6-43ce-8c66-9ea42b73c1b7" name="id" ordinal-position="1" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables,table CurrencyPeriod,category Constraints,constraint PK_CurrencyPeriod,category Columns,column ID" source-vendor="MSSQL" descasc="ASC"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="1230608a-5770-4598-8b72-5ab530becc91" name="Indexes" order-num="2" child-type="index" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables,table CurrencyPeriod,category Indexes"/>
                        <category _I_D="c17c669b-c046-48f3-a767-d51c5e533f7a" name="Triggers" order-num="3" child-type="trigger" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables,table CurrencyPeriod,category Triggers"/>
                        <category _I_D="72b0ffe6-b7f5-4019-a91e-73c32a31dec5" name="Partitions" order-num="4" child-type="partition" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables,table CurrencyPeriod,category Partitions"/>
                    </table>
                    <table _I_D="7d4dfdc6-9ef7-4057-afbb-4c50de315074" name="incomebook" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables,table IncomeBook" source-vendor="MSSQL" partitioned="NO">
                        <category _I_D="770e3519-1bda-4b28-839c-f41f4cf95c6a" name="Columns" order-num="0" child-type="column" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables,table IncomeBook,category Columns">
                            <column _I_D="6541c0d5-ca33-49b1-95c6-dff1367802a0" name="id" type-name="int" is-nullable="0" is-identity="YES" is-xml-document="N" dt-name="INTEGER" transformed="2022-09-14 15:32:53" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables,table IncomeBook,category Columns,column ID" source-vendor="MSSQL" identity-generation="ALWAYS" identity-start-with="1" identity-increment-by="1"/>
                            <column _I_D="b061ce9e-69e2-4c16-8bfe-bfb3d57ece4d" name="date" type-name="datetime" is-nullable="Y" is-xml-document="N" dt-name="TIMESTAMP WITHOUT TIME ZONE" transformed="2022-09-14 15:32:53" character-maximum-length="8" numeric-precision="23" numeric-scale="3" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables,table IncomeBook,category Columns,column Date" source-vendor="MSSQL"/>
                            <column _I_D="52639f8b-8450-4d8d-9011-734722baff63" name="incomeusd" type-name="money" is-nullable="Y" is-xml-document="N" dt-name="NUMERIC" dt-attr-1="19" dt-attr-2="4" transformed="2022-09-14 15:32:53" character-maximum-length="8" numeric-precision="19" numeric-scale="4" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables,table IncomeBook,category Columns,column IncomeUsd" source-vendor="MSSQL"/>
                            <column _I_D="6c03b65a-7ba9-4a78-9128-11813d72f02c" name="exchangedata" type-name="datetime" is-nullable="Y" is-xml-document="N" dt-name="TIMESTAMP WITHOUT TIME ZONE" transformed="2022-09-14 15:32:53" character-maximum-length="8" numeric-precision="23" numeric-scale="3" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables,table IncomeBook,category Columns,column ExchangeData" source-vendor="MSSQL"/>
                            <column _I_D="868a59f5-ee61-42b7-9061-cc980e73f52e" name="exchangevalue" type-name="money" is-nullable="Y" is-xml-document="N" dt-name="NUMERIC" dt-attr-1="19" dt-attr-2="4" transformed="2022-09-14 15:32:53" character-maximum-length="8" numeric-precision="19" numeric-scale="4" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables,table IncomeBook,category Columns,column ExchangeValue" source-vendor="MSSQL"/>
                            <column _I_D="d069d929-79e7-4377-bd78-691c44296710" name="exchangerate" type-name="money" is-nullable="Y" is-xml-document="N" dt-name="NUMERIC" dt-attr-1="19" dt-attr-2="4" transformed="2022-09-14 15:32:53" character-maximum-length="8" numeric-precision="19" numeric-scale="4" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables,table IncomeBook,category Columns,column ExchangeRate" source-vendor="MSSQL"/>
                        </category>
                        <category _I_D="ba1c64d6-02f7-4523-aa5f-6603430ed517" name="Constraints" order-num="1" child-type="constraint" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables,table IncomeBook,category Constraints"/>
                        <category _I_D="1c4fc590-609f-4264-a2b8-342ccb8bbe64" name="Indexes" order-num="2" child-type="index" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables,table IncomeBook,category Indexes"/>
                        <category _I_D="c226ef1b-cbed-4fa3-b47a-cfe4539b844a" name="Triggers" order-num="3" child-type="trigger" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables,table IncomeBook,category Triggers"/>
                        <category _I_D="f500a874-345c-44a4-a73c-51551d6e3b2b" name="Partitions" order-num="4" child-type="partition" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Tables,table IncomeBook,category Partitions"/>
                    </table>
                </category>
                <category _I_D="8abddef2-2302-4c6c-84d8-121d36e8c5f5" name="Views" order-num="3" child-type="view" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Views"/>
                <category _I_D="abcc4b2a-0a82-456b-8d0c-aef2c170c91a" name="Procedures" order-num="4" child-type="procedure" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Procedures">
                    <procedure _I_D="0c121ce4-8ba9-4d17-a2d2-72d0efcf82e1" object-id="1173579219" schema-id="9" name="upl_cbrusdrate" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Procedures,procedure upl_CbrUsdRate" source-vendor="MSSQL" count-all-parsable-nodes="1168" count-error-parsable-nodes="16" proc-language="plpgsql">
                        <complex-attribute name="sql"><![CDATA[&#x000d;
/*&#x000d;
Example:&#x000d;
EXEC [upload].[upl_CbrUsdRate] '20200101', '20201231'&#x000d;
EXEC [upload].[upl_CbrUsdRate] '20200101', '20200102'&#x000d;
DECLARE @xmlString varchar(max)&#x000d;
EXEC [upload].[upl_LoadXMLFromFile] 'http://www.cbr.ru/scripts/XML_dynamic.asp?date_req1=01.01.2020&date_req2=29.05.2020&VAL_NM_RQ=R01235', @xmlString output&#x000d;
EXEC [audit].[sp_Print] @xmlString&#x000d;
INSERT [meta].[ConfigApp] (Parameter, StrValue) VALUES( 'ExcelFileIncomeBook','E:\Work\SQL\IndividualEntrepreneur\IncomeBook.xlsx')&#x000d;
&#x000d;
SELECT * FROM [upload].[CbrUsdRate]&#x000d;
*/&#x000d;
DECLARE&#x000d;
    var_SPName VARCHAR(510);&#x000d;
    var_SPParams TEXT;&#x000d;
    var_SPInfo TEXT;&#x000d;
    var_LogID INTEGER;&#x000d;
    var_RowCount INTEGER;&#x000d;
    var_AuditMessage TEXT;&#x000d;
    var_Trancnt INTEGER;&#x000d;
    var_OverridePrintEnabling NUMERIC(1, 0);&#x000d;
    var_res INTEGER;&#x000d;
    var_OpenRowSet TEXT;&#x000d;
    var_sqlcmd TEXT;&#x000d;
    var_NewVersionCount INTEGER;&#x000d;
    var_xmlString TEXT;&#x000d;
    var_url VARCHAR(255);&#x000d;
    var_h INTEGER;&#x000d;
    var_StartDate TIMESTAMP WITHOUT TIME ZONE;&#x000d;
    var_FinishDate TIMESTAMP WITHOUT TIME ZONE;&#x000d;
    var_RowCounttmp INTEGER;&#x000d;
    var_MaxCount INTEGER;&#x000d;
    error_catch$ERROR_NUMBER TEXT;&#x000d;
    error_catch$ERROR_SEVERITY TEXT;&#x000d;
    error_catch$ERROR_STATE TEXT;&#x000d;
    error_catch$ERROR_LINE TEXT;&#x000d;
    error_catch$ERROR_PROCEDURE TEXT;&#x000d;
    error_catch$ERROR_MESSAGE TEXT;&#x000d;
    sp_auditstart$ReturnCode INTEGER;&#x000d;
    sp_print$ReturnCode INTEGER;&#x000d;
    sp_auditfinish$ReturnCode INTEGER;&#x000d;
BEGIN&#x000d;
    /*&#x000d;
    [7674 - Severity CRITICAL - AWS SCT can't convert the CONCAT_NULL_YIELDS_NULL clause of the SET statement. Convert your source code manually.]&#x000d;
    SET CONCAT_NULL_YIELDS_NULL ON&#x000d;
    */&#x000d;
    IF NOT EXISTS (SELECT&#x000d;
        *&#x000d;
        FROM tempdb_dbo.sysobjects&#x000d;
        WHERE id = aws_sqlserver_ext.object_id('tempdb.dbo.#AuditProc')) THEN&#x000d;
        CREATE TEMPORARY TABLE t$auditproc&#x000d;
        (logid INTEGER PRIMARY KEY NOT NULL);&#x000d;
    END IF;&#x000d;
    var_SPName := '[' + current_schema || '].[' + 'upl_cbrusdrate' || ']';&#x000d;
&#x000d;
    IF par_FromDate IS NULL OR par_ToDate IS NULL THEN&#x000d;
        par_FromDate := make_date(date_part('year', clock_timestamp()), 1, 1);&#x000d;
        par_ToDate := make_date(date_part('year', clock_timestamp()), 12, 31);&#x000d;
    END IF;&#x000d;
    var_SPParams := '@FromDate=' || CAST (par_FromDate AS VARCHAR(11)) || '; @ToDate=' || CAST (par_ToDate AS VARCHAR(11)) || ';';&#x000d;
    CALL audit.sp_auditstart(par_SPName := var_SPName, par_SPParams := var_SPParams, par_LogID => var_LogID, return_code => sp_auditstart$ReturnCode);&#x000d;
    /*&#x000d;
    [7674 - Severity CRITICAL - AWS SCT can't convert the XACT_ABORT clause of the SET statement. Convert your source code manually.]&#x000d;
    SET XACT_ABORT OFF&#x000d;
    */&#x000d;
    /*&#x000d;
    [7674 - Severity CRITICAL - AWS SCT can't convert the CONCAT_NULL_YIELDS_NULL clause of the SET statement. Convert your source code manually.]&#x000d;
    SET CONCAT_NULL_YIELDS_NULL ON&#x000d;
    */&#x000d;
    var_OverridePrintEnabling := 0;&#x000d;
    var_AuditMessage := '[upload].[upl_CbrUsdRate]; start';&#x000d;
    CALL audit.sp_print(var_AuditMessage, var_OverridePrintEnabling, return_code => sp_print$ReturnCode);&#x000d;
&#x000d;
    BEGIN&#x000d;
        /*&#x000d;
        [7811 - Severity CRITICAL - PostgreSQL doesn't support the @@TRANCOUNT function. Review the converted code to make sure that the user-defined function produces the same results as the source code.]&#x000d;
        SET @Trancnt = @@TRANCOUNT&#x000d;
        */&#x000d;
        IF var_Trancnt > 0 THEN&#x000d;
            /*&#x000d;
            [7807 - Severity CRITICAL - PostgreSQL does not support explicit transaction management commands such as BEGIN TRAN, SAVE TRAN in functions. Convert your source code manually.]&#x000d;
            SAVE TRAN tr_CbrUsdRate_Upload&#x000d;
            */&#x000d;
            BEGIN&#x000d;
            END;&#x000d;
        ELSE&#x000d;
            /*&#x000d;
            [7807 - Severity CRITICAL - PostgreSQL does not support explicit transaction management commands such as BEGIN TRAN, SAVE TRAN in functions. Convert your source code manually.]&#x000d;
            BEGIN TRAN;&#x000d;
            */&#x000d;
            BEGIN&#x000d;
            END;&#x000d;
        END IF;&#x000d;
        par_FromDate := make_date(date_part('year', par_FromDate), date_part('month', par_FromDate), date_part('day', par_FromDate));&#x000d;
&#x000d;
        IF (par_ToDate > clock_timestamp()) THEN&#x000d;
            par_ToDate := make_date(date_part('year', clock_timestamp()), date_part('month', clock_timestamp()), date_part('day', clock_timestamp()));&#x000d;
        ELSE&#x000d;
            par_ToDate := make_date(date_part('year', par_ToDate), date_part('month', par_ToDate), date_part('day', par_ToDate));&#x000d;
        END IF;&#x000d;
&#x000d;
        IF (aws_sqlserver_ext.datediff('day', par_FromDate::TIMESTAMP, par_ToDate::TIMESTAMP) < 0) THEN&#x000d;
            RAISE 'Error %, severity %, state % was raised. Message: %.', '50000', 16, 1, 'Error: Parameter @FromDate must be be less than @ToDate.' USING ERRCODE = '50000';&#x000d;
        END IF;&#x000d;
        var_StartDate := par_FromDate;&#x000d;
&#x000d;
        IF (aws_sqlserver_ext.datediff('day', par_FromDate::TIMESTAMP, par_ToDate::TIMESTAMP) > 54) THEN&#x000d;
            var_FinishDate := var_StartDate + (55::NUMERIC || ' DAY')::INTERVAL - (1::NUMERIC || ' days')::INTERVAL;&#x000d;
        ELSE&#x000d;
            var_FinishDate := par_ToDate;&#x000d;
        END IF;&#x000d;
        var_MaxCount := 0;&#x000d;
&#x000d;
        WHILE (var_MaxCount < 45) LOOP&#x000d;
            /* Maximum 5 year */&#x000d;
            SELECT&#x000d;
                'http://www.cbr.ru/scripts/XML_dynamic.asp?date_req1=' || aws_sqlserver_ext.conv_datetime_to_string('CHAR(10)', 'DATETIME', var_StartDate, 104) || '&date_req2=' || aws_sqlserver_ext.conv_datetime_to_string('CHAR(10)', 'DATETIME', var_FinishDate, 104) || '&VAL_NM_RQ=R01235'&#x000d;
                INTO var_url;&#x000d;
            RAISE NOTICE '%', var_url;&#x000d;
            var_xmlString := NULL;&#x000d;
            CALL upload.upl_loadxmlfromfile(var_url, var_xmlString);&#x000d;
            SELECT&#x000d;
                t.DocHandle&#x000d;
                FROM aws_sqlserver_ext.sp_xml_preparedocument(var_xmlString)&#x000d;
                    AS t&#x000d;
                INTO var_h;&#x000d;
            INSERT INTO upload.cbrusdrate (date, exchangerates)&#x000d;
            SELECT&#x000d;
                (make_date(CAST (SUBSTR(date, 7, 4) AS INTEGER), CAST (SUBSTR(date, 4, 2) AS INTEGER), CAST (SUBSTR(date, 1, 2) AS INTEGER))) AS date, CAST (REPLACE(value, ',', '.') AS NUMERIC(19, 4)) AS exchangerates&#x000d;
                FROM aws_sqlserver_ext.openxml(var_h::BIGINT), XMLTABLE('//Record'&#x000d;
                    PASSING (SELECT&#x000d;
                        XmlData)&#x000d;
                    COLUMNS date CHAR(10) PATH '@Date',&#x000d;
                    nominal INTEGER PATH './Nominal',&#x000d;
                    value VARCHAR(10) PATH './Value');&#x000d;
            GET DIAGNOSTICS var_RowCounttmp = ROW_COUNT;&#x000d;
            var_RowCount := (COALESCE(var_RowCount, 0) + var_RowCounttmp)::INT;&#x000d;
            SELECT&#x000d;
                var_FinishDate + (1::NUMERIC || ' days')::INTERVAL&#x000d;
                INTO var_StartDate;&#x000d;
            SELECT&#x000d;
                var_MaxCount + 1&#x000d;
                INTO var_MaxCount;&#x000d;
            PERFORM aws_sqlserver_ext.sp_xml_removedocument(var_h::BIGINT);&#x000d;
&#x000d;
            IF (aws_sqlserver_ext.datediff('day', var_FinishDate::TIMESTAMP, par_ToDate::TIMESTAMP) <= 0) THEN&#x000d;
                SELECT&#x000d;
                    45&#x000d;
                    INTO var_MaxCount;&#x000d;
            END IF;&#x000d;
&#x000d;
            IF (aws_sqlserver_ext.datediff('day', var_StartDate::TIMESTAMP, par_ToDate::TIMESTAMP) > 54) THEN&#x000d;
                var_FinishDate := var_StartDate + (55::NUMERIC || ' DAY')::INTERVAL - (1::NUMERIC || ' days')::INTERVAL;&#x000d;
            ELSE&#x000d;
                var_FinishDate := par_ToDate;&#x000d;
            END IF;&#x000d;
        END LOOP;&#x000d;
&#x000d;
        IF var_Trancnt = 0 THEN&#x000d;
            COMMIT;&#x000d;
        END IF;&#x000d;
        var_AuditMessage := '[upload].[upl_CbrUsdRate];@RowCount=' || LTRIM(to_char(COALESCE(var_RowCount, 0)::DOUBLE PRECISION, '9999999999')) || ' finish';&#x000d;
        CALL audit.sp_print(var_AuditMessage, var_OverridePrintEnabling, return_code => sp_print$ReturnCode);&#x000d;
        CALL audit.sp_auditfinish(par_LogID := var_LogID, par_RecordCount := var_RowCount, return_code => sp_auditfinish$ReturnCode);&#x000d;
        EXCEPTION&#x000d;
            WHEN OTHERS THEN&#x000d;
                error_catch$ERROR_NUMBER := '0';&#x000d;
                error_catch$ERROR_SEVERITY := '0';&#x000d;
                error_catch$ERROR_LINE := '0';&#x000d;
                error_catch$ERROR_PROCEDURE := 'UPL_CBRUSDRATE';&#x000d;
                GET STACKED DIAGNOSTICS error_catch$ERROR_STATE = RETURNED_SQLSTATE,&#x000d;
                    error_catch$ERROR_MESSAGE = MESSAGE_TEXT;&#x000d;
                SELECT&#x000d;
                    error_catch$ERROR_MESSAGE&#x000d;
                    INTO par_ErrMessage;&#x000d;
&#x000d;
                IF var_Trancnt = 0 THEN&#x000d;
                    ROLLBACK;&#x000d;
                ELSE&#x000d;
                    IF xact_state() != - 1 THEN&#x000d;
                        ROLLBACK;&#x000d;
                    END IF;&#x000d;
                END IF;&#x000d;
&#x000d;
                IF xact_state() != - 1 THEN&#x000d;
                    var_AuditMessage := '[upload].[upl_CbrUsdRate]; error=''' || par_ErrMessage || '''';&#x000d;
                    CALL audit.sp_print(var_AuditMessage, 2, return_code => sp_print$ReturnCode);&#x000d;
                    CALL audit.sp_auditerror(par_LogID := var_LogID, par_ErrorMessage := par_ErrMessage);&#x000d;
                END IF;&#x000d;
                CALL audit.sp_auditfinish(par_LogID := var_LogID, par_RecordCount := var_RowCount, return_code => sp_auditfinish$ReturnCode);&#x000d;
                return_code := - 1;&#x000d;
                RETURN;&#x000d;
    END;&#x000d;
    /*&#x000d;
    &#x000d;
    DROP TABLE IF EXISTS t$auditproc;&#x000d;
    */&#x000d;
    /*&#x000d;
    &#x000d;
    Temporary table must be removed before end of the function.&#x000d;
    */&#x000d;
END;]]></complex-attribute>
                        <category _I_D="1118fbc5-0498-46fc-af64-25b6d0f9f0b1" name="Parameters" order-num="0" child-type="parameter" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Procedures,procedure upl_CbrUsdRate,category Parameters">
                            <parameter _I_D="18e7882c-c1c2-4f81-9511-6e74dc9f5e3d" name="par_fromdate" dt-name="TIMESTAMP WITHOUT TIME ZONE" transformed="2022-09-14 15:32:53" argument-order="1" argument-datatype="datetime" argument-mode="IN" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Procedures,procedure upl_CbrUsdRate,category Parameters,parameter \@FromDate" source-vendor="MSSQL" argument-default="NULL"/>
                            <parameter _I_D="4eadea59-a191-41c2-bcba-9695d1a37baa" name="par_todate" dt-name="TIMESTAMP WITHOUT TIME ZONE" transformed="2022-09-14 15:32:53" argument-order="2" argument-datatype="datetime" argument-mode="IN" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Procedures,procedure upl_CbrUsdRate,category Parameters,parameter \@ToDate" source-vendor="MSSQL" argument-default="NULL"/>
                            <parameter _I_D="a58b1fcd-acc9-4713-a341-8ab336466fbc" name="par_errmessage" dt-name="TEXT" transformed="2022-09-14 15:32:53" argument-order="3" argument-datatype="nvarchar" argument-mode="INOUT" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Procedures,procedure upl_CbrUsdRate,category Parameters,parameter \@ErrMessage" source-vendor="MSSQL" argument-default="NULL"/>
                            <parameter _I_D="449f4ef8-ee1b-49af-9e0c-508b096f171a" name="return_code" dt-name="int" transformed="2022-09-14 15:32:53" argument-order="4" argument-datatype="int" argument-mode="INOUT" argument-default="0"/>
                        </category>
                    </procedure>
                    <procedure _I_D="01f4e631-3f0f-430e-a9fb-7ec6f6985db9" object-id="1189579276" schema-id="9" name="upl_incomebook" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Procedures,procedure upl_IncomeBook" source-vendor="MSSQL" count-all-parsable-nodes="651" count-error-parsable-nodes="19" proc-language="plpgsql">
                        <complex-attribute name="sql"><![CDATA[&#x000d;
/*&#x000d;
Example:&#x000d;
EXEC [upload].[upl_IncomeBook]&#x000d;
SELECT * FROM [upload].[IncomeBook]&#x000d;
SELECT [meta].[ufn_GetConfigValue]('ExcelFileIncomeBook');&#x000d;
SELECT * FROM [meta].[ConfigApp]&#x000d;
INSERT [meta].[ConfigApp] (Parameter, StrValue)&#x000d;
SELECT 'ExcelFileIncomeBook',''&#x000d;
SELECT 'ExcelFileIncomeBookCmd',''&#x000d;
INSERT [meta].[ConfigApp] (Parameter, StrValue) VALUES( 'ExcelFileIncomeBook','E:\Work\SQL\IndividualEntrepreneur\IncomeBook.xlsx')&#x000d;
*/&#x000d;
DECLARE&#x000d;
    var_SPName VARCHAR(510);&#x000d;
    var_SPParams TEXT;&#x000d;
    var_SPInfo TEXT;&#x000d;
    var_LogID INTEGER;&#x000d;
    var_RowCount INTEGER;&#x000d;
    var_AuditMessage TEXT;&#x000d;
    var_tranc INTEGER;&#x000d;
    var_OverridePrintEnabling NUMERIC(1, 0);&#x000d;
    var_res INTEGER;&#x000d;
    var_OpenRowSet TEXT;&#x000d;
    var_sqlcmd TEXT;&#x000d;
    var_NewVersionCount INTEGER;&#x000d;
    error_catch$ERROR_NUMBER TEXT;&#x000d;
    error_catch$ERROR_SEVERITY TEXT;&#x000d;
    error_catch$ERROR_STATE TEXT;&#x000d;
    error_catch$ERROR_LINE TEXT;&#x000d;
    error_catch$ERROR_PROCEDURE TEXT;&#x000d;
    error_catch$ERROR_MESSAGE TEXT;&#x000d;
    sp_auditstart$ReturnCode INTEGER;&#x000d;
    sp_print$ReturnCode INTEGER;&#x000d;
    sp_auditfinish$ReturnCode INTEGER;&#x000d;
BEGIN&#x000d;
    /*&#x000d;
    [7674 - Severity CRITICAL - AWS SCT can't convert the CONCAT_NULL_YIELDS_NULL clause of the SET statement. Convert your source code manually.]&#x000d;
    SET CONCAT_NULL_YIELDS_NULL ON&#x000d;
    */&#x000d;
    IF NOT EXISTS (SELECT&#x000d;
        *&#x000d;
        FROM tempdb_dbo.sysobjects&#x000d;
        WHERE id = aws_sqlserver_ext.object_id('tempdb.dbo.#AuditProc')) THEN&#x000d;
        CREATE TEMPORARY TABLE t$auditproc&#x000d;
        (logid INTEGER PRIMARY KEY NOT NULL);&#x000d;
    END IF;&#x000d;
    var_SPName := '[' + current_schema || '].[' + 'upl_incomebook' || ']';&#x000d;
&#x000d;
    IF par_ExcelFile IS NULL THEN&#x000d;
        SELECT&#x000d;
            meta.ufn_getconfigvalue('ExcelFileIncomeBook')&#x000d;
            INTO par_ExcelFile;&#x000d;
    END IF;&#x000d;
&#x000d;
    IF par_ExcelFileCmd IS NULL THEN&#x000d;
        SELECT&#x000d;
            meta.ufn_getconfigvalue('ExcelFileIncomeBookCmd')&#x000d;
            INTO par_ExcelFileCmd;&#x000d;
    END IF;&#x000d;
    var_SPParams := '@ExcelFile=' || par_ExcelFile || '; @ExcelFileCmd=' || par_ExcelFileCmd || ';';&#x000d;
    CALL audit.sp_auditstart(par_SPName := var_SPName, par_SPParams := var_SPParams, par_LogID => var_LogID, return_code => sp_auditstart$ReturnCode);&#x000d;
    /*&#x000d;
    [7674 - Severity CRITICAL - AWS SCT can't convert the XACT_ABORT clause of the SET statement. Convert your source code manually.]&#x000d;
    SET XACT_ABORT OFF&#x000d;
    */&#x000d;
    /*&#x000d;
    [7674 - Severity CRITICAL - AWS SCT can't convert the CONCAT_NULL_YIELDS_NULL clause of the SET statement. Convert your source code manually.]&#x000d;
    SET CONCAT_NULL_YIELDS_NULL ON&#x000d;
    */&#x000d;
    var_OverridePrintEnabling := 1;&#x000d;
    var_AuditMessage := '[upload].[upl_IncomeBook]; start';&#x000d;
    CALL audit.sp_print(var_AuditMessage, var_OverridePrintEnabling, return_code => sp_print$ReturnCode);&#x000d;
&#x000d;
    BEGIN&#x000d;
        /*&#x000d;
        [7811 - Severity CRITICAL - PostgreSQL doesn't support the @@TRANCOUNT function. Review the converted code to make sure that the user-defined function produces the same results as the source code.]&#x000d;
        SET @tranc = @@TRANCOUNT&#x000d;
        */&#x000d;
        IF var_tranc > 0 THEN&#x000d;
            /*&#x000d;
            [7807 - Severity CRITICAL - PostgreSQL does not support explicit transaction management commands such as BEGIN TRAN, SAVE TRAN in functions. Convert your source code manually.]&#x000d;
            SAVE TRAN tran_IncomeBook&#x000d;
            */&#x000d;
            BEGIN&#x000d;
            END;&#x000d;
        ELSE&#x000d;
            /*&#x000d;
            [7807 - Severity CRITICAL - PostgreSQL does not support explicit transaction management commands such as BEGIN TRAN, SAVE TRAN in functions. Convert your source code manually.]&#x000d;
            BEGIN TRAN;&#x000d;
            */&#x000d;
            BEGIN&#x000d;
            END;&#x000d;
        END IF;&#x000d;
        SELECT&#x000d;
            meta.ufn_getconfigvalue('ExcelFileIncomeBook')&#x000d;
            INTO par_ExcelFile;&#x000d;
        SELECT&#x000d;
            meta.ufn_getconfigvalue('ExcelFileIncomeBookCmd')&#x000d;
            INTO par_ExcelFileCmd;&#x000d;
        TRUNCATE TABLE upload.incomebook;&#x000d;
&#x000d;
        IF par_ExcelFile IS NULL THEN&#x000d;
            RAISE 'Error %, severity %, state % was raised. Message: %.', '50000', 16, 1, 'Error: Parameter @ExcelFile must be defined.' USING ERRCODE = '50000';&#x000d;
        END IF;&#x000d;
&#x000d;
        IF par_ExcelFileCmd IS NULL THEN&#x000d;
            RAISE 'Error %, severity %, state % was raised. Message: %.', '50000', 16, 1, 'Error: Parameter @ExcelFile must be defined.' USING ERRCODE = '50000';&#x000d;
        END IF;&#x000d;
        var_OpenRowSet := 'Excel 12.0;IMEX=1;HDR=YES;DATABASE=' || par_ExcelFile;&#x000d;
        var_sqlcmd := '&#x000d;
		INSERT [upload].IncomeBook (Date, IncomeUsd, ExchangeData, ExchangeValue, ExchangeRate)&#x000d;
		SELECT Date, IncomeUsd, ExchangeData, ExchangeValue, ExchangeRate FROM OPENROWSET(''Microsoft.ACE.OLEDB.12.0'', ''' || var_OpenRowSet || ''',''' || par_ExcelFileCmd || ''' )&#x000d;
		';&#x000d;
        CALL audit.sp_print(var_sqlcmd, var_OverridePrintEnabling, return_code => sp_print$ReturnCode);&#x000d;
        EXECUTE var_sqlcmd;&#x000d;
        /*&#x000d;
        [7833 - Severity CRITICAL - AWS SCT can't convert the @@rowcount function in the current context. Convert your source code manually.]&#x000d;
        SET @RowCount = @@ROWCOUNT&#x000d;
        */&#x000d;
        IF var_tranc = 0 THEN&#x000d;
            COMMIT;&#x000d;
        END IF;&#x000d;
        var_AuditMessage := '[upload].[upl_IncomeBook];@RowCount=' || LTRIM(to_char(var_RowCount::DOUBLE PRECISION, '9999999999')) || ' finish';&#x000d;
        CALL audit.sp_print(var_AuditMessage, var_OverridePrintEnabling, return_code => sp_print$ReturnCode);&#x000d;
        CALL audit.sp_auditfinish(par_LogID := var_LogID, par_RecordCount := var_RowCount, return_code => sp_auditfinish$ReturnCode);&#x000d;
        EXCEPTION&#x000d;
            WHEN OTHERS THEN&#x000d;
                error_catch$ERROR_NUMBER := '0';&#x000d;
                error_catch$ERROR_SEVERITY := '0';&#x000d;
                error_catch$ERROR_LINE := '0';&#x000d;
                error_catch$ERROR_PROCEDURE := 'UPL_INCOMEBOOK';&#x000d;
                GET STACKED DIAGNOSTICS error_catch$ERROR_STATE = RETURNED_SQLSTATE,&#x000d;
                    error_catch$ERROR_MESSAGE = MESSAGE_TEXT;&#x000d;
                SELECT&#x000d;
                    error_catch$ERROR_MESSAGE&#x000d;
                    INTO par_ErrMessage;&#x000d;
&#x000d;
                IF var_tranc = 0 THEN&#x000d;
                    ROLLBACK;&#x000d;
                ELSE&#x000d;
                    IF xact_state() != - 1 THEN&#x000d;
                        ROLLBACK;&#x000d;
                    END IF;&#x000d;
                END IF;&#x000d;
&#x000d;
                IF xact_state() != - 1 THEN&#x000d;
                    var_AuditMessage := '[upload].[upl_IncomeBook]; error=''' || par_ErrMessage || '''';&#x000d;
                    CALL audit.sp_print(var_AuditMessage, 2, return_code => sp_print$ReturnCode);&#x000d;
                    CALL audit.sp_auditerror(par_LogID := var_LogID, par_ErrorMessage := par_ErrMessage);&#x000d;
                END IF;&#x000d;
                CALL audit.sp_auditfinish(par_LogID := var_LogID, par_RecordCount := var_RowCount, return_code => sp_auditfinish$ReturnCode);&#x000d;
                return_code := - 1;&#x000d;
                RETURN;&#x000d;
    END;&#x000d;
    /*&#x000d;
    &#x000d;
    DROP TABLE IF EXISTS t$auditproc;&#x000d;
    */&#x000d;
    /*&#x000d;
    &#x000d;
    Temporary table must be removed before end of the function.&#x000d;
    */&#x000d;
END;]]></complex-attribute>
                        <category _I_D="9993edd5-3ff6-4411-93c2-cf5543358e1f" name="Parameters" order-num="0" child-type="parameter" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Procedures,procedure upl_IncomeBook,category Parameters">
                            <parameter _I_D="83a456b0-dc2a-47fc-bb8d-311863bc9025" name="par_excelfile" dt-name="VARCHAR" dt-attr-1="256" transformed="2022-09-14 15:32:53" argument-order="1" argument-datatype="nvarchar" argument-mode="IN" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Procedures,procedure upl_IncomeBook,category Parameters,parameter \@ExcelFile" source-vendor="MSSQL" argument-default="NULL"/>
                            <parameter _I_D="c7c2283a-152f-43d3-b982-95b1a8dd6f29" name="par_excelfilecmd" dt-name="VARCHAR" dt-attr-1="256" transformed="2022-09-14 15:32:53" argument-order="2" argument-datatype="nvarchar" argument-mode="IN" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Procedures,procedure upl_IncomeBook,category Parameters,parameter \@ExcelFileCmd" source-vendor="MSSQL" argument-default="NULL"/>
                            <parameter _I_D="979b2402-e740-471e-a5ee-421e5a80270d" name="par_errmessage" dt-name="VARCHAR" dt-attr-1="4000" transformed="2022-09-14 15:32:53" argument-order="3" argument-datatype="nvarchar" argument-mode="INOUT" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Procedures,procedure upl_IncomeBook,category Parameters,parameter \@ErrMessage" source-vendor="MSSQL" argument-default="NULL"/>
                            <parameter _I_D="b78725cf-648f-43e8-ac04-9d26e5f24d75" name="return_code" dt-name="int" transformed="2022-09-14 15:32:53" argument-order="4" argument-datatype="int" argument-mode="INOUT" argument-default="0"/>
                        </category>
                    </procedure>
                    <procedure _I_D="228e5f22-1b0f-4d48-a9db-a192c835be70" object-id="1205579333" schema-id="9" name="upl_loadxmlfromfile" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Procedures,procedure upl_LoadXMLFromFile" source-vendor="MSSQL" count-all-parsable-nodes="533" count-error-parsable-nodes="3" proc-language="plpgsql">
                        <complex-attribute name="sql"><![CDATA[DECLARE&#x000d;
    var_SPName VARCHAR(510);&#x000d;
    var_SPParams TEXT;&#x000d;
    var_SPInfo TEXT;&#x000d;
    var_LogID INTEGER;&#x000d;
    var_RowCount INTEGER;&#x000d;
    var_retVal INTEGER;&#x000d;
    var_oXML INTEGER;&#x000d;
    var_errorSource VARCHAR(8000);&#x000d;
    var_errorDescription VARCHAR(8000);&#x000d;
    var_loadRetVal INTEGER;&#x000d;
    sp_auditstart$ReturnCode INTEGER;&#x000d;
    sp_auditfinish$ReturnCode INTEGER;&#x000d;
BEGIN&#x000d;
    /*&#x000d;
    [7674 - Severity CRITICAL - AWS SCT can't convert the CONCAT_NULL_YIELDS_NULL clause of the SET statement. Convert your source code manually.]&#x000d;
    SET CONCAT_NULL_YIELDS_NULL ON&#x000d;
    */&#x000d;
    IF NOT EXISTS (SELECT&#x000d;
        *&#x000d;
        FROM tempdb_dbo.sysobjects&#x000d;
        WHERE id = aws_sqlserver_ext.object_id('tempdb.dbo.#AuditProc')) THEN&#x000d;
        CREATE TEMPORARY TABLE t$auditproc&#x000d;
        (logid INTEGER PRIMARY KEY NOT NULL);&#x000d;
    END IF;&#x000d;
    var_SPName := '[' + current_schema || '].[' + 'upl_loadxmlfromfile' || ']';&#x000d;
    var_SPParams := '@tcFileName=' || COALESCE('''' || par_tcFileName || '''', 'NULL') || ',' || '@tcXMLString=' || COALESCE('''' || par_tcXMLString || '''', 'NULL');&#x000d;
    CALL audit.sp_auditstart(par_SPName := var_SPName, par_SPParams := var_SPParams, par_LogID => var_LogID, return_code => sp_auditstart$ReturnCode);&#x000d;
    /* Scratch variables used in the script */&#x000d;
    /* Initialize the XML document */&#x000d;
    CALL sp_OACreate('MSXML2.DOMDocument', var_oXML);&#x000d;
&#x000d;
    IF (var_retVal <> 0) THEN&#x000d;
        /* Trap errors if any */&#x000d;
        CALL sp_OAGetErrorInfo(var_oXML, var_errorSource, var_errorDescription);&#x000d;
        RAISE 'Error %, severity %, state % was raised. Message: %.', '50000', 16, 1, var_errorDescription USING ERRCODE = '50000';&#x000d;
        /* Release the reference to the COM object */&#x000d;
        CALL sp_OADestroy(var_oXML);&#x000d;
        RETURN;&#x000d;
    END IF;&#x000d;
    CALL sp_OASetProperty(var_oXML, 'async', 0);&#x000d;
&#x000d;
    IF var_retVal <> 0 THEN&#x000d;
        /* Trap errors if any */&#x000d;
        CALL sp_OAGetErrorInfo(var_oXML, var_errorSource, var_errorDescription);&#x000d;
        RAISE 'Error %, severity %, state % was raised. Message: %.', '50000', 16, 1, var_errorDescription USING ERRCODE = '50000';&#x000d;
        /* Release the reference to the COM object */&#x000d;
        CALL sp_OADestroy(var_oXML);&#x000d;
        RETURN;&#x000d;
    END IF;&#x000d;
    /* Load the XML into the document */&#x000d;
    CALL sp_OAMethod(var_oXML, 'load', var_loadRetVal, par_tcFileName);&#x000d;
&#x000d;
    IF (var_retVal <> 0) THEN&#x000d;
        /* Trap errors if any */&#x000d;
        CALL sp_OAGetErrorInfo(var_oXML, var_errorSource, var_errorDescription);&#x000d;
        RAISE 'Error %, severity %, state % was raised. Message: %.', '50000', 16, 1, var_errorDescription USING ERRCODE = '50000';&#x000d;
        /* Release the reference to the COM object */&#x000d;
        CALL sp_OADestroy(var_oXML);&#x000d;
        RETURN;&#x000d;
    END IF;&#x000d;
    /* Get the loaded XML */&#x000d;
    CALL sp_OAMethod(var_oXML, 'xml', par_tcXMLString);&#x000d;
&#x000d;
    IF (var_retVal <> 0) THEN&#x000d;
        /* Trap errors if any */&#x000d;
        CALL sp_OAGetErrorInfo(var_oXML, var_errorSource, var_errorDescription);&#x000d;
        RAISE 'Error %, severity %, state % was raised. Message: %.', '50000', 16, 1, var_errorDescription USING ERRCODE = '50000';&#x000d;
        /* Release the reference to the COM object */&#x000d;
        CALL sp_OADestroy(var_oXML);&#x000d;
        RETURN;&#x000d;
    END IF;&#x000d;
    /* Release the reference to the COM object */&#x000d;
    CALL sp_OADestroy(var_oXML);&#x000d;
    CALL audit.sp_auditfinish(par_LogID := var_LogID, par_RecordCount := var_RowCount, return_code => sp_auditfinish$ReturnCode);&#x000d;
    /*&#x000d;
    &#x000d;
    DROP TABLE IF EXISTS t$auditproc;&#x000d;
    */&#x000d;
    /*&#x000d;
    &#x000d;
    Temporary table must be removed before end of the function.&#x000d;
    */&#x000d;
END;]]></complex-attribute>
                        <category _I_D="a096514e-1aa3-45c9-b10c-979268be974f" name="Parameters" order-num="0" child-type="parameter" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Procedures,procedure upl_LoadXMLFromFile,category Parameters">
                            <parameter _I_D="496633c0-c317-4e26-a157-886c49b485dd" name="par_tcfilename" dt-name="VARCHAR" dt-attr-1="255" transformed="2022-09-14 15:32:53" argument-order="1" argument-datatype="varchar" argument-mode="IN" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Procedures,procedure upl_LoadXMLFromFile,category Parameters,parameter \@tcFileName" source-vendor="MSSQL"/>
                            <parameter _I_D="72d2c186-4b1e-405e-9d3e-d1e3d414635e" name="par_tcxmlstring" dt-name="VARCHAR" dt-attr-1="8000" transformed="2022-09-14 15:32:53" argument-order="2" argument-datatype="varchar" argument-mode="INOUT" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Procedures,procedure upl_LoadXMLFromFile,category Parameters,parameter \@tcXMLString" source-vendor="MSSQL"/>
                        </category>
                    </procedure>
                </category>
                <category _I_D="29d88831-6ed4-43a2-8452-7b1fbe92e069" name="Functions" order-num="5" child-type="function" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category SQL scalar functions"/>
                <category _I_D="6226c2e7-0614-4cf5-919b-4cf55656b98c" name="Sequences" order-num="10" child-type="sequence" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Sequences"/>
                <category _I_D="18543cd4-e926-4d70-82a4-cfa03658393b" name="Domains" order-num="11" child-type="domain" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Types"/>
                <category _I_D="8fcdf91d-ba03-4a03-96b2-cdef1fde7510" name="User defined types" order-num="12" child-type="table-type" transformed="2022-09-14 15:32:53" artificial-src-full-name="category Databases,database IEAccountinginUSD,category Schemas,schema upload,category Table types"/>
            </schema>
        </category>
        <category _I_D="7669bfed-07cd-401c-a7bd-d7e31beda66d" name="Foreign Servers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="foreign-server"/>
        <category-group _I_D="d193c41a-63c0-4f94-bf92-dd2e6d88b25f" name="Server Level Objects" order-num="2" objects-loading="empty" subcategories-loading="full">
            <category _I_D="04bd88a8-8060-4a57-8df6-38e3c90df7a4" name="Contexts" order-num="0" objects-loading="empty" subcategories-loading="full" child-type="context"/>
        </category-group>
        <category _I_D="1d86a26b-dfdd-48e3-945a-83fb493a18db" name="SQL Scripts" script-root="true" disable-autocommit="true" data-format="DD-MON-RR" sql-plus-settings="{&quot;tnsAliases&quot;:[]}"/>
    </metadata>
</tree>